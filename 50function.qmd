---
title: "함수 및 모듈"
format: html
---

## 함수 {#sec-function}

함수는(Function) 특정 작업을 수행하는 코드 블록으로, 코드의 재사용성을 높이고 가독성을 개선하는 역할을 한다. Python에서 함수는 `def` 키워드를 사용하여 정의한다.

::: {#nte-function .callout-note icon=false title="함수 문법"}
```python
def 함수이름(매개변수1, 매개변수2, ...):
    """문서화 문자열 (docstring)"""
    실행할 코드
    return 반환값  # (선택 사항)
```

- def 키워드로 함수 정의를 시작한다.
- 함수이름은 함수의 이름을 나타낸다.
- 매개변수(parameter)는 함수에 전달될 값을 받는 변수이며, 생략 가능하다.
d- ocstring(선택 사항)은 함수의 목적을 설명하는 문자열이다.
return 문을 사용하여 값을 반환할 수 있다. 반환이 필요하지 않다면 생략 가능하다.
:::

### 함수 정의 및 호출

함수 정의 및 호출 문법 [@nte-function]에 따라 수행한다.

```{python}
def add(a, b):
    return a + b

result = add(3, 5)
print(result) 
```
- `def` 키워드로 함수를 정의한다.
- `add(a, b)`: 두 개의 매개변수(`a`, `b`)를 받아 더한 값을 반환한다.
- `return` 문을 사용하여 결과를 반환한다.
- `add(3, 5)`와 같이 호출하면 8이 출력된다.

### 매개변수와 반환값

Python에서 함수 매개변수는 함수를 호출할 때 전달되는 값(인자, argument)을 받는 변수이다. 매개변수를 설정하는 방식에 따라 다양한 형태로 사용할 수 있다.  

| 매개변수 유형 | 설명 | 예시 |
|-------------|------|------|
| 기본 매개변수 | 필수 인자를 받아야 하는 매개변수 | `def func(a, b):` |
| 기본값 매개변수 | 기본값을 설정할 수 있는 매개변수 | `def func(a, b=10):` |
| 위치 인자 | 순서에 따라 전달되는 인자 | `func(1, 2)` |
| 키워드 인자 | `매개변수명=값` 형식으로 전달되는 인자 | `func(a=1, b=2)` |
| 가변 위치 인자(*args) | 여러 개의 위치 인자를 튜플로 받을 수 있음 | `def func(*args):` |
| 가변 키워드 인자(**kwargs) | 여러 개의 키워드 인자를 딕셔너리로 받을 수 있음 | `def func(**kwargs):` |
| 위치 전용 매개변수 | `/` 앞의 매개변수는 위치 인자로만 사용 가능 | `def func(a, b, /):` |
| 키워드 전용 매개변수 | `*` 뒤의 매개변수는 키워드 인자로만 사용 가능 | `def func(*, a, b):` |
: 함수 매개변수 유형

이러한 매개변수 방식을 조합하여 다양한 형태의 함수를 정의할 수 있다.

#### 기본 매개변수(Required Parameters)  
함수를 정의할 때 매개변수를 지정하면, 해당 함수는 반드시 인자를 전달받아야 한다.  

```{python}
#| error: true

def greet(name):
    print(f"안녕하세요, {name}님!")

greet("철수") 

greet()  # 오류 발생 (TypeError)
```
- `greet(name)` 함수는 `name` 매개변수를 필수로 요구한다.
- `greet()` 호출 시 인자를 전달하지 않으면 `TypeError`가 발생한다.  

#### 기본값 매개변수(Default Parameters)  
매개변수에 기본값을 설정하면, 호출 시 인자를 전달하지 않아도 된다.  

```{python}
#| error: true

def greet(name="손님"):
    print(f"안녕하세요, {name}님!")

greet("철수")  

greet()  
```
- `name="손님"`과 같이 기본값을 설정하면, 인자를 전달하지 않을 경우 기본값이 사용된다.


#### 위치 인자(Positional Arguments)  
함수 호출 시 인자의 순서에 따라 매개변수에 값이 할당된다.  

```{python}
def introduce(name, age):
    print(f"제 이름은 {name}이고, {age}살입니다.")

introduce("영희", 25) 

introduce(25, "영희") 
```
- 인자의 순서가 중요하므로, 잘못된 순서로 전달하면 예상치 못한 결과가 나올 수 있다.


#### 키워드 인자(Keyword Arguments)  
함수 호출 시 `매개변수명=값` 형식으로 지정하여 순서를 무시할 수 있다.  

```{python}
introduce(age=30, name="민수")  
# 출력: 제 이름은 민수이고, 30살입니다.
```
- 키워드 인자를 사용하면 가독성이 좋아지고, 인자 순서에 의존하지 않는다.


#### 가변 인자(*args)  
여러 개의 위치 인자를 튜플(tuple) 형태로 받을 수 있다.  

```{python}
def sum_numbers(*args):
    total = sum(args)
    print(f"합계: {total}")

sum_numbers(1, 2, 3)  

sum_numbers(10, 20, 30, 40, 50) 
```
- `*args`는 여러 개의 인자를 받을 수 있으며, `튜플` 형태로 저장된다.
- 매개변수명이 `args`가 아니어도 되지만, **관례적으로 `args`**를 사용한다.


#### 키워드 가변 인자(**kwargs)  
여러 개의 키워드 인자를 딕셔너리(dict) 형태로 받을 수 있다.  

```{python}
def print_info(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_info(name="철수", age=25, city="서울")
```
- `**kwargs`는 키워드 인자를 받을 수 있으며, 딕셔너리 형태로 저장된다.
- `kwargs.items()`를 사용하여 키와 값을 출력할 수 있다.

#### 위치 전용 매개변수(Positional-Only Parameters)  
Python 3.8부터 `/` 기호를 사용하여 특정 매개변수를 위치 인자로만 받을 수 있다.  

```{python}
#| error: true

def multiply(a, b, /):
    return a * b

print(multiply(3, 4))  
# 출력: 12

print(multiply(a=3, b=4))  
# 오류 발생 (TypeError)
```
- `/` 이전의 매개변수들은 위치 인자로만 전달해야 하며, 키워드 인자로 사용할 수 없다.


#### 키워드 전용 매개변수(Keyword-Only Parameters)  
`*` 기호 이후에 정의된 매개변수는 키워드 인자로만 전달해야 한다.  

```{python}
#| error: true

def divide(*, x, y):
    return x / y

print(divide(x=10, y=2))  
# 출력: 5.0

print(divide(10, 2))  
# 오류 발생 (TypeError)
```
- `*` 이후의 매개변수들은 반드시 `키워드 인자`로 전달해야 한다.

---

#### 위치 및 키워드 혼합  
`/`와 `*`를 함께 사용하여 위치 인자, 키워드 인자, 일반 매개변수를 조합할 수 있다.  

```{python}
#| error: true

def function(a, b, /, c, *, d):
    print(a, b, c, d)

function(1, 2, 3, d=4)  

function(1, 2, c=3, d=4)  

function(a=1, b=2, c=3, d=4)  
# 오류 발생 (TypeError)
```
- `a`와 `b`는 위치 인자로만 사용 가능하다.
- `c`는 위치 또는 키워드 인자로 사용할 수 있다.
- `d`는 키워드 인자로만 사용할 수 있다.


#### 매개변수의 기본값과 가변 인자 조합  
기본값이 있는 매개변수와 `*args`, `**kwargs`를 함께 사용할 수 있다.  

```{python}
def example(a, b=10, *args, c=20, **kwargs):
    print(f"a: {a}, b: {b}, c: {c}")
    print(f"args: {args}")
    print(f"kwargs: {kwargs}")

example(1, 2, 3, 4, c=5, d=6, e=7)
```
- `b`와 `c`는 기본값을 가진다.
- `*args`는 위치 인자를 추가적으로 받을 수 있다.
- `**kwargs`는 키워드 인자를 추가적으로 받을 수 있다.

### 익명 함수(lambda) {#sec-lambda} 

Python에서 **익명 함수(lambda)**는 `lambda` 키워드를 사용하여 정의하는 **한 줄짜리 함수**이다. 일반적인 `def` 함수와 달리 이름이 없으며, 간단한 연산을 수행하는 데 사용된다.  

#### lambda 함수 기본 구조  

```python
lambda 매개변수1, 매개변수2, ... : 표현식
```
- `lambda` 키워드로 함수를 정의한다.
- `매개변수`는 여러 개 입력받을 수 있다.
- `:` 이후에 오는 **표현식(expression)**이 반환값이 된다.
- 여러 줄 코드를 작성할 수 없으며, **단일 표현식만** 사용 가능하다.

#### lambda 함수 예제  

```{python}
# 일반적인 함수 정의
def add(a, b):
    return a + b

# lambda로 변환
add_lambda = lambda a, b: a + b

print(add(3, 5))        # 8
print(add_lambda(3, 5)) # 8
```
- `lambda a, b: a + b`는 `add(a, b)` 함수와 동일하게 동작한다.


#### lambda 함수 활용 예시  

##### 변수에 할당하여 사용  

```{python}
multiply = lambda x, y: x * y
print(multiply(4, 5))  # 20
```
- `lambda x, y: x * y`는 두 숫자의 곱을 반환하는 함수이다.

##### lambda와 `map()` 함수  

```{python}
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x ** 2, numbers))
print(squared)  # [1, 4, 9, 16, 25]
```
- `map(lambda x: x ** 2, numbers)`는 리스트의 각 요소를 제곱한다.

##### lambda와 `filter()` 함수  

```{python}
numbers = [1, 2, 3, 4, 5, 6]
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(even_numbers)  # [2, 4, 6]
```
- `filter(lambda x: x % 2 == 0, numbers)`는 리스트에서 짝수만 필터링한다.

##### lambda와 `sorted()` 함수  

```{python}
students = [("철수", 90), ("영희", 85), ("민수", 95)]
sorted_students = sorted(students, key=lambda x: x[1], reverse=True)
print(sorted_students)
```
- `key=lambda x: x[1]`을 사용하여 두 번째 요소(점수)를 기준으로 정렬한다.

##### lambda와 `reduce()` 함수  

```{python}
from functools import reduce

numbers = [1, 2, 3, 4, 5]
result = reduce(lambda x, y: x * y, numbers)
print(result)  # 120 (1 * 2 * 3 * 4 * 5)
```
- `reduce(lambda x, y: x * y, numbers)`는 리스트의 모든 요소를 곱한다.

#### lambda와 일반 함수 비교  

| 비교 항목 | lambda 함수 | 일반 함수 (`def`) |
|---------|------------|------------------|
| **정의 방식** | `lambda` 키워드 사용 | `def` 키워드 사용 |
| **이름** | 없음(익명 함수) | 있음 |
| **코드 길이** | 한 줄로 작성 | 여러 줄 작성 가능 |
| **반환값** | 자동으로 표현식의 결과 반환 | `return`을 사용해야 함 |
| **사용 용도** | 간단한 연산 | 복잡한 로직 구현 |

#### lambda 함수 사용이 적절한 경우  

- **한 줄로 간단한 연산을 수행할 때**
- **map, filter, sorted 등의 함수와 함께 사용할 때**
- **굳이 별도 함수를 정의할 필요가 없을 때**

하지만, **복잡한 연산이나 여러 줄의 코드가 필요한 경우에는 `def` 함수가 더 적합**하다.

### 함수 반환값

Python에서 함수는 `return` 키워드를 사용하여 값을 반환할 수 있다. 반환값을 이용하면 함수의 실행 결과를 저장하고, 다른 연산에 활용할 수 있다.  

| 개념 | 설명 |
|------|------|
| **기본 반환값** | `return 값`을 사용해 특정 값을 반환 |
| **여러 개 반환** | `return a, b`를 사용하면 튜플로 반환 |
| **조건부 반환** | `if` 문을 사용해 특정 조건에서만 반환 가능 |
| **리스트/딕셔너리 반환** | 여러 데이터를 리스트나 딕셔너리 형태로 반환 가능 |
| **return 없음** | `None`을 반환 |
| **제너레이터 반환** | `yield`를 사용하면 값들을 순차적으로 생성 |
: 함수 반환값

Python의 `return` 문은 함수의 종료를 의미하며, 다양한 형태의 데이터를 반환할 수 있다.

#### 기본적인 반환값  

```{python}
def add(a, b):
    return a + b

result = add(3, 5)
print(result)  # 8
```
- `return a + b`: 두 숫자의 합을 반환한다.
- 함수 호출 결과 `result` 변수에 저장된다.

#### 여러 개의 반환값  

Python에서는 **여러 개의 값을 반환**할 수 있으며, 이는 **튜플(tuple)**로 반환된다.  

```{python}
def get_info():
    name = "철수"
    age = 25
    return name, age

info = get_info()
print(info)       # ('철수', 25)
print(info[0])    # 철수
print(info[1])    # 25
```
- `return name, age`는 `(name, age)` 형태의 튜플을 반환한다.
- 반환값을 여러 변수에 **언패킹(unpacking)**하여 받을 수도 있다.

```{python}
name, age = get_info()
print(name)  # 철수
print(age)   # 25
```

#### `return`이 없는 함수  

- `return` 문이 없거나, `return` 키워드만 사용하면 **`None`이 반환**된다.  

```{python}
def greet():
    print("안녕하세요!")

result = greet()
print(result)  # None
```
- `print()` 함수는 값을 반환하지 않으므로 `None`이 저장된다.

#### 조건에 따른 반환값  

- 함수 내에서 특정 조건을 만족할 때만 값을 반환할 수 있다.  

```{python}
def check_even(n):
    if n % 2 == 0:
        return "짝수"
    return "홀수"

print(check_even(4))  # 짝수
print(check_even(7))  # 홀수
```
- `return "짝수"` 실행 후 함수가 종료되므로, 이후 코드는 실행되지 않는다.

## 5. 리스트나 딕셔너리 반환  

먼저 **리스트 반환**이다.  

```{python}
def get_numbers():
    return [1, 2, 3, 4, 5]

print(get_numbers())  # [1, 2, 3, 4, 5]
```

**딕셔너리 반환**이다.  

```{python}
def get_student():
    return {"name": "영희", "age": 22}

print(get_student())  # {'name': '영희', 'age': 22}
```

#### `return`과 `None` 비교  

| 상황 | 반환값 |
|------|--------|
| `return 값` 사용 | 해당 값 반환 |
| `return`만 사용 | `None` 반환 |
| `return`이 없는 함수 | `None` 반환 |

```{python}
def example():
    return

print(example())  # None
```

#### `yield`를 사용한 제너레이터 반환  

- `return` 대신 `yield`를 사용하면 **제너레이터(generator)**를 반환한다.  

```{python}
def count_up(n):
    for i in range(n):
        yield i

gen = count_up(3)
print(list(gen))  # [0, 1, 2]
```
- `yield`는 값을 하나씩 생성하며, `return`과 달리 **함수를 종료하지 않는다**.

### 재귀함수 {#sec-recursive-function}  

Python에서 **재귀함수(recursive function)**는 **자기 자신을 호출하는 함수**를 의미한다. 반복문 없이 특정 작업을 반복할 수 있으며, **분할 정복(Divide and Conquer)** 같은 알고리즘에서 자주 사용된다.  

#### 재귀함수의 기본 구조  

```python
def recursive():
    print("재귀 호출")
    recursive()  # 자기 자신을 호출

recursive()  # 실행하면 무한 루프 발생
```
- 함수 `recursive()` 내부에서 다시 `recursive()`를 호출한다.
- 종료 조건이 없으면 무한 루프에 빠지므로, **반드시 종료 조건(base case)**을 설정해야 한다.

#### 종료 조건을 포함한 재귀함수  

```{python}
def countdown(n):
    if n <= 0:  # 종료 조건
        print("끝!")
        return
    print(n)
    countdown(n - 1)  # 자기 자신을 호출 (n 감소)

countdown(5)
```

- `n`이 0 이하가 되면 `return`하여 종료된다.
- 종료 조건이 없다면 **무한 재귀**(infinite recursion)가 발생한다.

#### 재귀함수를 이용한 팩토리얼 계산  

```{python}
def factorial(n):
    if n == 0 or n == 1:  # 종료 조건
        return 1
    return n * factorial(n - 1)  # 자기 자신을 호출

print(factorial(5))  # 120
```
- `factorial(5) = 5 * 4 * 3 * 2 * 1 = 120`
- 종료 조건 `if n == 0 or n == 1`을 설정하여 재귀를 멈춘다.

---

#### 재귀함수를 이용한 피보나치 수열  

피보나치 수열:  
$$F(n) = F(n-1) + F(n-2), \quad F(0) = 0, \quad F(1) = 1$$  

```{python}
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)  # 재귀 호출

print(fibonacci(6))  # 8
```
- `fibonacci(6) = fibonacci(5) + fibonacci(4) = 8`
- 종료 조건을 설정하지 않으면 무한 루프에 빠질 수 있다.

#### 재귀 깊이 제한 (Recursion Limit)  

Python은 기본적으로 **재귀 호출 가능 횟수(깊이)를 제한**한다.  
기본 최대 깊이: **1,000번**  

```python
import sys
print(sys.getrecursionlimit())  # 1000
```
- 너무 깊이 재귀 호출하면 `RecursionError` 발생  

**재귀 깊이 제한 변경 가능**  

```python
sys.setrecursionlimit(2000)  # 최대 재귀 깊이를 2000으로 설정
```
- 하지만 **너무 높은 값으로 설정하면 메모리 부족 오류 발생 가능**  

#### 재귀와 반복문의 비교  

| 비교 항목 | 재귀함수 | 반복문 |
|----------|--------|------|
| **사용 방식** | 자기 자신을 호출 | `for` 또는 `while` 사용 |
| **메모리 사용** | 호출마다 스택 메모리 사용 | 상대적으로 적은 메모리 사용 |
| **속도** | 함수 호출 오버헤드로 느릴 수 있음 | 일반적으로 빠름 |
| **코드 가독성** | 일부 문제에서 직관적 | 대부분의 경우 더 명확 |
| **종료 필요** | 종료 조건(base case) 필수 | `break`나 조건문 사용 |
: 재귀함수와 반복문 비교

#### 꼬리 재귀(Tail Recursion)  

- **꼬리 재귀(Tail Recursion)**: 함수의 마지막 동작이 **자기 자신을 호출하는 형태**  
- 일반적으로 **반복문으로 변환 가능**하며, 일부 언어에서는 **최적화(Tail Call Optimization, TCO)**를 지원하지만, Python은 지원하지 않는다.

```{python}
def tail_recursive(n, result=1):
    if n == 0:
        return result
    return tail_recursive(n - 1, n * result)  # 변수로 결과 유지

print(tail_recursive(5))  # 120
```

---

## 8. 재귀함수 사용이 적절한 경우  

- **문제를 작은 부분으로 나눌 수 있는 경우**  
- **이진 탐색(Binary Search)**
- **분할 정복 알고리즘 (Merge Sort, Quick Sort)**
- **트리(Tree) 또는 그래프(Graph) 탐색 (DFS)**
- **하노이 탑(Tower of Hanoi) 문제**

하지만, **일반적인 반복문으로 해결 가능한 경우에는 재귀보다 반복문을 사용하는 것이 성능상 유리**하다.
```

### 함수 범위

변수는 호출 위치와 키워드 사용 여부에 따라 그 범위가 결정된다.

- **지역 변수(Local Variable)**: 함수 내부에서 정의된 변수로, 함수 내부에서만 접근 가능하다.
- **전역 변수(Global Variable)**: 함수 외부에서 정의된 변수로, 프로그램 전체에서 접근 가능하다.

```{python}
x = 10  # 전역 변수

def func():
    x = 5  # 지역 변수
    print(x)

func()  # 5
print(x)  # 10
```

전역 변수 값을 함수 내부에서 변경하려면 `global` 키워드를 사용해야 한다.

```{python}
x = 10

def change_x():
    global x
    x = 20

change_x()
print(x)  # 20
```

### 함수 데코레이터
함수를 감싸는 래퍼(wrapper) 역할을 하며, 실행 전후에 특정 동작을 추가할 수 있다.
```{python}
def decorator(func):
    def wrapper():
        print("함수 실행 전")
        func()
        print("함수 실행 후")
    return wrapper

@decorator
def hello():
    print("안녕하세요!")

hello()
```

### 함수형 프로그래밍 개념

**map 함수**: 리스트의 각 요소에 함수를 적용한다.

```{python}
numbers = [1, 2, 3, 4]
squared = list(map(lambda x: x ** 2, numbers))
print(squared)
```

**filter 함수**: 리스트의 요소를 조건에 맞게 필터링한다.

```{python}
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(even_numbers)  # [2, 4]
```

**reduce 함수**: 리스트의 요소를 누적하여 하나의 결과를 만든다.
```{python}
from functools import reduce
total = reduce(lambda x, y: x + y, numbers)
print(total)  # 10
```
## 모듈 {#sec-module}

