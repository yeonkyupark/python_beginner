[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "파이썬 다루기",
    "section": "",
    "text": "들어가기",
    "crumbs": [
      "들어가기"
    ]
  },
  {
    "objectID": "index.html#파이썬-소개",
    "href": "index.html#파이썬-소개",
    "title": "파이썬 다루기",
    "section": "1. 파이썬 소개",
    "text": "1. 파이썬 소개\n\n파이썬이란?\n\n파이썬의 특징과 장점\n\n설치 및 개발 환경 설정(VS Code, Jupyter Notebook)\n\n첫 번째 프로그램: “Hello, World!” 출력",
    "crumbs": [
      "들어가기"
    ]
  },
  {
    "objectID": "index.html#기본-문법",
    "href": "index.html#기본-문법",
    "title": "파이썬 다루기",
    "section": "2. 기본 문법",
    "text": "2. 기본 문법\n\n변수와 데이터 타입(숫자, 문자열, 불리언)\n\n연산자(산술, 비교, 논리, 대입 연산자)\n\n주석 사용법",
    "crumbs": [
      "들어가기"
    ]
  },
  {
    "objectID": "index.html#자료형과-자료-구조",
    "href": "index.html#자료형과-자료-구조",
    "title": "파이썬 다루기",
    "section": "3. 자료형과 자료 구조",
    "text": "3. 자료형과 자료 구조\n\n리스트(List)\n\n튜플(Tuple)\n\n딕셔너리(Dictionary)\n\n집합(Set)\n\n문자열(String) 다루기",
    "crumbs": [
      "들어가기"
    ]
  },
  {
    "objectID": "index.html#제어문",
    "href": "index.html#제어문",
    "title": "파이썬 다루기",
    "section": "4. 제어문",
    "text": "4. 제어문\n\n조건문(if-elif-else)\n\n반복문(for, while)\n\n반복문 제어문(break, continue)",
    "crumbs": [
      "들어가기"
    ]
  },
  {
    "objectID": "index.html#함수와-모듈",
    "href": "index.html#함수와-모듈",
    "title": "파이썬 다루기",
    "section": "5. 함수와 모듈",
    "text": "5. 함수와 모듈\n\n함수 정의 및 호출\n\n매개변수와 반환값\n\n내장 함수 활용\n\n모듈과 패키지(import 사용법)",
    "crumbs": [
      "들어가기"
    ]
  },
  {
    "objectID": "index.html#파일-입출력",
    "href": "index.html#파일-입출력",
    "title": "파이썬 다루기",
    "section": "6. 파일 입출력",
    "text": "6. 파일 입출력\n\n파일 열기와 닫기(open, close)\n\n파일 읽기(read, readline, readlines)\n\n파일 쓰기(write)",
    "crumbs": [
      "들어가기"
    ]
  },
  {
    "objectID": "index.html#예외-처리",
    "href": "index.html#예외-처리",
    "title": "파이썬 다루기",
    "section": "7. 예외 처리",
    "text": "7. 예외 처리\n\n예외 발생과 처리(try-except)\n\n다양한 예외 종류",
    "crumbs": [
      "들어가기"
    ]
  },
  {
    "objectID": "index.html#클래스-기초",
    "href": "index.html#클래스-기초",
    "title": "파이썬 다루기",
    "section": "8. 클래스 기초",
    "text": "8. 클래스 기초\n\n클래스와 객체 개념\n\n생성자(__init__)와 속성\n\n메서드 정의 및 호출",
    "crumbs": [
      "들어가기"
    ]
  },
  {
    "objectID": "index.html#주요-패키지",
    "href": "index.html#주요-패키지",
    "title": "파이썬 다루기",
    "section": "9. 주요 패키지",
    "text": "9. 주요 패키지\n\n유용한 표준 라이브러리(os, datetime, random 등)\n\n데이터 분석 기초(pandas, numpy 간단 사용법)",
    "crumbs": [
      "들어가기"
    ]
  },
  {
    "objectID": "index.html#참고자료",
    "href": "index.html#참고자료",
    "title": "파이썬 다루기",
    "section": "참고자료",
    "text": "참고자료\n\n코드 시각화 - https://pythontutor.com/visualize.html#mode=edit",
    "crumbs": [
      "들어가기"
    ]
  },
  {
    "objectID": "10python.html",
    "href": "10python.html",
    "title": "파이썬 개요",
    "section": "",
    "text": "프로그래밍 언어",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>파이썬 개요</span>"
    ]
  },
  {
    "objectID": "10python.html#프로그래밍-언어란",
    "href": "10python.html#프로그래밍-언어란",
    "title": "파이썬 개요",
    "section": "프로그래밍 언어란?",
    "text": "프로그래밍 언어란?\n프로그래밍 언어는 컴퓨터가 이해하고 실행할 수 있는 명령을 작성하기 위한 언어이다. 사람이 이해할 수 있는 문법과 구조를 사용하여 컴퓨터에게 특정 작업을 수행하도록 지시한다.\n\n프로그래밍 언어의 종류\n저급 언어 (Low-Level Language) - 기계어와 가까운 언어로, 컴퓨터가 직접 실행할 수 있는 코드에 가깝다. - 예시: 기계어(Machine Code), 어셈블리어(Assembly Language) - 특징: 실행 속도가 빠르지만 사람이 이해하고 작성하기 어렵다.\n고급 언어 (High-Level Language) - 사람이 이해하기 쉬운 문법을 사용하며, 컴파일러나 인터프리터를 통해 기계어로 변환된다. - 예시: Python, Java, C++, JavaScript 등 - 특징: 직관적인 문법을 제공하며, 생산성이 높고 유지보수가 용이하다.\n\n\n프로그래밍 언어의 실행 방식\n\n프로그래밍 언어 실행 방식\n\n\n\n\n\n\n실행 방식\n설명\n\n\n\n\n컴파일 언어\n소스 코드를 기계어로 변환한 후 실행 파일을 생성하여 실행하는 방식. 실행 속도가 빠름.  예시: C, C++, Java (JVM 사용)\n\n\n인터프리터 언어\n소스 코드를 한 줄씩 해석하며 실행하는 방식. 개발 속도가 빠르지만 실행 속도가 비교적 느림.  예시: Python, JavaScript, Ruby\n\n\n혼합형 (JIT 컴파일)\n컴파일과 인터프리팅 방식을 혼합하여 실행 성능을 최적화한 방식.  예시: Java (JIT 컴파일을 사용하여 실행 속도를 높임)\n\n\n\n\n\n대표적인 프로그래밍 언어 및 특징\n\n대표적인 프로그래밍 언어\n\n\n\n\n\n\n언어\n특징\n\n\n\n\nC\n하드웨어 제어가 가능하고 성능이 뛰어나며, 운영체제 및 시스템 프로그래밍에 많이 사용됨.\n\n\nC++\n객체지향 프로그래밍(OOP) 기능을 추가한 C 기반 언어로, 게임 개발 및 고성능 애플리케이션에 많이 사용됨.\n\n\nPython\n문법이 간결하고 배우기 쉬우며, 데이터 과학, 인공지능(AI), 웹 개발 등 다양한 분야에서 활용됨.\n\n\nJava\n플랫폼 독립적(Write Once, Run Anywhere)이며, 기업용 소프트웨어 및 안드로이드 앱 개발에 많이 사용됨.\n\n\nJavaScript\n웹 개발에서 주로 사용되며, 브라우저에서 실행되는 동적 언어. Node.js를 통해 서버 개발도 가능함.\n\n\nRuby\n문법이 간결하고 직관적이며, 웹 개발에서 인기 있는 프레임워크인 Ruby on Rails를 제공함.\n\n\nGo\n구글이 개발한 언어로, 높은 성능과 간결한 문법을 제공하며, 대규모 네트워크 및 서버 애플리케이션에 적합함.\n\n\nSwift\n애플이 iOS 및 macOS 개발을 위해 만든 언어로, 성능이 뛰어나고 안전성을 고려한 설계를 가짐.\n\n\n\n프로그래밍 언어는 목적에 따라 선택해야 하며, 특정 분야(웹 개발, 데이터 분석, 시스템 프로그래밍 등)에 적합한 언어를 배우는 것이 중요하다.\n2025년 1월 기준, Python이 TIOBE 순위1 1위를 차지 하였다.\n\n\n\n프로그래밍 언어 순위\n\n\n\n\n\n년도별 언어 순위 추이",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>파이썬 개요</span>"
    ]
  },
  {
    "objectID": "10python.html#파이쎤-소개",
    "href": "10python.html#파이쎤-소개",
    "title": "파이썬 개요",
    "section": "파이쎤 소개",
    "text": "파이쎤 소개\n\n\n\npython\n\n\n파이썬(Python)은 배우기 쉽고 강력한 기능을 갖춘 프로그래밍 언어이다. 문법이 간결하고 가독성이 높아 초보자부터 전문가까지 폭넓게 사용하고 있다.\n\n파이썬의 특징\n\n\n\nhttps://xkcd.com/353/\n\n\n파이썬은 다음과 같은 특징을 갖는다.\n\n쉬운 문법: 영어와 비슷한 구문 구조를 가지고 있어 처음 배우는 사람도 쉽게 익힐 수 있다.\n\n높은 생산성: 적은 코드로 강력한 기능을 구현할 수 있어 개발 속도가 빠르다.\n\n다양한 활용 분야: 웹 개발, 데이터 분석, 인공지능, 자동화 등 다양한 분야에서 사용된다.\n\n강력한 커뮤니티: 많은 개발자가 사용하며 다양한 라이브러리와 자료가 제공된다.\n\n\n\n\n\n\n\n파일 내용 읽어 오기\n\n\n\nC 코드\n#include &lt;stdio.h&gt; \nint main() { \n   FILE *file = fopen(\"text.txt\", \"r\"); \n   char line[100]; \n   if (file) { \n      while (fgets(line, sizeof(line), file)) { \n         printf(\"%s\", line); \n      } \n      fclose(file); \n   } \n   return 0; \n}\n\n파이썬 코드\nwith open(\"text.txt\", \"r\") as file: \n   print(file.read())\n\n\n\n\n파이썬의 활용 분야\n파이썬 주요 활용 분야는 다음과 같다.\n\n웹 개발: Django, Flask와 같은 프레임워크를 활용하여 웹사이트와 API를 개발할 수 있다.\n\n데이터 분석 및 인공지능: pandas, NumPy, TensorFlow 등 라이브러리를 이용하여 데이터 처리와 머신러닝 모델을 만들 수 있다.\n\n자동화 및 스크립트: 반복 작업을 자동화하는 데 유용하며, 파일 처리 및 웹 스크래핑 등에 활용된다.\n\n게임 개발: Pygame과 같은 라이브러리를 이용하여 간단한 게임을 만들 수 있다.\n\n파이썬은 초보자도 쉽게 배울 수 있으면서도 강력한 기능을 제공하는 언어로, 프로그래밍을 처음 접하는 사람에게 추천할 만한 언어이다.\n\n\n파이썬의 장점과 단점\n파이썬은 쉽고 강력한 프로그래밍 언어지만, 다른 언어와 비교했을 때 장점과 단점이 존재한다. 아래 표를 통해 주요 특징을 정리한다.\n\n파이썬 장단점\n\n\n\n\n\n\n\n구분\n장점\n단점\n\n\n\n\n문법\n코드가 간결하고 가독성이 높아 초보자도 쉽게 배울 수 있다.\n동적 타이핑(dynamic typing)으로 인해 대규모 프로젝트에서 예상치 못한 오류가 발생할 수 있다.\n\n\n속도\n인터프리터 언어로 개발 속도가 빠르고 유지보수가 용이하다.\n컴파일 언어(C, C++)보다 실행 속도가 느리다.\n\n\n확장성\n다양한 라이브러리와 프레임워크가 제공되어 다양한 분야에서 활용 가능하다.\n모바일 앱 개발에 적합한 프레임워크와 지원이 부족하다.\n\n\n다중 패러다임\n객체 지향, 절차적, 함수형 프로그래밍을 모두 지원한다.\n다중 스레드 성능이 GIL(Global Interpreter Lock)으로 인해 제한된다.\n\n\n활용 분야\n웹 개발, 데이터 분석, 인공지능, 자동화 등 다양한 분야에서 사용된다.\n실시간 시스템, 임베디드 시스템과 같은 성능이 중요한 환경에서는 부적절할 수 있다.\n\n\n\n파이썬은 배우기 쉽고 다양한 활용이 가능하다는 점에서 강력한 언어지만, 실행 속도나 멀티스레딩 제한과 같은 단점도 존재한다. 따라서 사용 목적에 따라 적절한 언어를 선택하는 것이 중요하다.",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>파이썬 개요</span>"
    ]
  },
  {
    "objectID": "10python.html#sec-install-python",
    "href": "10python.html#sec-install-python",
    "title": "파이썬 개요",
    "section": "파이썬 설치",
    "text": "파이썬 설치\n파이썬을 설치하는 방법은 운영 체제에 따라 다를 수 있지만, 일반적으로 공식 웹사이트에서 설치 파일을 다운로드하여 설치하는 방식이 가장 쉽다.\n\n파이썬 다운로드\n\n파이썬 공식 웹사이트에 접속한다.\n\n상단 메뉴에서 Downloads를 클릭한 후, 사용 중인 운영 체제(Windows, macOS, Linux)에 맞는 최신 버전의 파이썬을 다운로드한다.\n\n\n\nWindows에서 설치\n\n다운로드한 python-버전번호.exe 파일을 실행한다.\n\n“Add Python to PATH” 옵션을 체크한 후 “Install Now” 버튼을 클릭한다.\n\n설치가 완료되면 “Close” 버튼을 클릭한다.\n\n\n\nmacOS에서 설치\n\n다운로드한 python-버전번호.pkg 파일을 실행한다.\n\n설치 마법사의 안내에 따라 진행한다.\n\n설치가 완료되면 터미널을 열어 아래 명령어를 실행하여 설치를 확인한다.\n\n\n\nLinux(Ubuntu)에서 설치\n\n터미널을 열고 다음 명령어를 실행한다.\nsudo apt update\nsudo apt install python3\n\n\n\n설치 확인\n\n터미널(또는 명령 프롬프트, PowerShell)을 열고 아래 명령어를 입력한다.\npython --version\n설치된 파이썬 버전이 출력되면 정상적으로 설치된 것이다.\n\n설치 후에는 IDLE, VS Code, Jupyter Notebook 등의 개발 환경을 설정하여 코딩을 시작할 수 있다.",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>파이썬 개요</span>"
    ]
  },
  {
    "objectID": "10python.html#개발-환경-설정",
    "href": "10python.html#개발-환경-설정",
    "title": "파이썬 개요",
    "section": "개발 환경 설정",
    "text": "개발 환경 설정\n\nVS Code\nVS Code(Visual Studio Code)는 마이크로소프트에서 제공하는 무료 코드 편집기로, 파이썬 개발 환경으로 많이 사용된다. 가벼우면서도 확장성이 뛰어나 초보자부터 전문가까지 널리 활용된다.\n\n\n\nVisual Studio Code\n\n\n\nVS Code 다운로드\n\nVS Code 공식 웹사이트에 접속한다.\n\n사용 중인 운영 체제(Windows, macOS, Linux)에 맞는 설치 파일을 다운로드한다.\n\n\n\nWindows에서 설치\n\n다운로드한 VSCodeUserSetup.exe 파일을 실행한다.\n\n설치 마법사가 실행되면 “Next”를 눌러 진행한다.\n\n설치 옵션에서 “Add to PATH” 항목을 체크한다.\n\n“Install” 버튼을 클릭하여 설치를 완료한 후, “Finish”를 눌러 실행한다.\n\n\n\nmacOS에서 설치\n\n다운로드한 VSCode-darwin.zip 파일을 압축 해제한다.\n\nVisual Studio Code.app을 응용 프로그램(Applications) 폴더로 이동한다.\n\n터미널에서 VS Code를 쉽게 실행하려면 아래 명령어를 입력하여 code 명령어를 등록한다.\nsudo ln -s /Applications/Visual\\ Studio\\ Code.app/Contents/Resources/app/bin/code /usr/local/bin/code\n\n\n\nLinux(Ubuntu)에서 설치\n\n터미널을 열고 다음 명령어를 실행하여 설치한다.\nsudo apt update\nsudo apt install code\n설치가 완료되면 아래 명령어를 입력하여 실행한다.\ncode\n\n\n\nVS Code에서 파이썬 개발 환경 설정\n\n1) 파이썬 확장 프로그램 설치\n\nVS Code를 실행하고 확장(Extensions) 메뉴(Ctrl + Shift + X)를 연다.\n\n검색창에 “Python”을 입력하고 Microsoft 제공 Python 확장 프로그램을 설치한다.\n\n\n\n2) 기본 인터프리터 설정\n\nCtrl + Shift + P를 눌러 명령 팔레트(Command Palette)를 연다.\n\n“Python: Select Interpreter”를 선택한 후 설치된 파이썬 경로를 선택한다.\n\n터미널에서 python --version을 실행하여 정상적으로 설정되었는지 확인한다.\n\n\n\n3) 실행 및 디버깅\n\n.py 파일을 만들고 파이썬 코드를 작성한다.\n\nF5 키를 눌러 실행하고 결과를 확인한다.\n\n\n\n\n설치 확인\n\nVS Code에서 Ctrl + ` 키를 눌러 터미널을 연다.\n\n아래 명령어를 입력하여 파이썬이 정상적으로 동작하는지 확인한다.\npython --version\n\n설치가 완료되면 VS Code를 활용하여 편리하게 파이썬 프로그래밍을 진행할 수 있다. 자세한 사용법은 VS Code 튜토리얼을 참고한다.\n\nhttps://code.visualstudio.com/docs/getstarted/getting-started\n\n\n\n\nJupyter Notebook\nJupyter Notebook은 웹 기반의 대화형 개발 환경으로, 파이썬 코드 실행과 문서화를 동시에 할 수 있어 데이터 분석 및 머신러닝 작업에 많이 사용된다.\n\n\n\n\nhttps://jupyter-notebook.readthedocs.io/en/latest/\n\n\n\n\nJupyter Notebook 설치 전 준비\nJupyter Notebook을 사용하려면 먼저 파이썬이 설치되어 있어야 한다.\n\n아래 명령어를 실행하여 파이썬이 설치되어 있는지 확인한다.\npython --version\n설치되어 있지 않다면 파이썬 공식 사이트에서 설치한다(파이썬 설치 참고).\n\n\n\nJupyter Notebook 설치\n\n1) pip을 이용한 설치\n\n터미널(또는 명령 프롬프트)을 열고 아래 명령어를 입력한다.\npip install notebook\n설치가 완료되면 jupyter --version을 실행하여 정상적으로 설치되었는지 확인한다.\n\n\n\n2) Anaconda를 이용한 설치\n\nAnaconda 공식 사이트에서 설치 파일을 다운로드한다.\n\n설치 후, 터미널(또는 Anaconda Prompt)에서 아래 명령어를 입력한다.\nconda install jupyter\n설치가 완료되면 jupyter --version을 실행하여 확인한다.\n\n\n\n\nJupyter Notebook 실행\n\n터미널 또는 명령 프롬프트에서 아래 명령어를 입력한다.\njupyter notebook\n자동으로 웹 브라우저가 열리며 Jupyter Notebook 인터페이스가 실행된다.\n\n\n\nJupyter Notebook 사용 방법\n\n1) 새 노트북 생성\n\nJupyter Notebook 실행 후, New &gt; Python 3을 클릭하여 새로운 노트북을 만든다.\n\n\n\n2) 코드 실행\n\n코드 셀에 파이썬 코드를 입력한 후, Shift + Enter를 눌러 실행한다.\nprint(\"Hello, Jupyter Notebook!\")\n\n\n\n3) 저장 및 종료\n\n파일 &gt; Save and Checkpoint를 선택하여 작업을 저장한다.\n\nJupyter Notebook을 종료하려면 터미널에서 Ctrl + C를 누르고 y를 입력한다.\n\n설치가 완료되면 Jupyter Notebook을 활용하여 데이터 분석, 머신러닝, 문서 작성 등을 편리하게 수행할 수 있다. 자세한 사용법은 Jupyter Notebook 튜토리얼을 참고한다.\n\nhttps://docs.jupyter.org/en/latest/start/index.html\n\n\n\n\n\nPyCharm\n\n\n\nPyCharm\n\n\n\nPyCharm 다운로드\n\n웹 브라우저를 열고 PyCharm 공식 웹사이트(https://www.jetbrains.com/pycharm/)에 접속한다.\n“Download” 버튼을 클릭한다.\n운영체제(Windows, macOS, Linux)에 맞는 버전을 선택한다.\n버전 선택:\n\nCommunity Edition (무료): 기본적인 기능을 제공하며, 일반적인 파이썬 개발에 충분하다.\nProfessional Edition (유료, 30일 체험 가능): 웹 개발, 데이터베이스, 과학 연산 등 고급 기능이 포함되어 있다.\n\n원하는 버전을 선택한 후 “Download” 버튼을 클릭하여 설치 파일을 다운로드한다.\n\n\nPyCharm 설치\n\nWindows\n\n\n다운로드한 pycharm-community-*.exe 또는 pycharm-professional-*.exe 파일을 실행한다.\n설치 마법사가 나타나면 “Next” 버튼을 클릭한다.\n설치 경로를 선택한 후 “Next” 버튼을 클릭한다.\n선택 옵션에서 필요에 따라 다음을 설정한다.\n\n“Create Desktop Shortcut”: 바탕화면에 바로 가기 아이콘 생성\n“Update PATH variable”: 명령 프롬프트에서 pycharm 명령어 실행 가능하도록 설정\n\n“Install” 버튼을 클릭하여 설치를 진행한다.\n설치가 완료되면 “Run PyCharm Community” 옵션을 선택한 후 “Finish” 버튼을 클릭한다.\n\n\nmacOS\n\n\n다운로드한 .dmg 파일을 열어 PyCharm 아이콘을 Applications 폴더로 드래그앤드롭한다.\n응용 프로그램(Applications) 폴더에서 PyCharm을 실행한다.\n\n\nLinux\n\n\n.tar.gz 파일을 다운로드한 후 압축을 해제한다.\n터미널에서 PyCharm 실행 파일을 실행한다.\ncd pycharm-community-*/bin\n./pycharm.sh\n\n\n\n\n\nPyCharm 첫 실행 및 설정\n\n처음 실행하면 설정 마이그레이션 옵션이 나타나는데, 기존 설정이 없다면 “Do not import settings”를 선택한다.\nUI 테마 선택 (Darcula 또는 Light) 후 Next 버튼을 클릭한다.\n원하는 플러그인을 설치한 후 Start using PyCharm을 클릭하여 IDE를 시작한다.\n새 프로젝트 생성 또는 기존 프로젝트 열기를 선택하여 개발을 시작한다.\n\nPyCharm이 정상적으로 실행되면 Python 개발 환경을 구성하고 프로젝트를 생성하여 코딩을 시작할 수 있다(PyCharm 사용법 참고).",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>파이썬 개요</span>"
    ]
  },
  {
    "objectID": "10python.html#첫-번째-프로그램",
    "href": "10python.html#첫-번째-프로그램",
    "title": "파이썬 개요",
    "section": "첫 번째 프로그램",
    "text": "첫 번째 프로그램\n\n\n\nHello, World2\n\n\n화면에 “Hello, World”를 출력하는 프로그램을 작성한다.3\n\nprint(\"Hello, World\")\n\nHello, World",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>파이썬 개요</span>"
    ]
  },
  {
    "objectID": "10python.html#참고자료",
    "href": "10python.html#참고자료",
    "title": "파이썬 개요",
    "section": "참고자료",
    "text": "참고자료\n\nIDLE\nIDLE(Integrated Development and Learning Environment)은 파이썬에 기본적으로 포함된 통합 개발 환경(IDE)으로, 초보자가 쉽게 파이썬을 실행하고 학습할 수 있도록 설계된 프로그램이다.\n\n\n\n\nIDLE\n\n\n\n\nIDLE의 특징\n\n기본 제공: 파이썬을 설치하면 자동으로 포함되므로 별도의 설치가 필요하지 않다.\n\nGUI 환경: 코드 편집기와 실행 창을 제공하여 사용자가 쉽게 코드를 작성하고 실행할 수 있다.\n\n대화형 인터프리터: 즉시 코드를 실행하고 결과를 확인할 수 있는 인터랙티브 셸을 제공한다.\n\n문법 강조: 코드 편집 시 색상을 적용하여 가독성을 높여준다.\n\n디버깅 기능: 간단한 디버깅 도구를 제공하여 오류를 찾고 수정할 수 있다.\n\n\n\nIDLE 실행 방법\n\nWindows: 시작 메뉴 &gt; Python &gt; IDLE (Python 버전) 선택\n\nmacOS: 응용 프로그램 &gt; Python 폴더 &gt; IDLE 실행\n\nLinux: 터미널에서 idle3 명령어 입력\n\n\n\nIDLE 사용 방법\n\n대화형 셸(Interactive Shell):\n실행 후 나타나는 창에서 바로 파이썬 코드를 입력하고 실행할 수 있다.\n&gt;&gt;&gt; print(\"Hello, Python!\")\nHello, Python!\n스크립트 작성 및 실행:\nFile &gt; New File을 선택하여 새 파일을 만들고 코드를 작성한 후, F5 키를 눌러 실행할 수 있다.\n\n\n\nIDLE의 장점과 단점\n\n\n\n\n\n\n\n\n구분\n장점\n단점\n\n\n\n\n사용 편의성\n별도 설치 없이 바로 사용 가능하다.\n기능이 제한적이어서 대형 프로젝트에는 부적합하다.\n\n\n학습 도구\n초보자가 배우기에 적합한 환경을 제공한다.\n자동 완성 기능이 부족하여 코드 작성 시 불편할 수 있다.\n\n\n인터랙티브 실행\n코드 실행 결과를 즉시 확인할 수 있다.\n여러 파일을 관리하는 데 비효율적이다.\n\n\n\nIDLE은 파이썬을 처음 배우는 사람에게 적합한 개발 환경이며, 간단한 코드 실습이나 테스트를 할 때 유용하다. 하지만 규모가 큰 프로젝트를 진행할 경우 VS Code, PyCharm 같은 다른 개발 도구를 사용하는 것이 더 효율적이다.\n\n\n\nPyCharm 사용법\nPyCharm은 파이썬 개발을 위한 강력한 IDE(통합 개발 환경)로, 코드 작성, 디버깅, 패키지 관리 등을 쉽게 할 수 있다.\n\nPyCharm 기본 화면 구성\n\n\n\nhttps://www.jetbrains.com/help/pycharm/quick-start-guide.html#ui\n\n\n\n윈도우 헤더: 가장 인기 있는 기능을 빠르게 사용할 수 있도록 여러 도구가 포함된 영역\n\n프로젝트 위젯: 현재 열려 있는 프로젝트 관리\n\nVCS(버전 관리 시스템) 위젯: 코드 변경 사항 추적\n\n실행 위젯: 코드 실행 및 디버깅\n\n기타 기능: Code With Me (협업 도구), Search Everywhere (전체 검색), 설정 열기\n\n프로젝트 도구 창: 화면 왼쪽에 위치하며, 프로젝트에 포함된 파일들을 보여줌\n에디터: 화면 오른쪽에 위치하며, 실제로 코드를 작성하는 공간\n\n여러 파일을 동시에 열어둘 수 있도록 탭 방식으로 구성됨\n\n컨텍스트 메뉴: 인터페이스 요소나 코드 조각을 오른쪽 클릭하면 열리는 메뉴\n\n해당 요소에서 사용할 수 있는 다양한 기능 제공\n\n네비게이션 바: 프로젝트의 폴더와 파일을 빠르게 탐색할 수 있도록 도와주는 도구\n거터(Gutter): 에디터 왼쪽의 세로 줄\n\n브레이크포인트(디버깅을 위해 코드 실행을 멈추는 지점) 표시\n\n코드의 계층 구조(정의/선언 위치) 탐색 지원\n\n라인 번호 및 VCS 변경 내역 표시\n\n스크롤바: 에디터 오른쪽에 위치하며 코드 이동을 지원\n\n코드 품질 검사 결과가 표시됨\n\n오른쪽 상단의 인디케이터를 통해 파일 전체의 코드 품질 상태 확인 가능\n\n도구 창: 작업 공간의 하단 및 측면에 위치한 특수 창\n\n프로젝트 관리, 코드 검색 및 탐색, 버전 관리, 실행, 테스트, 디버깅 등의 기능 제공\n\n상태 표시줄(Status Bar)\n\n현재 프로젝트 및 전체 IDE 상태를 표시\n\n파일 인코딩, 줄 구분자, 코드 검사 프로필 등 다양한 정보 제공\n\nPython 인터프리터 설정을 빠르게 변경할 수 있는 기능 포함\n\n\n\n\n새 프로젝트 생성 및 Python 환경 설정\n\n새 프로젝트 생성\n\n\nPyCharm을 실행하고 “New Project”를 선택한다.\n프로젝트 위치(폴더)를 설정한다.\nPython 인터프리터 선택:\n\n기본 인터프리터 사용: Existing Interpreter에서 현재 설치된 Python을 선택\n새로운 가상 환경 생성: Virtualenv Environment를 선택하여 가상 환경 생성\n\nCreate 버튼을 클릭하여 프로젝트를 생성한다.\n\n\n\n\n\n코드 작성 및 실행\n\n새로운 파이썬 파일 생성\n\n\nProject 창에서 프로젝트 폴더를 우클릭 → New → Python File 선택\n파일 이름을 입력하고 .py 확장자를 지정한 후 Enter 키를 누른다.\n생성된 파일에서 코드 작성\n\n\n코드 실행\n\n\n방법 1: 상단 Run 버튼(▶) 클릭\n방법 2: 코드 파일에서 우클릭 → Run ‘파일명’ 선택\n방법 3: Shift + F10 키를 눌러 실행\n\n\n\n예제 코드\nprint(\"Hello, PyCharm!\")\n\n\n패키지 설치 및 관리\n\n내장 터미널 사용\n\n\npip 명령어를 사용하여 패키지 설치 가능:\npip install numpy\n\n\nPyCharm의 패키지 관리자 사용\n\n\nFile → Settings → Project → Python Interpreter로 이동.\n“+” 버튼을 클릭하여 설치할 패키지를 검색한 후 Install 버튼을 누름.\n\n\n\n\n\n디버깅 (Debugging)\nPyCharm에서는 중단점(Breakpoint)을 설정하여 코드를 단계별로 실행할 수 있다.\n\n코드 줄 번호 왼쪽을 클릭하여 중단점 설정.\n상단 메뉴에서 “Run → Debug ‘파일명’”을 선택.\n실행이 멈추면 변수 값 확인, 단계별 실행(F8), 함수 내부 진입(F7) 등을 활용하여 문제를 찾는다.\n\n\n\n코드 자동 완성 및 리팩토링\n\n코드 자동 완성\n\n\nCtrl + Space를 누르면 함수 및 변수 자동 완성 기능 제공\n\n\n코드 리팩토링\n\n\n변수 또는 함수명을 변경할 때 우클릭 → Refactor → Rename 사용\n\n\n\n\n\n버전 관리(Git 연동)\n\nVCS → Enable Version Control Integration을 클릭\nGit을 선택하고 연동하면 프로젝트를 GitHub 등과 연결 가능\n\n\nPyCharm을 활용하면 파이썬 개발을 더욱 효율적으로 할 수 있으며, 기본적인 코드 작성부터 디버깅, 패키지 관리, Git 연동까지 다양한 기능을 사용할 수 있다.",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>파이썬 개요</span>"
    ]
  },
  {
    "objectID": "10python.html#footnotes",
    "href": "10python.html#footnotes",
    "title": "파이썬 개요",
    "section": "",
    "text": "https://www.tiobe.com/tiobe-index/↩︎\nhttps://geek-and-poke.com/geekandpoke/2011/2/11/a-geek-is-born.html↩︎\nhttps://namu.wiki/w/Hello%2C%20world%21↩︎",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>파이썬 개요</span>"
    ]
  },
  {
    "objectID": "20syntax.html",
    "href": "20syntax.html",
    "title": "문법",
    "section": "",
    "text": "변수와 상수\n변수, 상수, 리터럴은 프로그래밍에서 데이터를 저장하고 관리하는 개념이다. 데이터 저장은 일반적으로 저장장치계층에 따라 CPU, 메모리(RAM), 저장장치(HDD, SSD 등)을 이용한다.",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>문법</span>"
    ]
  },
  {
    "objectID": "20syntax.html#변수와-상수",
    "href": "20syntax.html#변수와-상수",
    "title": "문법",
    "section": "",
    "text": "저장장치 계층 구조\n\n\n\n변수\n\n\n\nhttps://pixabay.com/ko/\n\n\n변수란 값을 변경할 수 있는 저장 공간을 말한다.\n\n프로그램에서 데이터를 저장하고 변경할 수 있는 공간\n\n특정한 값이 할당되며, 필요에 따라 변경할 수 있음\n\n선언 시 변수명을 사용하여 값을 저장하고 참조함\n\n\n\n상수\n상수란 값을 변경할 수 없는 저장 공간을 말한다.\n\n한 번 할당되면 변경할 수 없는 값\n\n프로그램이 실행되는 동안 값이 유지됨\n\n일반적으로 const, final 등의 키워드를 사용하여 선언함 (언어별 상수 키워드 참고)\n\n\n\n리터럴\n저장 공간에 실제 저장하는 값을 말한다.\n\n프로그램에서 직접 사용하는 고정된 값\n\n변수나 상수에 할당되는 실제 데이터 값\n\n숫자, 문자열, 불리언, 배열 등 다양한 형태가 있음\n\n아래는 파이썬 예제이다.\n\n# 변수\nx = 10  \ny = \"Hello\"\n\n# 상수 (Python에서는 관례적으로 대문자로 작성)\nPI = 3.14159  \n\n# 리터럴\nprint(100)       # 정수 리터럴\nprint(3.14)      # 실수 리터럴\nprint(\"Python\")  # 문자열 리터럴\n\n100\n3.14\nPython\n\n\n파이썬에서는 상수를 만드는 “const”와 같은 키워드를 제공하지 않는다. 관례적으로 상수인 경우 변수명을 대문자로 작성한다(개발자간 암묵적인 규칙).",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>문법</span>"
    ]
  },
  {
    "objectID": "20syntax.html#sec-datatype",
    "href": "20syntax.html#sec-datatype",
    "title": "문법",
    "section": "자료형",
    "text": "자료형\n자료형은 데이터의 종류를 나타내는 것이다. 프로그래밍에서 데이터를 다룰 때, 컴퓨터가 그 데이터의 성격을 이해할 수 있도록 자료형을 사용한다.\n\n자료형의 역할\n\n데이터를 어떻게 저장하고 처리할지 결정한다.\n허용되는 연산을 정의한다.\n\n\n\n파이썬에서 주요 자료형\n\n\n\n\n\ngraph LR\n    A[Python Data Types] --&gt; B[Numeric Types]\n    A --&gt; C[Sequence Types]\n    A --&gt; D[Mapping Type]\n    A --&gt; E[Set Types]\n    A --&gt; F[Boolean Type]\n    A --&gt; G[None Type]\n    A --&gt; H[Binary Types]\n    \n    B --&gt; B1[int]\n    B --&gt; B2[float]\n    B --&gt; B3[complex]\n    \n    C --&gt; C1[list]\n    C --&gt; C2[tuple]\n    C --&gt; C3[range]\n    C --&gt; C4[str]\n    \n    D --&gt; D1[dict]\n    \n    E --&gt; E1[set]\n    E --&gt; E2[frozenset]\n    \n    F --&gt; F1[bool]\n    \n    G --&gt; G1[NoneType]\n    \n    H --&gt; H1[bytes]\n    H --&gt; H2[bytearray]\n    H --&gt; H3[memoryview]\n\n\n\n\n\n\n\n숫자형 (Number)\n\n정수, 실수, 복소수를 포함한다.\n예: 10(정수), 3.14(실수)\n\n문자열 (String)\n\n문자나 단어를 묶어놓은 데이터.\n예: \"안녕하세요\", 'Python'\n\n불리언 (Boolean)\n\n참(True)과 거짓(False)만을 표현하는 자료형.\n예: True, False\n\n리스트 (List)\n\n여러 개의 값을 순서대로 저장하는 자료형.\n예: [1, 2, 3], [\"a\", \"b\", \"c\"]\n\n튜플 (Tuple)\n\n리스트와 비슷하지만, 값이 변경되지 않는다.\n예: (1, 2, 3)\n\n딕셔너리 (Dictionary)\n\n키(key)와 값(value)을 쌍으로 저장하는 자료형.\n예: {\"이름\": \"철수\", \"나이\": 20}\n\n집합 (Set)\n\n중복 없는 값을 저장하는 자료형.\n예: {1, 2, 3}\n\n\n\n\n자료형의 예제\n\n# 숫자형\nx = 10\ny = 3.14\n\n# 문자열\nname = \"Python\"\n\n# 논리값(불리언)\nis_valid = True\n\n# 리스트\nnumbers = [1, 2, 3]\n\n# 튜플\ncoordinates = (10, 20)\n\n# 딕셔너리\nperson = {\"name\": \"Alice\", \"age\": 25}\n\n# 집합\nunique_numbers = {1, 2, 3, 4}\n\n\n\n쉽게 기억하는 법\n\n숫자: 계산할 수 있는 데이터\n\n문자열: 글자나 단어를 표현\n\n리스트/튜플: 여러 개의 데이터를 하나로 묶기\n\n딕셔너리: “단어: 뜻”처럼 짝지어진 데이터\n\n불리언: 맞다/틀리다(True/False)로 답하는 데이터",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>문법</span>"
    ]
  },
  {
    "objectID": "20syntax.html#sec-numeric",
    "href": "20syntax.html#sec-numeric",
    "title": "문법",
    "section": "숫자형",
    "text": "숫자형\n파이썬에서 숫자형 자료형은 숫자를 저장하고 연산할 수 있는 데이터 타입이다. 크게 정수형, 실수형, 복소수형으로 나뉜다.\n\n정수형\n정수형(Integer, int) …, -1, 0, 1, …과 같이 정수를 표현하는 자료형이다.\n\n소수점이 없는 정수 값을 저장하는 자료형\n\n크기의 제한 없이 매우 큰 정수도 표현 가능\n\n양수, 음수, 0을 포함\n\n예제\n\na = 10   # 양의 정수\nb = -5   # 음의 정수\nc = 0    # 0도 정수\nd = 999999999999999999999  # 매우 큰 정수도 가능\nprint(type(a))  # &lt;class 'int'&gt;\n\n&lt;class 'int'&gt;\n\n\n\n\n\n실수형\n실수형(Floating Point, float)은 실수를 표현하는 자료형이다.\n\n소수점이 있는 숫자를 표현하는 자료형\n\n부동소수점(floating point) 방식으로 저장됨\n\n지수 표현(e 표기법)을 사용하여 매우 큰 숫자나 매우 작은 숫자도 표현 가능\n\n예제\n\nx = 3.14   # 일반적인 실수\ny = -2.71  # 음수 실수\nz = 1.2e3  # 1.2 × 10^3 = 1200.0\nw = 5e-4   # 5 × 10^(-4) = 0.0005\nprint(type(x))  # &lt;class 'float'&gt;\n\n&lt;class 'float'&gt;\n\n\n\n\n\n복소수형\n복소수형(Complex Number, complex)은 복소수를 표현하는 자료형이다.\n\n수학에서 사용하는 복소수를 표현하는 자료형\n\n실수부(real)와 허수부(imag)로 구성됨\n\n허수부는 j를 사용하여 표현\n\n예제\n\nnum1 = 3 + 4j  # 3 + 4i (수학에서의 허수 i를 j로 표현)\nnum2 = -2 - 5j\nprint(num1.real)  # 실수부: 3.0\nprint(num1.imag)  # 허수부: 4.0\nprint(type(num1)) # &lt;class 'complex'&gt;\n\n3.0\n4.0\n&lt;class 'complex'&gt;\n\n\n\n\n\n형 변환 (Type Conversion)\n\n숫자형 간 변환이 가능하며, int(), float(), complex()를 사용함\n\n예제\n\nprint(int(3.14))     # 3 (실수를 정수로 변환)\nprint(float(5))      # 5.0 (정수를 실수로 변환)\nprint(complex(2))    # (2+0j) (정수를 복소수로 변환)\n\n3\n5.0\n(2+0j)\n\n\n\n\n\n숫자형과 관련된 내장 함수\n\n\n\n\n\n\n\n\n함수\n설명\n예제\n\n\n\n\nabs(x)\n절댓값 반환\nabs(-5) → 5\n\n\nround(x, n)\n반올림 (소수점 n자리까지)\nround(3.14159, 2) → 3.14\n\n\npow(x, y)\nx의 y제곱 (거듭제곱)\npow(2, 3) → 8\n\n\ndivmod(x, y)\n(몫, 나머지) 튜플 반환\ndivmod(10, 3) → (3, 1)\n\n\n\n\nprint(abs(-7))        # 7t\nprint(round(3.14159, 2)) # 3.14\nprint(pow(2, 3))      # 8\nprint(divmod(10, 3))  # (3, 1)\n\n7\n3.14\n8\n(3, 1)",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>문법</span>"
    ]
  },
  {
    "objectID": "20syntax.html#sec-string",
    "href": "20syntax.html#sec-string",
    "title": "문법",
    "section": "문자형",
    "text": "문자형\n파이썬에서 문자열(String, str)은 문자들의 연속된 집합으로, 텍스트 데이터를 저장하는 자료형이다. 작은따옴표(')나 큰따옴표(\")로 감싸서 표현한다.\n\n문자열 생성\n\ntext1 = 'Hello'       # 작은따옴표 사용\ntext2 = \"Python\"      # 큰따옴표 사용\ntext3 = '''Hello'''   # 작은따옴표 세 개 사용\ntext4 = \"\"\"Python\"\"\"  # 큰따옴표 세 개 사용\n\nprint(type(text1))  # &lt;class 'str'&gt;\n\n&lt;class 'str'&gt;\n\n\n\n작은따옴표와 큰따옴표는 동일하게 작동한다.\n세 개의 따옴표(''' 또는 \"\"\")는 여러 줄 문자열을 만들 때 사용한다.\n\n\nmulti_line = \"\"\"이것은\n    여러 줄의\n문자열입니다.\"\"\"\nprint(multi_line)\n\n이것은\n    여러 줄의\n문자열입니다.\n\n\n\n\n문자열 인덱싱(Indexing)과 슬라이싱(Slicing)\n문자열은 인덱스를 사용하여 개별 문자에 접근할 수 있다. 인덱스는 0부터 시작하며, 음수 인덱스를 사용하면 뒤에서부터 접근 가능하다.\n\n인덱싱\n\n\n\n인덱싱\n\n\n\ntext = \"Python\"\nprint(text[0])   # 'P'\nprint(text[-1])  # 'n' (뒤에서 첫 번째 문자)\n\nP\nn\n\n\n\n\n슬라이싱\n\n\n\n슬라이싱\n\n\n\ntext = \"Python\"\nprint(text[0:4])  # 'Pyth' (0부터 3까지)\nprint(text[:3])   # 'Pyt' (처음부터 2까지)\nprint(text[2:])   # 'thon' (2부터 끝까지)\nprint(text[-4:-1])# 'tho' (뒤에서 4번째부터 뒤에서 2번째까지)\nprint(text[::-1]) # 'nohtyP' (문자열 뒤집기)\n\nPyth\nPyt\nthon\ntho\nnohtyP\n\n\n\n\n\n문자열 연산\n파이썬의 문자열은 더하기(+)와 곱하기(*) 연산을 지원한다.\n\n\n\n연산자\n설명\n예제\n\n\n\n\n+\n문자열 연결\n'Hello' + 'World' → 'HelloWorld'\n\n\n*\n문자열 반복\n'Python' * 3 → 'PythonPythonPython'\n\n\n\n\na = \"Hello\"\nb = \"World\"\nprint(a + \" \" + b)  # \"Hello World\"\n\nc = \"Python\"\nprint(c * 3)  # \"PythonPythonPython\"\n\nHello World\nPythonPythonPython\n\n\n\n\n문자열 길이 확인\nlen() 함수를 사용하면 문자열의 길이를 확인할 수 있다.\n\ntext = \"Hello Python\"\nprint(len(text))  # 12\n\n12\n\n\n\n\n문자열 내장 함수\n문자열 조작을 위한 다양한 함수가 제공된다.\n\n\n\n\n\n\n\n\n함수\n설명\n예제\n\n\n\n\nupper()\n대문자로 변환\n\"hello\".upper() → \"HELLO\"\n\n\nlower()\n소문자로 변환\n\"PYTHON\".lower() → \"python\"\n\n\nstrip()\n공백 제거\n\" hello \".strip() → \"hello\"\n\n\nreplace(a, b)\n문자열 치환\n\"Hello\".replace(\"H\", \"J\") → \"Jello\"\n\n\nsplit(sep)\n문자열 분할\n\"a,b,c\".split(\",\") → ['a', 'b', 'c']\n\n\njoin(iterable)\n문자열 합치기\n\" \".join(['Hello', 'World']) → \"Hello World\"\n\n\nfind(sub)\n문자열 찾기 (인덱스 반환)\n\"Python\".find(\"y\") → 1\n\n\ncount(sub)\n특정 문자 개수 세기\n\"banana\".count(\"a\") → 3\n\n\nstartswith(sub)\n특정 문자열로 시작하는지 확인\n\"Python\".startswith(\"Py\") → True\n\n\nendswith(sub)\n특정 문자열로 끝나는지 확인\n\"Python\".endswith(\"on\") → True\n\n\n\n\ntext = \" hello python \"\nprint(text.upper())    # \" HELLO PYTHON \"\nprint(text.strip())    # \"hello python\"\nprint(text.replace(\"python\", \"world\"))  # \" hello world \"\nprint(\"apple,banana,grape\".split(\",\"))  # ['apple', 'banana', 'grape']\nprint(\"-\".join([\"2025\", \"01\", \"30\"]))   # \"2025-01-30\"\nprint(\"banana\".count(\"a\"))  # 3\n\n HELLO PYTHON \nhello python\n hello world \n['apple', 'banana', 'grape']\n2025-01-30\n3\n\n\n\n\n문자열 포맷팅 (Formatting)\n파이썬에서 문자열 포맷팅은 변수 값을 문자열에 삽입하는 방법이다. 여러 가지 방식으로 문자열을 포맷할 수 있으며, 각 방식은 특정한 사용 사례에 따라 적합하다. 아래는 파이썬에서 문자열 포맷팅을 위한 주요 방법들이다.\n\n% 포맷팅\n이 방식(구식 방식)은 C 언어 스타일의 포맷팅으로, 문자열 안에 % 기호를 사용하여 변수를 삽입한다.\n\nname = \"Alice\"\nage = 30\nresult = \"Name: %s, Age: %d\" % (name, age)\nprint(result)\n\nName: Alice, Age: 30\n\n\n\n%s: 문자열 삽입\n%d: 정수 삽입\n%f: 부동소수점 숫자 삽입\n\n\n\nstr.format()\nstr.format()은 더 직관적인 방식(중간 방식)으로, {} 플레이스홀더를 사용하여 변수 값을 삽입한다. 포맷팅할 자리에 {}를 넣고, format() 메서드 안에 변수 값을 전달한다.\n\nname = \"Alice\"\nage = 30\nresult = \"Name: {}, Age: {}\".format(name, age)\nprint(result)\n\nName: Alice, Age: 30\n\n\n\n\n위치 인자와 키워드 인자 사용\n\nresult = \"Name: {0}, Age: {1}\".format(name, age)\nprint(result)  # 출력: Name: Alice, Age: 30\n\nresult = \"Name: {name}, Age: {age}\".format(name=\"Alice\", age=30)\nprint(result)\n\nName: Alice, Age: 30\nName: Alice, Age: 30\n\n\n\n\nf-strings\nf-string은 가장 최신의 방식(Python 3.6 이상)으로, 문자열 앞에 f를 붙이고, 중괄호 {} 안에 변수나 표현식을 직접 삽입하는 방법이다. 가독성이 좋고 성능도 우수하다.\n\nname = \"Alice\"\nage = 30\nresult = f\"Name: {name}, Age: {age}\"\nprint(result)  # 출력: Name: Alice, Age: 30\n\nName: Alice, Age: 30\n\n\n\n표현식 삽입\n\n\nf-string에서는 변수뿐만 아니라 표현식도 바로 삽입할 수 있다.\n\n\n\n\nx = 5\nresult = f\"5 * 2 = {x * 2}\"\nprint(result)  # 출력: 5 * 2 = 10\n\n5 * 2 = 10\n\n\n\n각 방식의 장단점\n\n\n\n\n\n\n\n\n방식\n설명\n장점\n단점\n\n\n\n\n% 포맷팅\nC 스타일 포맷팅\n간단하고 직관적\n가독성이 떨어짐\n\n\nstr.format()\n{}와 format() 메서드 사용\n위치 인자, 키워드 인자 지원\n비교적 오래된 방식\n\n\nf-strings\nf\"{}\"를 사용하여 변수를 직접 삽입\n가독성, 성능, 간결함\nPython 3.6 이상만 지원\n\n\n\n\n가장 최신의 방식은 f-string이다. Python 3.6 이상에서 사용할 수 있으며, 성능과 가독성이 뛰어나 대부분의 경우 이 방식을 사용한다.\nstr.format()은 여전히 유용하지만, 최신 코드에서는 f-string으로 대체되고 있다.\n% 포맷팅은 구식 방식이며, 가독성 및 유지보수 측면에서 추천되지 않는다.\n\n\n\n\n문자열 비교\n파이썬에서는 문자열을 사전 순서(ASCII1 값 기준)로 비교한다.\n\n\n\n연산자\n설명\n예제\n\n\n\n\n==\n문자열이 같은지 비교\n\"apple\" == \"apple\" → True\n\n\n!=\n문자열이 다른지 비교\n\"apple\" != \"banana\" → True\n\n\n&lt;, &gt;\n사전순 비교\n\"apple\" &lt; \"banana\" → True\n\n\n\n\nprint(\"apple\" == \"apple\")  # True\nprint(\"apple\" != \"banana\") # True\nprint(\"apple\" &lt; \"banana\")  # True (사전순 비교)\nprint(\"Zebra\" &gt; \"apple\")   # False ('Z'의 ASCII 값이 'a'보다 작음)\n\nTrue\nTrue\nTrue\nFalse\n\n\n\n\n문자열을 숫자로 변환\nint(), float()를 사용하면 문자열을 숫자로 변환할 수 있다.\n\nnum_str = \"100\"\nprint(int(num_str) + 5)  # 105 (문자열 → 정수)\n\nfloat_str = \"3.14\"\nprint(float(float_str) * 2)  # 6.28 (문자열 → 실수)\n\n105\n6.28\n\n\n문자열 관련 내용을 정리하면 다음과 같다.\n\n\n\n\n\n\n\n\n개념\n설명\n예제\n\n\n\n\n문자열 생성\n작은따옴표 또는 큰따옴표 사용\n'Hello', \"Python\"\n\n\n인덱싱\n특정 문자 접근\n\"Python\"[0] → 'P'\n\n\n슬라이싱\n문자열 일부 가져오기\n\"Python\"[1:4] → 'yth'\n\n\n연산\n+ (연결), * (반복)\n\"Hello\" + \"World\", \"Hi\" * 3\n\n\n내장 함수\n문자열 조작\n\"hello\".upper(), \"text\".replace(\"t\", \"T\")\n\n\n포맷팅\n변수 포함\nf\"이름: {name}\", \"이름: {}\".format(name)\n\n\n비교\n문자열 비교\n\"apple\" &lt; \"banana\" → True\n\n\n\n파이썬의 문자열은 변경할 수 없는(Immutable) 객체이지만, 다양한 함수와 연산을 활용하여 쉽게 다룰 수 있다.",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>문법</span>"
    ]
  },
  {
    "objectID": "20syntax.html#sec-boolean",
    "href": "20syntax.html#sec-boolean",
    "title": "문법",
    "section": "논리형",
    "text": "논리형\n파이썬에서 불리언(Boolean, bool) 자료형은 참(True)과 거짓(False)을 표현하는 데이터 타입이다.\n\n불리언 값과 생성\nTrue 또는 False 값을 가지며, 첫 글자는 반드시 대문자로 작성한다(true, false는 오류 발생) .\n\na = True\nb = False\nprint(type(a))  # &lt;class 'bool'&gt;\nprint(type(b))  # &lt;class 'bool'&gt;\n\n&lt;class 'bool'&gt;\n&lt;class 'bool'&gt;\n\n\n\n\n불리언 연산\n논리 연산자(and, or, not)를 사용하여 조합 가능하다.\n\nAND (논리곱)\n\n\nAND 연산은 두 값이 모두 True일 때만 결과가 True가 된다.\n\n\n\n\n\n\nA\nB\nA AND B\n\n\n\n\nFalse\nFalse\nFalse\n\n\nFalse\nTrue\nFalse\n\n\nTrue\nFalse\nFalse\n\n\nTrue\nTrue\nTrue\n\n\n\n\nOR (논리합)\n\n\nOR 연산은 두 값 중 하나라도 True일 때 결과가 True가 된다.\n\n\n\n\n\n\nA\nB\nA OR B\n\n\n\n\nFalse\nFalse\nFalse\n\n\nFalse\nTrue\nTrue\n\n\nTrue\nFalse\nTrue\n\n\nTrue\nTrue\nTrue\n\n\n\n\nNOT (부정)\n\n\nNOT 연산은 입력 값이 True이면 False로, False이면 True로 바꾼다.\n\n\n\n\n\n\nA\nNOT A\n\n\n\n\nFalse\nTrue\n\n\nTrue\nFalse\n\n\n\n이 표들은 불리언 논리에서 사용하는 기본적인 연산들로, 프로그래밍에서 조건문이나 제어 흐름을 처리할 때 자주 사용된다.\n\n파이썬 논리 연산자\n\n\n연산자\n설명\n예제\n\n\n\n\nand\n두 값이 모두 참이면 True\nTrue and True → True\n\n\nor\n하나라도 참이면 True\nTrue or False → True\n\n\nnot\n값을 반대로 변환\nnot True → False\n\n\n\n\nprint(True and False)  # False\nprint(True or False)   # True\nprint(not True)        # False\n\nFalse\nTrue\nFalse\n\n\n\n\n불리언과 숫자 변환\nTrue는 1, False는 0과 동일하게 동작한다. int()와 bool()을 사용하여 변환 가능하다.\n\nprint(int(True))   # 1\nprint(int(False))  # 0\nprint(bool(1))     # True\nprint(bool(0))     # False\n\n1\n0\nTrue\nFalse\n\n\n\n\n참/거짓 판별\nbool() 함수를 사용해 참과 거짓을 판별할 수 있다. 아래 값들은 False(거짓)로 간주된다.\n\n0\n0.0\n'' (빈 문자열)\nNone\n[] (빈 리스트)\n{} (빈 딕셔너리)\nset() (빈 집합)\n\n\nprint(bool(0))       # False\nprint(bool(0.0))     # False\nprint(bool(\"\"))      # False\nprint(bool([]))      # False\nprint(bool(None))    # False\nprint(bool(\"Python\"))  # True (문자가 있으면 True)\nprint(bool([1, 2, 3]))  # True (리스트에 요소가 있으면 True)\n\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nTrue\n\n\n불리언 자료형은 조건문 (if), 반복문 (while), 논리 연산 등에 널리 사용된다.",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>문법</span>"
    ]
  },
  {
    "objectID": "20syntax.html#연산자",
    "href": "20syntax.html#연산자",
    "title": "문법",
    "section": "연산자",
    "text": "연산자\n파이썬에서는 산술, 비교, 논리, 대입 등과 같은 연산자를 제공한다.\n\n산술\n파이썬에서 산술 연산자는 숫자 값을 계산하는 연산자이다. 기본적인 사칙연산뿐만 아니라 나머지 연산, 거듭제곱 연산, 몫 연산도 제공한다.\n\n산술 연산자 종류\n\n\n\n연산자\n설명\n예제\n결과\n\n\n\n\n+\n덧셈\n10 + 5\n15\n\n\n-\n뺄셈\n10 - 5\n5\n\n\n*\n곱셈\n10 * 5\n50\n\n\n/\n나눗셈 (소수점 포함)\n10 / 3\n3.3333\n\n\n//\n몫 연산 (정수 나눗셈)\n10 // 3\n3\n\n\n%\n나머지 연산\n10 % 3\n1\n\n\n**\n거듭제곱\n2 ** 3\n8\n\n\n\n\n\n덧셈(+)과 뺄셈(-)\n\na = 10\nb = 5\nprint(a + b)  # 15\nprint(a - b)  # 5\n\n15\n5\n\n\n\n\n곱셈(*)과 나눗셈(/)\n\nx = 10\ny = 3\nprint(x * y)  # 30\nprint(x / y)  # 3.3333333333333335 (소수 포함)\n\n30\n3.3333333333333335\n\n\n\nx = 10\ny = 0\nprint(x / y)  # ZeroDivisionError\n\n\n---------------------------------------------------------------------------\nZeroDivisionError                         Traceback (most recent call last)\nCell In[28], line 3\n      1 x = 10\n      2 y = 0\n----&gt; 3 print(x / y)  # ZeroDivisionError\n\nZeroDivisionError: division by zero\n\n\n\n\n\n몫 연산(//)\n결과값이 정수로 반환된다(소수점 이하 버림).\n\nprint(10 // 3)  # 3\nprint(-10 // 3) # -4 (음수는 반올림이 아니라 내림)\n\n3\n-4\n\n\n\n\n나머지 연산(%)\n\nprint(10 % 3)  # 1\nprint(15 % 4)  # 3\n\n1\n3\n\n\n\n\n거듭제곱(**)\n\nprint(2 ** 3)  # 8 (2의 3제곱)\nprint(5 ** 2)  # 25 (5의 제곱)\nprint(9 ** 0.5) # 3.0 (제곱근)\n\n8\n25\n3.0\n\n\n\n\n\n산술 연산과 자료형\nint와 float이 함께 연산되면 결과는 float이 된다.\n\nprint(5 + 2.5)  # 7.5 (int + float = float)\nprint(10 / 2)   # 5.0 (나눗셈 결과는 항상 float)\n\n7.5\n5.0\n\n\n\n\n연산자 우선순위\n파이썬의 산술 연산자는 수학과 동일한 우선순위를 따른다. 우선순위가 높을수록 먼저 계산된다.\n\n\n\n연산자\n우선순위 (높음 → 낮음)\n\n\n\n\n**\n거듭제곱\n\n\n*, /, //, %\n곱셈, 나눗셈, 몫, 나머지\n\n\n+, -\n덧셈, 뺄셈\n\n\n\n\nprint(2 + 3 * 4)     # 14 (* 먼저 계산)\nprint((2 + 3) * 4)   # 20 (괄호 안 먼저 계산)\nprint(2 ** 3 * 4)    # 32 (** 먼저 계산)\n\n14\n20\n32\n\n\n우선 순위가 있는 연산시 혼동을 피하기 위해 괄로로 묶어 계산한다.\n\n\n\n비교\n파이썬에서 비교 연산자는 두 값을 비교하고 True 또는 False를 반환하는 연산자이다.\n\n비교 연산자 종류\n\n\n\n\n\n\n\n\n\n\n연산자\n의미\n설명\n예제\n결과\n\n\n\n\n==\n같음\n두 값이 같으면 True, 다르면 False\n5 == 5\nTrue\n\n\n!=\n다름\n두 값이 다르면 True, 같으면 False\n5 != 3\nTrue\n\n\n&lt;\n작음\n왼쪽 값이 오른쪽 값보다 작으면 True\n3 &lt; 5\nTrue\n\n\n&gt;\n큼\n왼쪽 값이 오른쪽 값보다 크면 True\n5 &gt; 3\nTrue\n\n\n&lt;=\n작거나 같음\n왼쪽 값이 오른쪽 값보다 작거나 같으면 True\n5 &lt;= 5\nTrue\n\n\n&gt;=\n크거나 같음\n왼쪽 값이 오른쪽 값보다 크거나 같으면 True\n5 &gt;= 3\nTrue\n\n\n\n\n\n== (같음)\n\n두 값이 같으면 True, 다르면 False를 반환한다.\n\n\n\nprint(5 == 5)  # True\nprint(5 == 3)  # False\n\nTrue\nFalse\n\n\n\n!= (다름)\n\n두 값이 다르면 True, 같으면 False를 반환한다.\n\n\n\nprint(5 != 3)  # True\nprint(5 != 5)  # False\n\nTrue\nFalse\n\n\n\n&lt; (작음)\n\n왼쪽 값이 오른쪽 값보다 작으면 True, 크거나 같으면 False를 반환한다.\n\n\n\nprint(3 &lt; 5)  # True\nprint(5 &lt; 5)  # False\n\nTrue\nFalse\n\n\n\n&gt; (큼)\n\n왼쪽 값이 오른쪽 값보다 크면 True, 작거나 같으면 False를 반환한다.\n\n\n\nprint(5 &gt; 3)  # True\nprint(5 &gt; 5)  # False\n\nTrue\nFalse\n\n\n\n&lt;= (작거나 같음)\n\n왼쪽 값이 오른쪽 값보다 작거나 같으면 True, 크면 False를 반환한다.\n\n\n\nprint(3 &lt;= 5)  # True\nprint(5 &lt;= 5)  # True\nprint(6 &lt;= 5)  # False\n\nTrue\nTrue\nFalse\n\n\n\n&gt;= (크거나 같음)\n\n왼쪽 값이 오른쪽 값보다 크거나 같으면 True, 작으면 False를 반환한다.\n\n\n\nprint(5 &gt;= 3)  # True\nprint(5 &gt;= 5)  # True\nprint(3 &gt;= 5)  # False\n\nTrue\nTrue\nFalse\n\n\n\n\n\n비교 연산자의 특징\n\n\n문자열 비교\n\n문자열도 비교 연산자로 비교할 수 있으며, 사전 순서(ASCII 코드 값) 에 따라 결과가 결정된다.\n\n\n\nprint(\"apple\" &lt; \"banana\")  # True (\"a\"가 \"b\"보다 앞에 있음)\nprint(\"abc\" &lt; \"abcd\")  # True (문자 수가 적은 것이 더 작음)\n\nTrue\nTrue\n\n\n\n논리값 비교\n\nTrue는 1, False는 0과 동등하게 취급된다.\n\n\n\nprint(True == 1)  # True\nprint(False == 0)  # True\nprint(True &gt; False)  # True (1 &gt; 0)\n\nTrue\nTrue\nTrue\n\n\n\n비교 연산자 연쇄 사용 (Chaining)\n\n여러 개의 비교 연산자를 연결하여 사용할 수 있다.\n\n\n\nx = 5\nprint(3 &lt; x &lt; 10)  # True (3 &lt; 5 and 5 &lt; 10)\nprint(3 &lt; x &gt; 2)  # True (3 &lt; 5 and 5 &gt; 2)\n\nTrue\nTrue\n\n\n\n비교 연산자는 조건문, 반복문, 필터링 등의 다양한 상황에서 활용된다.\n\n\n\n논리\n파이썬에서 논리 연산자는 여러 개의 조건을 결합하거나 부정할 때 사용한다. 논리 연산자는 and, or, not 세 가지가 있다.\n\n논리 연산자의 종류\n\n\n\n\n\n\n\n\n\n연산자\n설명\n예제\n결과\n\n\n\n\nand\n둘 다 True일 때만 True, 하나라도 False이면 False\nTrue and True\nTrue\n\n\nor\n둘 중 하나라도 True이면 True\nTrue or False\nTrue\n\n\nnot\nTrue를 False로, False를 True로 변환\nnot True\nFalse\n\n\n\n\n\nand 연산자\n연산자 좌우항 둘 다 True여야 True이다.\n\nprint(True and True)   # True\nprint(True and False)  # False\nprint(False and True)  # False\nprint(False and False) # False\n\nTrue\nFalse\nFalse\nFalse\n\n\n\nx = 10\nprint(x &gt; 5 and x &lt; 20)  # True (둘 다 True)\nprint(x &gt; 5 and x &gt; 20)  # False (하나가 False)\n\nTrue\nFalse\n\n\n\n\nor 연산자\n연산자 좌우향 중 하나라도 True면 True이다.\n\nprint(True or True)   # True\nprint(True or False)  # True\nprint(False or True)  # True\nprint(False or False) # False\n\nTrue\nTrue\nTrue\nFalse\n\n\n\ny = 7\nprint(y &lt; 5 or y &gt; 6)   # True (하나가 True)\nprint(y &lt; 5 or y == 7)  # True (하나가 True)\nprint(y &lt; 5 or y &gt; 10)  # False (둘 다 False)\n\nTrue\nTrue\nFalse\n\n\n\n\nnot 연산자\n논리값을 반대로 바꿔준다. 즉, True → False, False → True로 반환한다.\n\nprint(not True)   # False\nprint(not False)  # True\n\nFalse\nTrue\n\n\n\na = 5\nprint(not (a &gt; 10))  # True (a &gt; 10이 False이므로 not을 적용하면 True)\n\nTrue\n\n\n\n\n논리 연산자와 비교 연산자 함께 사용\n논리 연산자는 비교 연산자(&gt;, &lt;, ==, != 등)와 함께 사용되어 조건문을 조합할 때 유용하다.\n\nage = 25\nprint(age &gt; 18 and age &lt; 30)  # True (두 조건이 모두 참)\nprint(age &lt; 18 or age &gt; 30)   # False (둘 다 거짓)\nprint(not age &gt; 18)           # False (age가 18보다 크므로 not을 적용하면 False)\n\nTrue\nFalse\nFalse\n\n\n\n\nand, or의 단축 평가 (Short-Circuit Evaluation)\n파이썬은 논리 연산을 수행할 때 불필요한 연산을 생략하는 단축 평가(short-circuit evaluation) 를 적용한다.\n\nand 연산자에서 단축 평가\n첫 번째 값이 False이면 결과가 무조건 False이므로 두 번째 값은 검사하지 않는다.\n\nprint(False and print(\"실행되지 않음\"))  # False만 출력됨\n\nFalse\n\n\n\n\nor 연산자에서 단축 평가\n첫 번째 값이 True이면 결과가 무조건 True이므로 두 번째 값은 검사하지 않는다.\n\nprint(True or print(\"실행되지 않음\"))  # True만 출력됨\n\nTrue\n\n\n\n\n\n논리 연산자와 숫자형 값\n파이썬에서 True는 1, False는 0과 동일하게 취급된다. 또한, 빈 값(0, None, '', [], {})은 False, 나머지는 True로 평가된다.\n\nprint(bool(0))    # False\nprint(bool(1))    # True\nprint(bool(\"\"))   # False\nprint(bool(\"Hi\")) # True\n\nFalse\nTrue\nFalse\nTrue\n\n\n\n\n논리 연산자의 반환값\n논리 연산자는 단순히 True나 False가 아니라 실제 값을 반환하기도 한다.\n\nand 연산자: 첫 번째 값이 True이면 두 번째 값을 반환\nprint(10 and 20)  # 20 (10이 True이므로 20 반환)\nprint(0 and 20)   # 0 (0이 False이므로 0 반환)\n\n\nor 연산자: 첫 번째 값이 True이면 그 값을 반환, False이면 두 번째 값을 반환**\nprint(10 or 20)  # 10 (첫 번째 값이 True이므로 그대로 반환)\nprint(0 or 20)   # 20 (첫 번째 값이 False이므로 두 번째 값 반환)\n논리 연산자를 정리하면 다음과 같다.\n\n\n\n연산자\n설명\n예제\n결과\n\n\n\n\nand\n둘 다 True일 때 True\nTrue and False\nFalse\n\n\nor\n하나라도 True이면 True\nTrue or False\nTrue\n\n\nnot\nTrue ↔︎ False 변환\nnot True\nFalse\n\n\n\n논리 연산자는 조건문, 반복문, 복잡한 조건을 평가할 때 필수적으로 사용되며, 단축 평가와 값 반환 방식을 이해하면 더욱 효율적으로 활용할 수 있다.\n\n\n\n\n대입\n파이썬에서 대입 연산자(할당 연산자)는 변수에 값을 저장하거나 연산 후 결과를 변수에 저장하는 데 사용한다.\n\n\n대입 연산자의 종류\n\n\n\n연산자\n설명\n예제\n결과\n\n\n\n\n=\n기본 대입 (값을 변수에 저장)\na = 10\na에 10 저장\n\n\n+=\n덧셈 후 대입\na += 5\na = a + 5\n\n\n-=\n뺄셈 후 대입\na -= 3\na = a - 3\n\n\n*=\n곱셈 후 대입\na *= 2\na = a * 2\n\n\n/=\n나눗셈 후 대입\na /= 4\na = a / 4\n\n\n//=\n몫 연산 후 대입\na //= 3\na = a // 3\n\n\n%=\n나머지 연산 후 대입\na %= 2\na = a % 2\n\n\n**=\n거듭제곱 후 대입\na **= 3\na = a ** 3\n\n\n\n\n\n기본 대입 연산자\n\n=\n\n\nx = 10\ny = 5\nprint(x)  # 10\nprint(y)  # 5\n\n10\n5\n\n\n\n\n복합 대입 연산자\n\n+=, -=, *=, /=, //=, %=, **=\n\n\na = 10\n\na += 5   # a = a + 5\nprint(a)  # 15\n\na -= 3   # a = a - 3\nprint(a)  # 12\n\na *= 2   # a = a * 2\nprint(a)  # 24\n\na /= 4   # a = a / 4\nprint(a)  # 6.0 (나눗셈 결과는 항상 float)\n\na //= 2  # a = a // 2\nprint(a)  # 3 (정수 나눗셈)\n\na %= 2   # a = a % 2\nprint(a)  # 1 (나머지 연산)\n\na **= 3  # a = a ** 3\nprint(a)  # 1 (1의 3제곱)\n\n15\n12\n24\n6.0\n3.0\n1.0\n1.0\n\n\n\n\n여러 개의 변수에 값 대입\n\n여러 변수에 한 번에 대입\n\nx = y = z = 100\nprint(x, y, z)  # 100 100 100\n\n100 100 100\n\n\n\n\n여러 변수에 각각 다른 값 대입 (튜플 형태)\n\na, b, c = 1, 2, 3\nprint(a, b, c)  # 1 2 3\n\n1 2 3\n\n\n\n\n\n변수 값 교환\n파이썬에서는 임시 변수 없이 두 변수의 값을 쉽게 교환할 수 있다.\n\na, b = 10, 20\na, b = b, a\nprint(a, b)  # 20 10\n\n20 10\n\n\n\n\n리스트에서 값을 대입하는 언패킹(unpacking)\n\nnumbers = [1, 2, 3]\nx, y, z = numbers\nprint(x, y, z)  # 1 2 3\n\n1 2 3\n\n\n대입 연산자는 값을 저장하고, 계산을 간단하게 만들며, 여러 변수에 값을 동시에 할당할 때 유용하다.\n\n\n\n기타 연산자\n파이썬에서는 산술 연산자, 비교 연산자, 논리 연산자, 대입 연산자 외에도 다양한 연산자가 있다. 대표적으로 비트 연산자, 멤버 연산자, 식별 연산자가 있다.\n\n비트 연산자 (Bitwise Operators)\n비트 연산자는 정수를 이진수(0과 1)로 변환하여 비트 단위로 연산할 때 사용한다.\n\n\n\n\n\n\n\n\n\n연산자\n설명\n예제 (a = 5, b = 3)\n결과 (a = 5(101), b = 3(011))\n\n\n\n\n&\nAND (둘 다 1이면 1)\na & b\n1 (001)\n\n\n|\nOR (하나라도 1이면 1)\na | b\n7 (111)\n\n\n^\nXOR (다를 때 1)\na ^ b\n6 (110)\n\n\n~\nNOT (비트 반전, 1의 보수)\n~a\n-6 (음수 표현 방식)\n\n\n&lt;&lt;\n왼쪽 시프트 (비트 이동, 2^n 배 증가)\na &lt;&lt; 1\n10 (1010)\n\n\n&gt;&gt;\n오른쪽 시프트 (비트 이동, 2^n 배 감소)\na &gt;&gt; 1\n2 (10)\n\n\n\n\na = 5  # 101 (2진수)\nb = 3  # 011 (2진수)\n\nprint(a & b)  # 1  (001)\nprint(a | b)  # 7  (111)\nprint(a ^ b)  # 6  (110)\nprint(~a)     # -6 (음수 표현 방식)\nprint(a &lt;&lt; 1) # 10 (1010) → 2배 증가\nprint(a &gt;&gt; 1) # 2  (10)   → 2배 감소\n\n1\n7\n6\n-6\n10\n2\n\n\n\n\n멤버 연산자 (Membership Operators)\n멤버 연산자는 특정 값이 리스트, 튜플, 문자열 등에 포함되어 있는지 확인할 때 사용한다.\n\n\n\n\n\n\n\n\n\n연산자\n설명\n예제\n결과\n\n\n\n\nin\n값이 포함되어 있으면 True\n'a' in 'apple'\nTrue\n\n\nnot in\n값이 포함되지 않으면 True\n'x' not in 'apple'\nTrue\n\n\n\n\ntext = \"hello\"\nprint('h' in text)     # True\nprint('z' not in text) # True\n\nnumbers = [1, 2, 3, 4]\nprint(3 in numbers)    # True\nprint(5 not in numbers) # True\n\nTrue\nTrue\nTrue\nTrue\n\n\n\n\n식별 연산자 (Identity Operators)\n식별 연산자는 두 변수가 같은 객체를 가리키는지 확인할 때 사용한다(==은 값 비교, is는 객체 비교).\n\n\n\n연산자\n설명\n예제\n결과\n\n\n\n\nis\n같은 객체이면 True\na is b\nTrue 또는 False\n\n\nis not\n다른 객체이면 True\na is not b\nTrue 또는 False\n\n\n\n\na = [1, 2, 3]\nb = a\nc = [1, 2, 3]\n\nprint(a is b)   # True (같은 객체를 가리킴)\nprint(a is c)   # False (같은 값이지만 다른 객체)\nprint(a == c)   # True (값이 같음)\nprint(a is not c) # True (다른 객체)\n\nTrue\nFalse\nTrue\nTrue\n\n\n위 연산자들은 비트 연산, 데이터 포함 여부 검사, 객체 비교 등에 유용하게 사용된다.",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>문법</span>"
    ]
  },
  {
    "objectID": "20syntax.html#주석-사용법",
    "href": "20syntax.html#주석-사용법",
    "title": "문법",
    "section": "주석 사용법",
    "text": "주석 사용법\n파이썬에서 주석(Comment)은 코드에 대한 설명을 작성하는 부분으로, 프로그램 실행에는 영향을 주지 않는다. 코드 가독성을 높이고 유지보수를 쉽게 하기 위해 사용한다.\n\n\n\n\n\n\n\n\n주석 유형\n설명\n예제\n\n\n\n\n한 줄 주석\n#을 사용하여 작성\n# 변수 선언\n\n\n여러 줄 주석\n\"\"\" 또는 '''로 감싸서 작성\n\"\"\" 여러 줄 주석 \"\"\"\n\n\n여러 줄 # 주석\n여러 줄에 걸쳐 # 사용\n# 첫 번째 줄  # 두 번째 줄\n\n\n\n\n한 줄 주석\n한 줄 주석(Single-line Comment)은 # 기호를 사용하여 작성한다.\n\n# 변수 선언\nx = 10  # x에 10을 할당\nprint(x)  # x 값을 출력\n\n10\n\n\n\n# 뒤에 오는 내용은 주석 처리되어 실행되지 않는다.\n\n\n\n여러 줄 주석\n여러 줄 주석(Multi-line Comment)은 여러 줄을 한 번에 주석 처리할 때 사용하며, 보통 큰 설명을 추가할 때 사용한다.\n\n여러 줄 주석 - \"\"\" 또는 ''' 사용\n\n\"\"\"\n이 코드는 사칙연산을 수행하는 코드입니다.\n각 연산 결과를 출력합니다.\n\"\"\"\na = 10\nb = 5\n\nprint(a + b)  # 덧셈\nprint(a - b)  # 뺄셈\n\n15\n5\n\n\n\n'''\n여러 줄 주석을 사용하여\n설명을 추가할 수 있습니다.\n'''\nprint(\"Hello, World!\")\n\nHello, World!\n\n\n\"\"\" 또는 '''로 감싸면 여러 줄을 주석 처리할 수 있다. 다만, \"\"\"와 '''는 문자열 리터럴로도 사용될 수 있으므로, 문서화 문자열(docstring)로 인식될 수 있다.\n\n\n\n여러 줄 주석 - 여러 개의 # 사용\n여러 줄을 주석 처리할 때, #을 각 줄마다 붙이는 방법도 있다.\n\n# 이 코드는 두 숫자를 더하는 코드입니다.\n# 결과를 출력합니다.\n\na = 10\nb = 20\nprint(a + b)  # 30 출력\n\n30\n\n\n#을 여러 줄에 걸쳐 사용하면 여러 줄을 주석 처리할 수 있다.\n\n\n\n주석 활용 예제\n\n디버깅할 때 특정 코드 실행 막기\n\nx = 10\ny = 20\n# print(x + y)  # 이 줄은 실행되지 않음\nprint(x * y)  # 200 출력\n\n200\n\n\n특정 줄을 실행하지 않도록 하여 코드를 테스트할 때 유용하게 사용할 수 있다.\n\n\n함수 설명(docstring)으로 활용\n함수의 설명을 추가할 때 \"\"\" 또는 '''를 사용하면 문서화 문자열(docstring)로 활용할 수 있다.\n\ndef add(a, b):\n    \"\"\"두 수를 더하는 함수\"\"\"\n    return a + b\n\nprint(add(3, 5))  # 8 출력\n\n8\n\n\nhelp(add)를 실행하면 함수의 설명이 출력된다.\n\n\n\n주석 작성 시 주의할 점\n\n필요한 부분만 주석을 작성해야 한다. (불필요한 주석은 오히려 가독성을 해친다.)\n\n일관된 스타일로 작성하는 것이 좋다. (주석 스타일을 팀과 맞추는 것이 중요하다.)\n\n주석은 항상 최신 상태로 유지해야 한다. (코드를 변경했을 때 주석도 함께 수정해야 한다.)\n\n파이썬 주석은 코드를 이해하기 쉽게 만들고, 디버깅할 때 유용하며, 문서화 목적으로도 활용할 수 있다.",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>문법</span>"
    ]
  },
  {
    "objectID": "20syntax.html#참고사항",
    "href": "20syntax.html#참고사항",
    "title": "문법",
    "section": "참고사항",
    "text": "참고사항\n\n언어별 상수 키워드\n프로그래밍 언어별로 상수를 정의할 때 사용하는 키워드를 아래와 같다.\n\n프로그래밍 언어별 상수 키워드\n\n\n\n\n\n\n\n언어\n상수 키워드\n설명\n\n\n\n\nC\nconst, #define\nconst로 상수 선언, #define은 전처리기 지시문으로 상수 정의\n\n\nC++\nconst, constexpr\nconst는 변경 불가 변수, constexpr은 컴파일 시간 상수\n\n\nJava\nfinal\n변수에 final을 붙이면 값 변경 불가 (상수로 사용)\n\n\nC#\nconst, readonly\nconst는 컴파일 타임 상수, readonly는 런타임 초기화 후 변경 불가\n\n\nPython\n(키워드 없음)\n대문자 변수명으로 상수 표현 (관례), 변경 방지 기능 없음\n\n\nJavaScript\nconst\n재할당 불가능한 변수 선언, 객체나 배열의 내부 값은 변경 가능\n\n\nSwift\nlet\n상수 선언 시 사용, 한 번 초기화된 후 값 변경 불가\n\n\nKotlin\nval, const val\nval은 변경 불가 변수, const val은 컴파일 타임 상수\n\n\nGo\nconst\n컴파일 타임 상수 선언에 사용\n\n\nRust\nconst, let\nconst는 상수, let은 기본 변수 선언 (불변성은 mut 유무로 결정)\n\n\nTypeScript\nconst\nJavaScript와 동일하게 상수 선언\n\n\nPHP\ndefine(), const\ndefine() 함수 또는 const 키워드로 상수 선언\n\n\nRuby\n(키워드 없음)\n대문자 변수명으로 상수 표현, 재할당 시 경고만 발생\n\n\n\n\n참고\n\n\nPython, Ruby처럼 상수 전용 키워드는 없지만 대문자 변수명 사용으로 상수를 표현하는 언어도 있음\n\nJavaScript의 const는 값 재할당은 불가능하지만, 객체나 배열 내부의 데이터는 변경 가능\n\n\n\n\n\n실수 표현\n컴퓨터 프로그래밍에서 실수(소수)를 정확히 표현할 수 없다. 이유는 컴퓨터가 2진수(0과 1)로 숫자를 저장하기 때문이다.\n\n비유로 이해하기\n\n10진수(사람): 우리는 0.1, 0.5처럼 소수를 10진수로 쉽게 표현할 수 있다.\n\n2진수(컴퓨터): 컴퓨터는 2진수로 숫자를 저장하는데, 0.1(10진수)는 2진수로 정확히 표현할 수 없다.\n\n\n\n간단한 예\n\n\n\n소수점을 2진수로 변환\n\n\n\n1/3을 10진수로 나타내면 0.3333… (무한 반복)\n\n마찬가지로, 컴퓨터가 0.1을 2진수로 변환하면 무한하게 반복되는 값이 되어 정확히 저장할 수 없다. 2\n\n\n\n결과\n\n컴퓨터는 이런 무한한 숫자를 저장할 수 없으므로 가까운 값으로 반올림해서 저장한다.\n\n그래서 0.1 + 0.2 != 0.3 같은 이상한 결과가 나오기도 한다.\n\n\nprint(0.1 + 0.2)\n\n0.30000000000000004\n\n\n\n\n해결 방법\n\n정밀한 계산이 필요할 때는 decimal 모듈(파이썬) 같은 고정 소수점 방식을 사용하거나, 부동소수점 오차를 고려해서 코드를 작성한다.",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>문법</span>"
    ]
  },
  {
    "objectID": "20syntax.html#footnotes",
    "href": "20syntax.html#footnotes",
    "title": "문법",
    "section": "",
    "text": "https://ko.wikipedia.org/wiki/ASCII↩︎\nhttps://www.h-schmidt.net/FloatConverter/IEEE754.html↩︎",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>문법</span>"
    ]
  },
  {
    "objectID": "30datatype.html",
    "href": "30datatype.html",
    "title": "자료형",
    "section": "",
    "text": "리스트\n리스트(list)는 여러 개의 값을 순차적으로 저장할 수 있는 자료형으로, 대괄호([])를 사용하여 생성한다. 리스트는 변경 가능한(mutable) 객체이며, 다양한 자료형의 값을 함께 저장할 수 있다.",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>자료형</span>"
    ]
  },
  {
    "objectID": "30datatype.html#sec-list",
    "href": "30datatype.html#sec-list",
    "title": "자료형",
    "section": "",
    "text": "리스트 생성\n\n기본 리스트 생성\n대괄호 []를 사용하여 리스트를 생성할 수 있다.\n\n# 빈 리스트 생성\nempty_list = []\n\n# 정수 리스트\nnumbers = [1, 2, 3, 4, 5]\n\n# 문자열 리스트\nfruits = [\"apple\", \"banana\", \"cherry\"]\n\n# 여러 자료형이 포함된 리스트\nmixed = [1, \"hello\", 3.14, True]\n\nprint(empty_list)  # []\nprint(numbers)  # [1, 2, 3, 4, 5]\nprint(fruits)  # ['apple', 'banana', 'cherry']\nprint(mixed)  # [1, 'hello', 3.14, True]\n\n[]\n[1, 2, 3, 4, 5]\n['apple', 'banana', 'cherry']\n[1, 'hello', 3.14, True]\n\n\n\n\nlist() 함수 사용\nlist() 생성자를 사용하여 리스트를 만들 수 있다.\n\n# 빈 리스트 생성\nempty_list = list()\n\n# 문자열을 리스트로 변환\nchar_list = list(\"hello\")  \nprint(char_list)  # ['h', 'e', 'l', 'l', 'o']\n\n# 튜플을 리스트로 변환\ntuple_list = list((1, 2, 3))\nprint(tuple_list)  # [1, 2, 3]\n\n# 집합(set)을 리스트로 변환\nset_list = list({4, 5, 6})\nprint(set_list)  # [4, 5, 6] (집합은 순서가 없으므로 순서가 달라질 수 있음)\n\n['h', 'e', 'l', 'l', 'o']\n[1, 2, 3]\n[4, 5, 6]\n\n\n\n\n리스트 컴프리헨션\n리스트 컴프리헨션((List Comprehension)을 사용하면 반복문을 활용하여 리스트를 한 줄로 생성할 수 있다.\n\n# 1~10까지의 숫자를 포함하는 리스트\nnumbers = [x for x in range(1, 11)]\nprint(numbers)  # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n# 제곱수를 포함하는 리스트\nsquares = [x**2 for x in range(1, 6)]\nprint(squares)  # [1, 4, 9, 16, 25]\n\n# 짝수만 포함하는 리스트\nevens = [x for x in range(1, 11) if x % 2 == 0]\nprint(evens)  # [2, 4, 6, 8, 10]\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n[1, 4, 9, 16, 25]\n[2, 4, 6, 8, 10]\n\n\n\n\nrange()와 list() 조합\nrange()를 이용하여 연속적인 숫자로 구성된 리스트를 만들 수 있다.\n\n# 0부터 9까지의 숫자를 포함하는 리스트\nnumbers = list(range(10))\nprint(numbers)  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# 1부터 10까지의 리스트\nnumbers = list(range(1, 11))\nprint(numbers)  # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n# 1부터 10까지의 홀수 리스트\nodds = list(range(1, 11, 2))\nprint(odds)  # [1, 3, 5, 7, 9]\n\n# 10부터 1까지 역순 리스트\nreverse_numbers = list(range(10, 0, -1))\nprint(reverse_numbers)  # [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n[1, 3, 5, 7, 9]\n[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n\n\n\n\n중첩 리스트\n리스트 안에 리스트(Nested List)를 포함하여 2차원 이상의 리스트를 만들 수 있다.\n\n# 2차원 리스트 생성\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\n# 원소 접근\nprint(matrix[0])  # [1, 2, 3]\nprint(matrix[1][1])  # 5 (두 번째 행, 두 번째 열)\n\n[1, 2, 3]\n5\n\n\n리스트는 다양한 방법으로 생성할 수 있으며, 상황에 맞게 적절한 방식을 선택하여 활용할 수 있다.\n\n\n\n리스트 원소 접근\n리스트의 원소는 인덱스(index)를 사용하여 접근(Access)할 수 있다. 인덱스는 0부터 시작하며, 음수를 사용하면 뒤에서부터 접근할 수 있다.\n\n인덱싱\n리스트의 각 원소는 0부터 시작하는 인덱스(index)를 사용하여 접근(Indexing)할 수 있다.\n\nnumbers = [10, 20, 30, 40, 50]\n\n# 양수 인덱스 접근\nprint(numbers[0])  # 10 (첫 번째 원소)\nprint(numbers[2])  # 30 (세 번째 원소)\nprint(numbers[4])  # 50 (다섯 번째 원소)\n\n10\n30\n50\n\n\n\n음수 인덱싱\n음수 인덱스를 사용하면 뒤에서부터 원소를 접근(Negative Indexing)할 수 있다.\n\nnumbers = [10, 20, 30, 40, 50]\n\nprint(numbers[-1])  # 50 (마지막 원소)\nprint(numbers[-3])  # 30 (뒤에서 세 번째 원소)\nprint(numbers[-5])  # 10 (첫 번째 원소와 동일)\n\n50\n30\n10\n\n\n유효하지 않은 인덱스를 사용하면 IndexError가 발생한다.\n\nnumbers = [10, 20, 30]\nprint(numbers[5])  # IndexError: list index out of range\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[8], line 2\n      1 numbers = [10, 20, 30]\n----&gt; 2 print(numbers[5])  # IndexError: list index out of range\n\nIndexError: list index out of range\n\n\n\n\n\n\n슬라이싱\n리스트의 특정 구간을 가져올 때는 슬라이싱(slicing)을 사용한다.\n\nnumbers = [10, 20, 30, 40, 50, 60, 70]\n\n# 기본 슬라이싱 [start:end] (end 인덱스는 포함되지 않음)\nprint(numbers[1:4])  # [20, 30, 40]\n\n# 처음부터 특정 인덱스까지\nprint(numbers[:3])  # [10, 20, 30]\n\n# 특정 인덱스부터 끝까지\nprint(numbers[4:])  # [50, 60, 70]\n\n# 전체 리스트 복사\nprint(numbers[:])  # [10, 20, 30, 40, 50, 60, 70]\n\n[20, 30, 40]\n[10, 20, 30]\n[50, 60, 70]\n[10, 20, 30, 40, 50, 60, 70]\n\n\n\n간격을 지정하는 슬라이싱\n세 번째 값 step을 추가하면 특정 간격으로 원소를 가져올 수 있다.\n\n[시작:끝:간격]\n\n\nnumbers = [10, 20, 30, 40, 50, 60, 70]\n\n# 2칸씩 건너뛰기\nprint(numbers[::2])  # [10, 30, 50, 70]\n\n# 3칸씩 건너뛰기\nprint(numbers[::3])  # [10, 40, 70]\n\n[10, 30, 50, 70]\n[10, 40, 70]\n\n\n\n\n리스트 뒤집기\n슬라이싱에서 step을 -1로 설정하면 리스트를 뒤집을 수 있다.\n\nnumbers = [10, 20, 30, 40, 50]\n\nprint(numbers[::-1])  # [50, 40, 30, 20, 10]\n\n[50, 40, 30, 20, 10]\n\n\n\n\n중첩 리스트 원소 접근\n리스트 안에 리스트가 포함된 경우 이중 인덱싱을 사용하여 원소를 접근할 수 있다.\n\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\n# 첫 번째 행 전체\nprint(matrix[0])  # [1, 2, 3]\n\n# 두 번째 행의 두 번째 원소\nprint(matrix[1][1])  # 5\n\n# 세 번째 행의 마지막 원소\nprint(matrix[2][-1])  # 9\n\n[1, 2, 3]\n5\n9\n\n\n\n\n\n\nfor 문을 활용한 리스트 접근\n반복문을 사용하여 리스트의 원소를 순회할 수 있다.\n\nnumbers = [10, 20, 30, 40, 50]\n\n# 리스트의 모든 원소 출력\nfor num in numbers:\n    print(num)\n\n10\n20\n30\n40\n50\n\n\n\n\n인덱스를 함께 사용하기\n인덱스와 값을 함께 가져오려면 enumerate()1를 사용할 수 있다.\n\nnumbers = [10, 20, 30, 40, 50]\n\nfor index, value in enumerate(numbers):\n    print(f\"Index {index}: {value}\")\n\nIndex 0: 10\nIndex 1: 20\nIndex 2: 30\nIndex 3: 40\nIndex 4: 50\n\n\n리스트의 원소는 인덱싱, 슬라이싱, 중첩 리스트 접근, 반복문을 활용하여 쉽게 접근할 수 있으며, 다양한 방식으로 조작할 수 있다.\n\n\n\n리스트 원소 수정\n리스트는 변경 가능한(mutable) 자료형이므로, 특정 인덱스의 값을 변경하거나 슬라이싱을 이용해 여러 개의 값을 한 번에 변경(Update)할 수 있다.\n\n인덱스를 이용한 원소 업데이트\n특정 인덱스의 값을 변경하려면 대입 연산자(=)를 사용한다.\n\nnumbers = [10, 20, 30, 40, 50]\n\n# 인덱스 2의 값을 변경\nnumbers[2] = 100\nprint(numbers)  # [10, 20, 100, 40, 50]\n\n# 마지막 원소 변경 (음수 인덱스 사용)\nnumbers[-1] = 500\nprint(numbers)  # [10, 20, 100, 40, 500]\n\n[10, 20, 100, 40, 50]\n[10, 20, 100, 40, 500]\n\n\n유효하지 않은 인덱스를 사용하면 IndexError가 발생한다.\n\nnumbers = [10, 20, 30]\nnumbers[5] = 100  # IndexError: list assignment index out of range\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[16], line 2\n      1 numbers = [10, 20, 30]\n----&gt; 2 numbers[5] = 100  # IndexError: list assignment index out of range\n\nIndexError: list assignment index out of range\n\n\n\n\n\n슬라이싱을 이용한 여러 원소 업데이트\n슬라이싱을 사용하면 여러 개의 원소를 한 번에 변경할 수 있다.\n\nnumbers = [10, 20, 30, 40, 50]\n\n# 1번 ~ 3번 인덱스의 값 변경\nnumbers[1:4] = [200, 300, 400]\nprint(numbers)  # [10, 200, 300, 400, 50]\n\n[10, 200, 300, 400, 50]\n\n\n슬라이싱을 이용하면 기존 리스트보다 더 적거나 많은 원소를 할당할 수도 있다.\n\nnumbers = [10, 20, 30, 40, 50]\n\n# 두 개의 값을 하나로 변경\nnumbers[1:3] = [999]\nprint(numbers)  # [10, 999, 40, 50]\n\n# 두 개의 값을 네 개로 변경\nnumbers[2:4] = [1, 2, 3, 4]\nprint(numbers)  # [10, 999, 1, 2, 3, 4]\n\n[10, 999, 40, 50]\n[10, 999, 1, 2, 3, 4]\n\n\n\n\n+= 연산자로 리스트 확장\n+= 연산자를 사용하면 기존 리스트에 새로운 원소를 추가할 수 있다.\n\nnumbers = [10, 20, 30]\n\n# 리스트 확장 (새로운 요소 추가)\nnumbers += [40, 50]\nprint(numbers)  # [10, 20, 30, 40, 50]\n\n[10, 20, 30, 40, 50]\n\n\n하지만 이 방법은 새로운 리스트를 생성하는 것이 아니라 기존 리스트를 확장하는 방식이므로 append()나 extend()와는 차이가 있다(리스트 원소 추가 참고).\n\n\n리스트 컴프리헨션을 이용한 원소 업데이트\n리스트 컴프리헨션(list comprehension)을 사용하면 조건에 맞게 리스트의 원소를 한 번에 변경할 수 있다.\n\nnumbers = [1, 2, 3, 4, 5]\n\n# 모든 원소를 제곱값으로 변경\nnumbers = [x**2 for x in numbers]\nprint(numbers)  # [1, 4, 9, 16, 25]\n\n# 홀수만 두 배로 변경\nnumbers = [x*2 if x % 2 != 0 else x for x in numbers]\nprint(numbers)  # [2, 4, 18, 16, 50]\n\n[1, 4, 9, 16, 25]\n[2, 4, 18, 16, 50]\n\n\n\n\n반복문을 사용한 리스트 원소 업데이트\n리스트를 반복하면서 특정 조건에 맞는 원소만 변경할 수도 있다.\n\nnumbers = [10, 20, 30, 40, 50]\n\n# 값이 30 이상인 원소를 모두 0으로 변경\nfor i in range(len(numbers)):\n    if numbers[i] &gt;= 30:\n        numbers[i] = 0\n\nprint(numbers)  # [10, 20, 0, 0, 0]\n\n[10, 20, 0, 0, 0]\n\n\n\n\nmap()을 사용한 원소 업데이트\nmap()2 함수를 사용하면 리스트의 모든 원소를 변경할 수 있다.\n\nnumbers = [1, 2, 3, 4, 5]\n\n# 모든 원소를 문자로 변환\nnumbers = list(map(str, numbers))\nprint(numbers)  # ['1', '2', '3', '4', '5']\n\n['1', '2', '3', '4', '5']\n\n\n리스트 원소는 인덱스를 직접 지정하거나, 슬라이싱, 리스트 컴프리헨션, 반복문, map()을 이용하여 변경할 수 있다. 상황에 따라 적절한 방법을 선택하면 된다.\n\n\n\n리스트 원소 추가\n리스트는 변경 가능한(mutable) 자료형이므로 새로운 원소를 동적으로 추가할 수 있다. 원소를 추가하는 대표적인 방법으로 append(), insert(), extend(), += 연산자 등을 사용할 수 있다.\n\n\n\n\n\n\n\n\n메서드\n설명\n예제\n\n\n\n\nappend(x)\n리스트 끝에 원소 x 추가\nnumbers.append(10)\n\n\ninsert(i, x)\n인덱스 i 위치에 원소 x 삽입\nnumbers.insert(2, 100)\n\n\nextend(iterable)\n리스트 확장 (여러 원소 추가)\nnumbers.extend([4, 5, 6])\n\n\n+= iterable\nextend()와 동일하게 리스트 확장\nnumbers += [7, 8]\n\n\n\n리스트의 원소 추가 방법은 상황에 따라 적절한 메서드를 선택하여 사용하면 된다.\n\nappend(): 리스트 끝에 원소 추가\nappend() 메서드는 리스트의 마지막에 원소를 하나 추가한다.\n\nnumbers = [10, 20, 30]\n\n# 리스트 끝에 40 추가\nnumbers.append(40)\nprint(numbers)  # [10, 20, 30, 40]\n\n# 문자열 리스트에 새로운 요소 추가\nfruits = [\"apple\", \"banana\"]\nfruits.append(\"cherry\")\nprint(fruits)  # ['apple', 'banana', 'cherry']\n\n[10, 20, 30, 40]\n['apple', 'banana', 'cherry']\n\n\n\n\n\n주의: append()는 리스트 자체를 변경하며, 여러 개의 원소를 추가할 경우 extend()를 사용해야 한다.\n\nnumbers = [1, 2, 3]\n\n# 리스트를 append() 하면 리스트 내부에 리스트가 들어감\nnumbers.append([4, 5])\nprint(numbers)  # [1, 2, 3, [4, 5]]\n\n[1, 2, 3, [4, 5]]\n\n\n\n\n\n\n\ninsert(): 특정 위치에 원소 추가\ninsert(index, value) 메서드는 지정한 위치(index)에 원소를 삽입한다.\n\nnumbers = [10, 20, 30, 40]\n\n# 인덱스 2(세 번째 위치)에 25 삽입\nnumbers.insert(2, 25)\nprint(numbers)  # [10, 20, 25, 30, 40]\n\n# 리스트의 맨 앞에 원소 삽입\nnumbers.insert(0, 5)\nprint(numbers)  # [5, 10, 20, 25, 30, 40]\n\n[10, 20, 25, 30, 40]\n[5, 10, 20, 25, 30, 40]\n\n\n\n\n\n\n\nextend(): 여러 개의 원소 추가\nextend(iterable) 메서드는 리스트에 여러 개의 원소를 한 번에 추가할 때 사용한다.\n\nnumbers = [1, 2, 3]\n\n# 리스트 확장\nnumbers.extend([4, 5, 6])\nprint(numbers)  # [1, 2, 3, 4, 5, 6]\n\n# 문자열 리스트 확장\nfruits = [\"apple\", \"banana\"]\nfruits.extend([\"cherry\", \"grape\"])\nprint(fruits)  # ['apple', 'banana', 'cherry', 'grape']\n\n[1, 2, 3, 4, 5, 6]\n['apple', 'banana', 'cherry', 'grape']\n\n\n\n\n\n주의: extend()는 리스트를 개별 원소 단위로 확장하며, append()와 다르게 리스트 자체가 추가되지 않는다.\n\nnumbers = [1, 2, 3]\n\n# append() 사용 시 리스트 형태로 추가됨\nnumbers.append([4, 5])\nprint(numbers)  # [1, 2, 3, [4, 5]]\n\n# extend() 사용 시 개별 원소로 추가됨\nnumbers = [1, 2, 3]\nnumbers.extend([4, 5])\nprint(numbers)  # [1, 2, 3, 4, 5]\n\n[1, 2, 3, [4, 5]]\n[1, 2, 3, 4, 5]\n\n\n\n\n+= 연산자를 이용한 원소 추가\n+= 연산자를 사용하면 extend()와 같은 효과를 낼 수 있다.\n\nnumbers = [10, 20, 30]\n\n# 리스트 확장\nnumbers += [40, 50]\nprint(numbers)  # [10, 20, 30, 40, 50]\n\n[10, 20, 30, 40, 50]\n\n\n\n\n리스트 컴프리헨션을 이용한 동적 추가\n리스트 컴프리헨션을 사용하여 조건을 만족하는 원소를 추가할 수 있다.\n\n# 기존 리스트에서 홀수만 추출하여 새로운 리스트 생성\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nodd_numbers = [x for x in numbers if x % 2 != 0]\n\nprint(odd_numbers)  # [1, 3, 5, 7, 9]\n\n[1, 3, 5, 7, 9]\n\n\n\n\nsetdefault()를 사용한 리스트 추가\n리스트를 딕셔너리 값으로 사용할 때, setdefault()를 활용하면 특정 키가 없을 경우 리스트를 생성하면서 원소를 추가할 수 있다.\n\ndata = {}\n\n# \"fruits\" 키가 없으면 새 리스트를 생성하고 \"apple\"을 추가\ndata.setdefault(\"fruits\", []).append(\"apple\")\n\nprint(data)  # {'fruits': ['apple']}\n\n{'fruits': ['apple']}\n\n\n\n\n\n리스트 원소 삭제\n리스트에서 원소를 삭제하는 방법은 여러 가지가 있으며, 인덱스, 값, 슬라이싱, 메서드 활용 등 다양한 방법을 사용할 수 있다.\n\n\n\n\n\n\n\n\n메서드\n설명\n예제\n\n\n\n\ndel list[index]\n특정 인덱스의 원소 삭제\ndel numbers[2]\n\n\ndel list[start:end]\n여러 원소 삭제\ndel numbers[1:4]\n\n\nremove(value)\n특정 값을 찾아 삭제 (가장 첫 번째 등장한 값)\nnumbers.remove(10)\n\n\npop(index)\n특정 인덱스의 원소를 삭제 후 반환\nnumbers.pop(2)\n\n\nclear()\n리스트의 모든 원소 삭제\nnumbers.clear()\n\n\n리스트 컴프리헨션\n특정 조건을 만족하는 원소만 남기기\n[x for x in numbers if x != 20]\n\n\n\n리스트의 원소를 삭제하는 방법은 필요한 상황에 따라 적절한 메서드를 선택하여 사용하면 된다.\n\ndel 키워드를 사용한 삭제\ndel 키워드를 사용하면 특정 인덱스의 원소를 삭제하거나 리스트 전체를 삭제할 수 있다.\n\nnumbers = [10, 20, 30, 40, 50]\n\n# 인덱스 2(세 번째 원소) 삭제\ndel numbers[2]\nprint(numbers)  # [10, 20, 40, 50]\n\n# 마지막 원소 삭제\ndel numbers[-1]\nprint(numbers)  # [10, 20, 40]\n\n[10, 20, 40, 50]\n[10, 20, 40]\n\n\n\n슬라이싱을 활용한 여러 원소 삭제\n\nnumbers = [10, 20, 30, 40, 50, 60]\n\n# 인덱스 1~3(2번째~4번째) 원소 삭제\ndel numbers[1:4]\nprint(numbers)  # [10, 50, 60]\n\n# 리스트 전체 삭제\ndel numbers[:]\nprint(numbers)  # []\n\n[10, 50, 60]\n[]\n\n\n\n\n\n\nremove()를 사용한 값 삭제\nremove(value) 메서드는 리스트에서 특정 값을 찾아 삭제한다. 해당 값이 여러 개 있을 경우 가장 앞에 있는 값 하나만 삭제한다.\n\nnumbers = [10, 20, 30, 20, 40, 50]\n\n# 값 20 삭제 (첫 번째 등장하는 20만 삭제됨)\nnumbers.remove(20)\nprint(numbers)  # [10, 30, 20, 40, 50]\n\n[10, 30, 20, 40, 50]\n\n\n없는 값을 삭제하려 하면 ValueError가 발생한다.\n\nnumbers = [10, 20, 30]\n\nnumbers.remove(100)  # ValueError: list.remove(x): x not in list\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[34], line 3\n      1 numbers = [10, 20, 30]\n----&gt; 3 numbers.remove(100)  # ValueError: list.remove(x): x not in list\n\nValueError: list.remove(x): x not in list\n\n\n\n\n\npop()을 사용한 삭제 및 반환\npop(index) 메서드는 특정 인덱스의 원소를 삭제하면서 해당 값을 반환한다. 인덱스를 지정하지 않으면 마지막 원소를 삭제 후 반환한다.\n\nnumbers = [10, 20, 30, 40, 50]\n\n# 인덱스 2(세 번째 원소) 삭제 후 반환\nremoved_value = numbers.pop(2)\nprint(numbers)  # [10, 20, 40, 50]\nprint(removed_value)  # 30\n\n# 마지막 원소 삭제 후 반환\nlast_value = numbers.pop()\nprint(numbers)  # [10, 20, 40]\nprint(last_value)  # 50\n\n[10, 20, 40, 50]\n30\n[10, 20, 40]\n50\n\n\n유효하지 않은 인덱스를 사용하면 IndexError가 발생한다.\n\nnumbers = [10, 20, 30]\n\nnumbers.pop(10)  # IndexError: pop index out of range\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[36], line 3\n      1 numbers = [10, 20, 30]\n----&gt; 3 numbers.pop(10)  # IndexError: pop index out of range\n\nIndexError: pop index out of range\n\n\n\n\n\n\nclear()를 사용한 리스트 전체 삭제\nclear() 메서드는 리스트의 모든 원소를 삭제하여 빈 리스트로 만든다.\n\nnumbers = [10, 20, 30, 40, 50]\n\nnumbers.clear()\nprint(numbers)  # []\n\n[]\n\n\n\n\n리스트 컴프리헨션을 활용한 조건부 삭제\n리스트 컴프리헨션을 이용하면 특정 조건을 만족하는 원소만 남기고 나머지를 삭제할 수 있다.\n\nnumbers = [10, 20, 30, 40, 50]\n\n# 30보다 작은 값만 남기기\nnumbers = [x for x in numbers if x &lt; 30]\nprint(numbers)  # [10, 20]\n\n[10, 20]\n\n\n\n\n특정 값 여러 개 삭제 (filter() 사용)\nremove()는 첫 번째 등장한 원소 하나만 삭제하지만, 리스트 컴프리헨션이나 filter()를 사용하면 특정 값을 모두 삭제할 수 있다.\n\nnumbers = [10, 20, 30, 20, 40, 50]\n\n# 값이 20인 원소 모두 삭제 (리스트 컴프리헨션 사용)\nnumbers = [x for x in numbers if x != 20]\nprint(numbers)  # [10, 30, 40, 50]\n\n# filter() 사용\nnumbers = list(filter(lambda x: x != 20, numbers))\nprint(numbers)  # [10, 30, 40, 50]\n\n[10, 30, 40, 50]\n[10, 30, 40, 50]\n\n\n\n\n\n리스트 관련 주요 함수 및 메서드\n\n\n\n\n\n\n\n\n함수/메서드\n설명\n예제\n\n\n\n\nlen()\n리스트의 길이(원소 개수) 반환\nlen([1,2,3])  # 3\n\n\nsorted()\n리스트를 정렬한 새 리스트 반환\nsorted([3,1,2])  # [1,2,3]\n\n\nlist.sort()\n리스트 자체를 정렬(오름차순 기본)\nnumbers.sort()\n\n\nlist.reverse()\n리스트 원소의 순서를 반대로 변경\nnumbers.reverse()\n\n\nlist.count(x)\n리스트에서 x의 개수 반환\n[1,2,2,3].count(2)  # 2\n\n\nlist.index(x)\nx의 첫 번째 인덱스 반환\n[10,20,30].index(20)  # 1\n\n\n\n\nnumbers = [3, 1, 4, 1, 5, 9, 2]\n\n# 리스트 길이\nprint(len(numbers))  # 7\n\n# 정렬 (새 리스트 반환)\nsorted_numbers = sorted(numbers)\nprint(sorted_numbers)  # [1, 1, 2, 3, 4, 5, 9]\n\n# 리스트 자체 정렬\nnumbers.sort()\nprint(numbers)  # [1, 1, 2, 3, 4, 5, 9]\n\n# 리스트 뒤집기\nnumbers.reverse()\nprint(numbers)  # [9, 5, 4, 3, 2, 1, 1]\n\n# 특정 값의 개수 찾기\nprint(numbers.count(1))  # 2\n\n# 특정 값의 인덱스 찾기\nprint(numbers.index(5))  # 1\n\n7\n[1, 1, 2, 3, 4, 5, 9]\n[1, 1, 2, 3, 4, 5, 9]\n[9, 5, 4, 3, 2, 1, 1]\n2\n1\n\n\n\n\n리스트 슬라이싱 (Slicing)\n리스트의 일부를 가져올 때 슬라이싱(slicing)을 사용한다.\n\nnumbers = [10, 20, 30, 40, 50, 60, 70]\n\n# 기본 슬라이싱 [start:end] (end는 포함되지 않음)\nprint(numbers[1:4])  # [20, 30, 40]\n\n# 처음부터 특정 인덱스까지\nprint(numbers[:3])  # [10, 20, 30]\n\n# 특정 인덱스부터 끝까지\nprint(numbers[4:])  # [50, 60, 70]\n\n# 특정 간격으로 슬라이싱 [start:end:step]\nprint(numbers[::2])  # [10, 30, 50, 70] (2칸씩 건너뛰기)\n\n# 리스트를 거꾸로 가져오기\nprint(numbers[::-1])  # [70, 60, 50, 40, 30, 20, 10]\n\n[20, 30, 40]\n[10, 20, 30]\n[50, 60, 70]\n[10, 30, 50, 70]\n[70, 60, 50, 40, 30, 20, 10]\n\n\n\n\n리스트 컴프리헨션 (List Comprehension)\n리스트를 간결하게 생성하는 방법으로, 반복문을 활용하여 리스트를 한 줄로 작성할 수 있다.\n\n# 1~10까지의 제곱 리스트 생성\nsquares = [x**2 for x in range(1, 11)]\nprint(squares)  # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\n# 짝수만 필터링하여 리스트 생성\nevens = [x for x in range(1, 11) if x % 2 == 0]\nprint(evens)  # [2, 4, 6, 8, 10]\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n[2, 4, 6, 8, 10]\n\n\n리스트는 다양한 기능과 메서드를 제공하는 강력한 자료형으로, 다양한 상황에서 활용할 수 있다.",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>자료형</span>"
    ]
  },
  {
    "objectID": "30datatype.html#sec-tuple",
    "href": "30datatype.html#sec-tuple",
    "title": "자료형",
    "section": "튜플",
    "text": "튜플\n튜플(tuple)은 변경할 수 없는(immutable) 순서가 있는 자료형으로, 리스트와 비슷하지만 한 번 생성하면 요소를 변경할 수 없다.\n\n튜플 생성\n튜플은 소괄호 () 를 사용하여 생성하며, 쉼표 , 로 여러 개의 요소를 구분한다.\n\n\n\n방법\n설명\n예제\n\n\n\n\n소괄호 사용\n일반적인 튜플 생성\n(10, 20, 30)\n\n\n쉼표 포함한 단일 요소\n요소가 하나일 때 쉼표 필요\n(10,)\n\n\ntuple() 함수\n리스트, 문자열 등 변환\ntuple([1, 2, 3])\n\n\n패킹 (괄호 없이)\n쉼표만 사용하여 생성\n10, 20, 30\n\n\n언패킹\n여러 변수에 값 할당\na, b, c = (10, 20, 30)\n\n\n빈 튜플\n요소가 없는 튜플\n() 또는 tuple()\n\n\n\n튜플은 변경할 수 없는(immutable) 자료형이므로, 리스트와 구분하여 사용해야 한다.\n\n기본적인 튜플 생성\n튜플을 생성하는 가장 기본적인 방법은 소괄호 () 안에 요소를 쉼표 ,로 구분하여 나열하는 것이다.\n\n# 정수형 튜플\nnumbers = (10, 20, 30)\nprint(numbers)  # (10, 20, 30)\n\n# 문자열 튜플\nfruits = (\"apple\", \"banana\", \"cherry\")\nprint(fruits)  # ('apple', 'banana', 'cherry')\n\n# 다양한 데이터 타입 포함 가능\nmixed = (10, \"hello\", 3.14, True)\nprint(mixed)  # (10, 'hello', 3.14, True)\n\n(10, 20, 30)\n('apple', 'banana', 'cherry')\n(10, 'hello', 3.14, True)\n\n\n\n한 개의 요소를 가진 튜플 생성\n튜플에 요소가 하나만 있을 경우, 쉼표 ,를 반드시 포함해야 한다.\n쉼표 없이 생성하면 단순한 변수로 인식된다.\n\nsingle1 = (10,)\nprint(single1)  # (10,)\n\n# 쉼표 없이 생성하면 정수로 인식됨\nsingle2 = (10)\nprint(single2)  # 10 (튜플이 아님)\n\n# 문자열도 마찬가지\nsingle3 = (\"hello\",)\nprint(single3)  # ('hello',)\n\n(10,)\n10\n('hello',)\n\n\n\n\n\ntuple() 함수를 이용한 생성\ntuple() 함수를 사용하면 다른 반복 가능한(iterable) 객체를 튜플로 변환할 수 있다.\n\n# 리스트를 튜플로 변환\nlist_data = [1, 2, 3, 4]\ntuple_from_list = tuple(list_data)\nprint(tuple_from_list)  # (1, 2, 3, 4)\n\n# 문자열을 튜플로 변환 (각 문자 하나씩 분리됨)\ntuple_from_string = tuple(\"hello\")\nprint(tuple_from_string)  # ('h', 'e', 'l', 'l', 'o')\n\n# range()를 튜플로 변환\ntuple_from_range = tuple(range(5))\nprint(tuple_from_range)  # (0, 1, 2, 3, 4)\n\n(1, 2, 3, 4)\n('h', 'e', 'l', 'l', 'o')\n(0, 1, 2, 3, 4)\n\n\n\n\n괄호 없이 튜플 생성 (패킹)\n튜플은 괄호 없이 쉼표만 사용해도 생성 가능하다. 이를 튜플 패킹(tuple packing)이라고 한다.\n\npacked_tuple = 10, 20, 30\nprint(packed_tuple)  # (10, 20, 30)\n\n(10, 20, 30)\n\n\n하지만 가독성을 위해 보통 괄호를 사용하는 것이 권장된다.\n\n\n여러 변수에 튜플 값 할당 (언패킹)\n튜플은 한 번에 여러 개의 변수에 값을 할당(언패킹, unpacking) 할 수 있다.\n\nnumbers = (10, 20, 30)\n\n# 언패킹\na, b, c = numbers\nprint(a)  # 10\nprint(b)  # 20\nprint(c)  # 30\n\n10\n20\n30\n\n\n튜플 요소의 개수와 변수 개수가 맞지 않으면 ValueError가 발생한다.\n\na, b = numbers  # ValueError: too many values to unpack\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[48], line 1\n----&gt; 1 a, b = numbers  # ValueError: too many values to unpack\n\nValueError: too many values to unpack (expected 2)\n\n\n\n특정 요소만 변수에 할당하고 나머지는 *를 사용해 리스트로 받을 수도 있다.\n\nnumbers = (1, 2, 3, 4, 5)\n\na, *b, c = numbers\nprint(a)  # 1\nprint(b)  # [2, 3, 4]\nprint(c)  # 5\n\n1\n[2, 3, 4]\n5\n\n\n\n\n빈 튜플 생성\n비어 있는 튜플은 () 또는 tuple()을 사용해 만들 수 있다.\n\nempty_tuple1 = ()\nempty_tuple2 = tuple()\n\nprint(empty_tuple1)  # ()\nprint(empty_tuple2)  # ()\n\n()\n()\n\n\n\n\n\n튜플 원소 접근\n튜플(tuple)은 순서가 있는(ordered) 자료형이므로, 리스트와 마찬가지로 인덱싱, 슬라이싱 등을 이용하여 원소에 접근할 수 있다. 하지만 튜플은 변경 불가능(immutable) 하므로, 원소를 수정할 수 없다.\n\n\n\n방법\n설명\n예제\n\n\n\n\n인덱싱\n특정 원소 접근\nt[0], t[-1]\n\n\n슬라이싱\n여러 개의 원소 가져오기\nt[1:4], t[::-1]\n\n\nfor 문\n모든 원소 순회\nfor x in t:\n\n\nenumerate()\n인덱스와 함께 순회\nfor i, v in enumerate(t):\n\n\nin 연산자\n원소 포함 여부 확인\nx in t\n\n\n언패킹\n여러 변수에 한 번에 할당\na, b = t\n\n\n\n튜플은 순서가 유지되며, 변경할 수 없는(immutable) 자료형이므로, 원소를 수정하거나 삭제하는 것은 불가능한 점에 유의해야 한다.\n\n인덱싱(Indexing)을 이용한 접근\n튜플의 각 원소는 0부터 시작하는 인덱스(index) 를 사용하여 접근할 수 있다.\n\nfruits = (\"apple\", \"banana\", \"cherry\", \"date\")\n\n# 첫 번째 원소 접근 (인덱스 0)\nprint(fruits[0])  # apple\n\n# 세 번째 원소 접근 (인덱스 2)\nprint(fruits[2])  # cherry\n\n# 마지막 원소 접근 (음수 인덱스 사용)\nprint(fruits[-1])  # date\nprint(fruits[-2])  # cherry\n\napple\ncherry\ndate\ncherry\n\n\n주의: 존재하지 않는 인덱스를 사용하면 IndexError가 발생한다.\n\nprint(fruits[10])  # IndexError: tuple index out of range\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[52], line 1\n----&gt; 1 print(fruits[10])  # IndexError: tuple index out of range\n\nIndexError: tuple index out of range\n\n\n\n\n\n슬라이싱(Slicing)을 이용한 접근\n튜플의 일부 원소를 가져오려면 슬라이싱(slicing) 을 사용할 수 있다. 슬라이싱의 기본 문법은 튜플[start:end:step] 이다.\n\nnumbers = (10, 20, 30, 40, 50, 60, 70)\n\n# 인덱스 1부터 4까지 가져오기 (end는 포함되지 않음)\nprint(numbers[1:4])  # (20, 30, 40)\n\n# 처음부터 세 번째 원소까지 가져오기\nprint(numbers[:3])  # (10, 20, 30)\n\n# 네 번째 원소부터 끝까지 가져오기\nprint(numbers[3:])  # (40, 50, 60, 70)\n\n# 전체 가져오기\nprint(numbers[:])  # (10, 20, 30, 40, 50, 60, 70)\n\n# step을 이용한 간격 지정 (2칸씩 건너뛰기)\nprint(numbers[::2])  # (10, 30, 50, 70)\n\n# 역순으로 가져오기 (step이 -1이면 뒤에서부터 가져옴)\nprint(numbers[::-1])  # (70, 60, 50, 40, 30, 20, 10)\n\n(20, 30, 40)\n(10, 20, 30)\n(40, 50, 60, 70)\n(10, 20, 30, 40, 50, 60, 70)\n(10, 30, 50, 70)\n(70, 60, 50, 40, 30, 20, 10)\n\n\n\n\nfor 문을 이용한 원소 접근 (반복문 활용)\n튜플은 반복문을 사용하여 원소를 하나씩 순회하면서 접근할 수 있다.\n\nfruits = (\"apple\", \"banana\", \"cherry\")\n\n# for 문을 이용한 튜플 원소 출력\nfor fruit in fruits:\n    print(fruit)\n\napple\nbanana\ncherry\n\n\n인덱스와 함께 순회하려면 enumerate()를 사용할 수 있다.\n\nfor index, fruit in enumerate(fruits):\n    print(f\"인덱스 {index}: {fruit}\")\n\n인덱스 0: apple\n인덱스 1: banana\n인덱스 2: cherry\n\n\n\n\nin 키워드를 이용한 원소 포함 여부 확인\n튜플에서 특정 원소가 존재하는지 확인하려면 in 연산자 를 사용할 수 있다.\n\nnumbers = (10, 20, 30, 40, 50)\n\n# 값이 있는지 확인\nprint(20 in numbers)  # True\nprint(100 in numbers)  # False\n\nTrue\nFalse\n\n\n\n\n튜플 언패킹(Unpacking)으로 원소 접근\n튜플을 변수 여러 개에 동시에 할당(언패킹, unpacking) 하여 원소를 접근할 수도 있다.\n\npoint = (3, 5)\n\n# 튜플 언패킹\nx, y = point\nprint(x)  # 3\nprint(y)  # 5\n\n3\n5\n\n\n만약 일부 요소만 받고 나머지는 리스트로 저장하고 싶다면 * 연산자를 사용할 수 있다.\n\nnumbers = (1, 2, 3, 4, 5)\n\na, *b, c = numbers\nprint(a)  # 1\nprint(b)  # [2, 3, 4]  (리스트로 저장됨)\nprint(c)  # 5\n\n1\n[2, 3, 4]\n5\n\n\n\n\n\n튜플 원소 수정\n튜플(tuple)은 immutable(변경 불가능한) 자료형이므로, 한 번 생성된 튜플의 원소를 직접 수정하거나 삭제할 수 없다. 즉, 리스트처럼 t[0] = 100과 같은 방식으로 원소를 변경할 수 없다.\n\nt = (10, 20, 30)\nt[0] = 100  # TypeError: 'tuple' object does not support item assignment\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[59], line 2\n      1 t = (10, 20, 30)\n----&gt; 2 t[0] = 100  # TypeError: 'tuple' object does not support item assignment\n\nTypeError: 'tuple' object does not support item assignment\n\n\n\n하지만 튜플을 변경하는 것처럼 보이는 몇 가지 우회적인 방법이 있다.\n\n\n\n\n\n\n\n\n방법\n설명\n예제\n\n\n\n\n리스트 변환 후 변경\n튜플 → 리스트 → 원소 수정 후 다시 튜플 변환\ntuple(list(t))\n\n\n새로운 튜플 생성\n기존 요소를 조합하여 새로운 튜플 생성\n(100,) + t[1:]\n\n\n+= 연산자 사용\n기존 튜플에 새로운 요소 추가 (새 튜플 생성)\nt += (40,)\n\n\n\n튜플은 변경 불가능(immutable)한 자료형이므로, 직접 수정하는 것이 아니라 새로운 튜플을 만들어 교체하는 방식으로 업데이트해야 한다.\n\n기존 튜플을 변형하여 새로운 튜플 만들기\n튜플은 변경할 수 없지만, 기존 튜플을 조합하여 새로운 튜플을 만들 수 있다.\n\nt = (10, 20, 30)\n\n# 첫 번째 원소를 100으로 변경하는 새로운 튜플 생성\nnew_t = (100,) + t[1:]\nprint(new_t)  # (100, 20, 30)\n\n(100, 20, 30)\n\n\n\n\n\n\n\n튜플을 리스트로 변환 후 수정\n튜플 자체를 수정할 수 없으므로, 리스트(list)로 변환한 후 수정하고 다시 튜플로 변환할 수 있다.\n\nt = (10, 20, 30)\n\n# 리스트로 변환 후 값 변경\ntemp_list = list(t)\ntemp_list[0] = 100  # 첫 번째 원소 변경\nt = tuple(temp_list)  # 다시 튜플로 변환\n\nprint(t)  # (100, 20, 30)\n\n(100, 20, 30)\n\n\n\n\n\n\n\n튜플 요소 일부 변경 (여러 개 수정)\n튜플을 리스트로 변환하면 여러 요소를 한 번에 변경할 수도 있다.\n\nt = (10, 20, 30, 40)\n\n# 리스트로 변환하여 일부 요소 변경\ntemp_list = list(t)\ntemp_list[1:3] = [200, 300]  # 인덱스 1~2 요소 변경\nt = tuple(temp_list)\n\nprint(t)  # (10, 200, 300, 40)\n\n(10, 200, 300, 40)\n\n\n\n\n튜플을 분해하고 재조합\n튜플의 일부를 유지하면서 새로운 요소를 추가하여 업데이트할 수도 있다.\n\nt = (10, 20, 30)\n\n# 첫 번째 원소를 변경하고 나머지는 유지\nt = (100,) + t[1:]\n\nprint(t)  # (100, 20, 30)\n\n(100, 20, 30)\n\n\n\n\n+= 연산자로 새로운 값 추가 (새 튜플 생성)\n튜플은 변경할 수 없지만, += 연산을 사용하면 새로운 튜플을 만들어 갱신할 수 있다.\n\nt = (10, 20, 30)\nprint(\"0x%X\" % id(t))\n\n# 기존 튜플에 새로운 요소 추가\nt += (40,)\nprint(\"0x%X\" % id(t))\n\nprint(t)  # (10, 20, 30, 40)\n\n0x7F72B3F5EE40\n0x7F72B3F510D0\n(10, 20, 30, 40)\n\n\n\n\n\n이 방식은 기존 튜플을 수정하는 것이 아니라, 새로운 튜플을 만들어 변수에 다시 할당하는 것이다.\n\n\n\n튜플 원소 추가\n튜플(tuple)은 변경 불가능(immutable)한 자료형이므로, 한 번 생성된 튜플에 원소를 직접 추가할 수 없다.\n즉, 리스트의 append()나 extend() 같은 메서드는 튜플에서 사용할 수 없다.\n\nt = (10, 20, 30)\n\n# 원소 추가 시도 (오류 발생)\nt.append(40)  # AttributeError: 'tuple' object has no attribute 'append'\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[65], line 4\n      1 t = (10, 20, 30)\n      3 # 원소 추가 시도 (오류 발생)\n----&gt; 4 t.append(40)  # AttributeError: 'tuple' object has no attribute 'append'\n\nAttributeError: 'tuple' object has no attribute 'append'\n\n\n\n\nt = (10, 20, 30)\n\nt += (40,)  # 가능하지만 새로운 튜플이 생성됨\n\n그러나 우회적인 방법을 사용하면 튜플에 원소를 추가할 수 있다.\n\n\n\n\n\n\n\n\n방법\n설명\n예제\n\n\n\n\n새로운 튜플 결합\n기존 튜플과 새로운 원소를 더해 새로운 튜플 생성\nt = t + (40,)\n\n\n리스트 변환 후 추가\n리스트로 변환 → append() → 다시 튜플로 변환\ntuple(list(t) + [40])\n\n\n+= 연산자 사용\n기존 튜플에 새로운 튜플을 더해 새로 할당\nt += (40,)\n\n\n언패킹 * 사용\n튜플을 풀어서 새로운 원소 추가\nt = (*t, 40)\n\n\n\n튜플은 변경 불가능(immutable) 하므로, 원소를 직접 추가하는 것이 아니라 새로운 튜플을 만들어 다시 할당하는 방식을 사용해야 한다.\n\n새로운 튜플을 만들어 기존 요소와 결합\n튜플을 직접 변경할 수 없기 때문에, 새로운 튜플을 생성하여 기존 튜플과 결합하는 방식을 사용할 수 있다.\n\nt = (10, 20, 30)\n\n# 새로운 원소 추가 (새 튜플 생성)\nt = t + (40,)\nprint(t)  # (10, 20, 30, 40)\n\n(10, 20, 30, 40)\n\n\n여러 개의 원소를 추가할 수도 있다.\n\nt = t + (50, 60)\nprint(t)  # (10, 20, 30, 40, 50, 60)\n\n(10, 20, 30, 40, 50, 60)\n\n\n\n\n리스트로 변환 후 원소 추가\n튜플을 리스트(list)로 변환한 후 원소를 추가하고 다시 튜플로 변환하는 방법도 있다.\n\nt = (10, 20, 30)\n\n# 리스트로 변환 후 원소 추가\ntemp_list = list(t)\ntemp_list.append(40)\nt = tuple(temp_list)\n\nprint(t)  # (10, 20, 30, 40)\n\n(10, 20, 30, 40)\n\n\n리스트 변환 방식을 사용하면 여러 개의 원소를 추가하는 것도 간단하다.\n\ntemp_list.extend([50, 60])  # 여러 원소 추가\nt = tuple(temp_list)\n\nprint(t)  # (10, 20, 30, 40, 50, 60)\n\n(10, 20, 30, 40, 50, 60)\n\n\n\n\n+= 연산자로 새로운 튜플 추가\n튜플은 += 연산을 사용할 수 있지만, 이는 기존 튜플을 변경하는 것이 아니라 새로운 튜플을 생성하여 다시 할당하는 것이다.\n\nt = (10, 20, 30)\n\n# 새로운 튜플 추가\nt += (40,)\n\nprint(t)  # (10, 20, 30, 40)\n\n(10, 20, 30, 40)\n\n\n여러 개의 원소를 추가할 수도 있다.\n\nt += (50, 60)\nprint(t)  # (10, 20, 30, 40, 50, 60)\n\n(10, 20, 30, 40, 50, 60)\n\n\n\n\n언패킹을 이용한 추가\n튜플을 언패킹(unpacking)하여 새로운 튜플을 생성하는 방법도 있다.\n\nt = (10, 20, 30)\n\n# 언패킹하여 새로운 튜플 생성\nt = (*t, 40)\nprint(t)  # (10, 20, 30, 40)\n\n(10, 20, 30, 40)\n\n\n이 방식은 리스트 변환 없이 튜플만 사용하므로, 간단하게 추가할 때 유용하다.\n\n\n\n튜플 원소 삭제\n튜플(tuple)은 immutable(변경 불가능) 자료형이므로, 튜플 내 원소를 삭제할 수 없다.\n즉, 리스트의 remove()나 pop() 메서드를 사용하여 원소를 삭제하는 것이 불가능하다.\n\nt = (10, 20, 30)\n\n# 원소 삭제 시도 (오류 발생)\ndel t[0]  # TypeError: 'tuple' object doesn't support item deletion\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[74], line 4\n      1 t = (10, 20, 30)\n      3 # 원소 삭제 시도 (오류 발생)\n----&gt; 4 del t[0]  # TypeError: 'tuple' object doesn't support item deletion\n\nTypeError: 'tuple' object doesn't support item deletion\n\n\n\n하지만 튜플에서 원소를 삭제하는 것처럼 보이는 몇 가지 우회적인 방법이 있다.\n\n\n\n\n\n\n\n\n방법\n설명\n예제\n\n\n\n\n새로운 튜플 생성\n삭제할 원소를 제외한 새로운 튜플 생성\nt = t[1:]\n\n\n리스트 변환 후 삭제\n리스트로 변환 후 remove() 또는 pop()으로 삭제\ntemp_list.remove(20)\n\n\ndel 문 사용\n전체 튜플 삭제\ndel t\n\n\n+= 연산자 사용\n새로운 튜플을 생성하여 원소 제외\nt = t[:1] + t[3:]\n\n\n\n튜플은 변경 불가능(immutable) 하므로, 원소를 직접 삭제하는 것이 아니라 새로운 튜플을 만들어 교체하는 방식으로 원소를 제외할 수 있다.\n\n새로운 튜플을 만들어 원소 제외시키기\n튜플은 변경 불가능하므로 원소를 삭제할 수는 없지만, 새로운 튜플을 만들어 삭제할 원소를 제외하는 방식으로 해결할 수 있다.\n\nt = (10, 20, 30, 40)\n\n# 첫 번째 원소 삭제 (새로운 튜플 생성)\nt = t[1:]\nprint(t)  # (20, 30, 40)\n\n(20, 30, 40)\n\n\n여러 원소를 삭제할 수도 있다.\n\n# 두 번째와 세 번째 원소 삭제\nt = t[:1] + t[3:]\nprint(t)  # (20, 40)\n\n(20,)\n\n\n\n\n리스트로 변환 후 원소 삭제\n튜플을 리스트로 변환한 후 remove() 또는 pop()을 사용하여 원소를 삭제하고, 다시 튜플로 변환할 수 있다.\n\nt = (10, 20, 30, 40)\n\n# 리스트로 변환 후 첫 번째 원소 삭제\ntemp_list = list(t)\ntemp_list.remove(20)  # 첫 번째 원소 20 삭제\nt = tuple(temp_list)\n\nprint(t)  # (10, 30, 40)\n\n(10, 30, 40)\n\n\nremove()는 값으로 삭제하고, pop()은 인덱스로 삭제할 수 있다.\n\n# 인덱스 2인 원소 삭제 (pop 사용)\ntemp_list.pop(2)\nt = tuple(temp_list)\n\nprint(t)  # (10, 30)\n\n(10, 30)\n\n\n\n\ndel 문을 사용한 삭제\ndel 문을 사용하여 튜플을 삭제할 수는 있지만 원소를 개별적으로 삭제하는 것은 불가능하다. 튜플 전체를 삭제하는 데 사용될 수 있다.\n\nt = (10, 20, 30, 40)\n\n# 튜플 전체 삭제\ndel t\nprint(t)  # NameError: name 't' is not defined\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[79], line 5\n      3 # 튜플 전체 삭제\n      4 del t\n----&gt; 5 print(t)  # NameError: name 't' is not defined\n\nNameError: name 't' is not defined\n\n\n\n\n\n+= 연산자 사용하여 원소 제외\n+= 연산자를 사용하여 원소를 제외하는 방식으로 새로운 튜플을 만들 수 있다.\n\nt = (10, 20, 30, 40)\n\n# 20과 30을 제외한 새로운 튜플 생성\nt = t[:1] + t[3:]\n\nprint(t)  # (10, 40)\n\n(10, 40)",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>자료형</span>"
    ]
  },
  {
    "objectID": "30datatype.html#sec-dictionay",
    "href": "30datatype.html#sec-dictionay",
    "title": "자료형",
    "section": "딕셔너리",
    "text": "딕셔너리\n딕셔너리(dictionary)는 키(key)와 값(value)의 쌍으로 이루어진 변경 가능한(mutable) 자료형이다.\n\n딕셔너리 생성\n딕셔너리는 순서가 없으며 키를 통해 빠르게 값을 조회할 수 있다. 파이썬에서 딕셔너리는 중괄호 {}를 사용하여 생성한다.\n\n\n\n\n\n\n\n\n방법\n설명\n예제\n\n\n\n\n중괄호 {} 사용\n키와 값의 쌍을 중괄호 안에 정의\n{\"name\": \"John\", \"age\": 30}\n\n\ndict() 함수 사용\n튜플이나 키워드 인자로 딕셔너리 생성\ndict(name=\"John\", age=30)\n\n\n빈 딕셔너리 생성\n빈 딕셔너리 생성\n{} 또는 dict()\n\n\ndefaultdict 사용\n기본값을 설정한 딕셔너리 생성\ndefaultdict(list)\n\n\n딕셔너리 컴프리헨션\n간결하게 딕셔너리 생성\n{x: x**2 for x in range(5)}\n\n\n\n딕셔너리는 키와 값의 쌍으로 데이터를 저장하며, 키를 통해 빠르게 값에 접근할 수 있는 자료형이다. dict() 함수나 중괄호 {}를 사용하여 다양한 방식으로 딕셔너리를 생성할 수 있다.\n\n기본 딕셔너리 생성\n딕셔너리를 중괄호 {}로 생성하고, 각 키와 값을 콜론 :으로 구분하여 정의한다. 여러 쌍을 추가할 때는 쉼표 ,로 구분한다.\n\n# 기본 딕셔너리 생성\nperson = {\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}\n\nprint(person)\n\n{'name': 'John', 'age': 30, 'city': 'New York'}\n\n\n\n\ndict() 함수 사용\ndict() 함수를 사용하여 딕셔너리를 생성할 수도 있다. 이 방법은 키와 값을 튜플의 형태로 전달하거나 키워드 인자를 사용하는 방식이다.\n\n튜플을 이용한 방식\n\n# 튜플을 이용해 딕셔너리 생성\nperson = dict([(\"name\", \"John\"), (\"age\", 30), (\"city\", \"New York\")])\n\nprint(person)\n\n{'name': 'John', 'age': 30, 'city': 'New York'}\n\n\n\n\n키워드 인자를 이용한 방식\n\n# 키워드 인자를 이용한 딕셔너리 생성\nperson = dict(name=\"John\", age=30, city=\"New York\")\n\nprint(person)\n\n{'name': 'John', 'age': 30, 'city': 'New York'}\n\n\n\n\n\n빈 딕셔너리 생성\n빈 딕셔너리를 생성하려면 중괄호 {}를 사용하거나 dict() 함수를 사용할 수 있다.\n\n# 빈 딕셔너리 생성\nempty_dict = {}\n\n# 또는\nempty_dict2 = dict()\n\nprint(empty_dict)   # 출력: {}\nprint(empty_dict2)  # 출력: {}\n\n{}\n{}\n\n\n\n\n딕셔너리 생성 시 기본값 설정\n딕셔너리의 값으로 기본값을 설정할 수도 있다. defaultdict는 collections 모듈에서 제공하는 클래스인데, 특정 키가 존재하지 않으면 기본값을 설정해준다.\n\nfrom collections import defaultdict\n\n# 기본값을 리스트로 설정한 defaultdict 생성\nd = defaultdict(list)\n\n# 키가 없으면 기본값으로 빈 리스트를 반환\nd[\"fruits\"].append(\"apple\")\nd[\"fruits\"].append(\"banana\")\n\nprint(d)\n\ndefaultdict(&lt;class 'list'&gt;, {'fruits': ['apple', 'banana']})\n\n\n\n\n딕셔너리 컴프리헨션 사용\n딕셔너리 컴프리헨션(dictionary comprehension)을 사용하여 짧고 간결하게 딕셔너리를 생성할 수 있다.\n\n# 딕셔너리 컴프리헨션\nsquares = {x: x**2 for x in range(5)}\n\nprint(squares)\n\n{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}\n\n\n\n\n\n딕셔너리 원소 접근\n딕셔너리(dictionary)는 키(key)를 사용하여 값(value)에 접근하는 키-값(key-value) 쌍의 자료구조이다. 딕셔너리의 원소를 접근하는 방법에는 여러 가지가 있다.\n\n\n\n\n\n\n\n\n접근 방법\n코드 예제\n설명\n\n\n\n\n키를 이용한 접근\nperson[\"name\"]\n키로 직접 값에 접근\n\n\nget() 사용\nperson.get(\"name\", \"기본값\")\n기본값을 설정하여 안전하게 접근\n\n\n키 목록 가져오기\nperson.keys()\n모든 키 반환\n\n\n값 목록 가져오기\nperson.values()\n모든 값 반환\n\n\n키-값 쌍 가져오기\nperson.items()\n(키, 값) 튜플 목록 반환\n\n\n키 존재 여부 확인\n\"name\" in person\n키가 존재하는지 확인\n\n\n반복문에서 활용\nfor key, value in person.items():\n모든 키-값 순회\n\n\n\n딕셔너리는 키를 사용하여 데이터를 빠르게 조회할 수 있으며, get()을 사용하면 KeyError를 방지할 수 있다.\n\n기본적인 키를 이용한 접근\n딕셔너리는 키를 사용하여 값에 접근한다.\n\nperson = {\"name\": \"Alice\", \"age\": 25, \"city\": \"Seoul\"}\n\nprint(person[\"name\"])  # Alice\nprint(person[\"age\"])   # 25\nprint(person[\"city\"])  # Seoul\n\nAlice\n25\nSeoul\n\n\n\n주의할 점\n\n\n존재하지 않는 키를 접근하면 KeyError가 발생한다.\n\n\n\n\nprint(person[\"job\"])  # KeyError 발생\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[88], line 1\n----&gt; 1 print(person[\"job\"])  # KeyError 발생\n\nKeyError: 'job'\n\n\n\n\n\nget() 메서드를 이용한 접근\nget() 메서드는 키가 존재하지 않을 경우 기본값(default value)을 반환할 수 있어 안전하게 값을 가져올 수 있다.\n\nprint(person.get(\"name\"))     # Alice\nprint(person.get(\"job\"))      # None (KeyError 발생하지 않음)\nprint(person.get(\"job\", \"N/A\"))  # 기본값 \"N/A\" 반환\n\nAlice\nNone\nN/A\n\n\n\nget(\"키\", \"기본값\") 형식으로 사용하며, 키가 없을 경우 기본값을 반환한다.\nget()을 사용하면 KeyError를 방지할 수 있다.\n\n\n\nkeys()를 이용한 키 목록 접근\nkeys() 메서드는 딕셔너리의 모든 키 목록을 반환한다.\n\nprint(person.keys())  # dict_keys(['name', 'age', 'city'])\n\ndict_keys(['name', 'age', 'city'])\n\n\n\nlist()를 사용하면 리스트로 변환할 수 있다.\n\n\nkeys_list = list(person.keys())\nprint(keys_list)  # ['name', 'age', 'city']\n\n['name', 'age', 'city']\n\n\n\n\nvalues()를 이용한 값 목록 접근\nvalues() 메서드는 딕셔너리의 모든 값 목록을 반환한다.\n\nprint(person.values())  # dict_values(['Alice', 25, 'Seoul'])\n\ndict_values(['Alice', 25, 'Seoul'])\n\n\n\n리스트로 변환할 수도 있다.\n\n\nvalues_list = list(person.values())\nprint(values_list)  # ['Alice', 25, 'Seoul']\n\n['Alice', 25, 'Seoul']\n\n\n\n\nitems()를 이용한 키-값 쌍 접근\nitems() 메서드는 딕셔너리의 모든 (키, 값) 쌍을 튜플로 반환한다.\n\nprint(person.items())  # dict_items([('name', 'Alice'), ('age', 25), ('city', 'Seoul')])\n\ndict_items([('name', 'Alice'), ('age', 25), ('city', 'Seoul')])\n\n\n반복문에서 활용 가능하다.\n\nfor key, value in person.items():\n    print(f\"{key}: {value}\")\n\nname: Alice\nage: 25\ncity: Seoul\n\n\n\n\nin 연산자를 이용한 키 존재 여부 확인\n딕셔너리에 특정 키가 존재하는지 확인하려면 in 연산자를 사용한다.\n\nif \"name\" in person:\n    print(\"name 키가 존재합니다.\")  # 출력됨\n\nif \"job\" not in person:\n    print(\"job 키가 존재하지 않습니다.\")  # 출력됨\n\nname 키가 존재합니다.\njob 키가 존재하지 않습니다.\n\n\n\n\n딕셔너리를 이용한 반복문(for 문)\n\n키를 반복\n\nfor key in person:\n    print(key)  # name, age, city\n\nname\nage\ncity\n\n\n\n\n값만 반복\n\nfor value in person.values():\n    print(value)  # Alice, 25, Seoul\n\nAlice\n25\nSeoul\n\n\n\n\n키와 값을 동시에 반복\n\nfor key, value in person.items():\n    print(f\"{key}: {value}\")\n\nname: Alice\nage: 25\ncity: Seoul\n\n\n\n\n\n\n딕셔너리 원소 수정\n딕셔너리에서 원소를 업데이트(update) 하려면 키를 통해 값을 수정하거나 추가하는 방식으로 진행할 수 있다. 기존 키의 값을 수정하거나 새로운 키-값 쌍을 추가할 수 있다.\n\n\n\n\n\n\n\n\n방법\n설명\n예제\n\n\n\n\n키를 이용한 수정\n특정 키의 값을 직접 수정\nperson[\"age\"] = 35\n\n\nupdate() 메서드\n여러 키-값 쌍을 한 번에 추가하거나 수정\nperson.update({\"age\": 35})\n\n\nsetdefault() 메서드\n키가 존재하면 값 수정 안 하고, 없으면 기본값을 추가\nperson.setdefault(\"city\", \"New York\")\n\n\n딕셔너리 컴프리헨션\n조건에 맞는 키-값 쌍을 업데이트\n{key: value + 1 for key, value in person.items()}\n\n\ndict()와 update() 사용\n기존 딕셔너리를 복사하고 업데이트\nnew_person = dict(person)\n\n\n\n딕셔너리에서는 키를 사용하여 값을 수정하거나 update() 메서드를 사용하여 여러 값을 동시에 수정할 수 있으며, setdefault() 메서드를 통해 키가 없으면 추가할 수 있다.\n\n키를 이용한 값 수정\n딕셔너리에서 특정 키의 값을 수정하려면 해당 키를 사용하여 새로운 값을 할당하면 된다.\n\n# 딕셔너리 생성\nperson = {\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}\n\n# 'age' 키의 값을 수정\nperson[\"age\"] = 35\n\nprint(person)\n\n{'name': 'John', 'age': 35, 'city': 'New York'}\n\n\n\n\nupdate() 메서드 사용\nupdate() 메서드는 기존 딕셔너리에 다른 딕셔너리나 키-값 쌍을 추가하거나 수정하는 데 사용된다.\n- 만약 기존에 있는 키가 있다면 값을 수정하고, - 존재하지 않는 키가 있다면 새로운 키-값 쌍을 추가한다.\n\n# 딕셔너리 생성\nperson = {\"name\": \"John\", \"age\": 30}\n\n# `update()`를 사용하여 값 수정\nperson.update({\"age\": 35, \"city\": \"New York\"})\n\nprint(person)\n\n{'name': 'John', 'age': 35, 'city': 'New York'}\n\n\nupdate() 메서드는 여러 개의 키-값 쌍을 한 번에 업데이트할 수 있다.\n\n# 여러 키-값 쌍을 업데이트\nperson.update({\"email\": \"john@example.com\", \"phone\": \"123-456-7890\"})\n\nprint(person)\n\n{'name': 'John', 'age': 35, 'city': 'New York', 'email': 'john@example.com', 'phone': '123-456-7890'}\n\n\n\n\nsetdefault() 메서드 사용\nsetdefault() 메서드는 딕셔너리에서 특정 키가 존재하지 않으면 값이 추가되도록 하는 메서드이다.\n키가 존재하면 값을 수정하지 않으며, 키가 없다면 지정된 기본값을 추가한다.\n\n# 딕셔너리 생성\nperson = {\"name\": \"John\", \"age\": 30}\n\n# 키가 존재하면 값 수정하지 않음, 없으면 값 추가\nperson.setdefault(\"age\", 35)  # 'age'가 이미 존재하므로 값 수정되지 않음\nperson.setdefault(\"city\", \"New York\")  # 'city'가 없으므로 값 추가\n\nprint(person)\n\n{'name': 'John', 'age': 30, 'city': 'New York'}\n\n\n\n\n딕셔너리 컴프리헨션 사용\n딕셔너리 컴프리헨션을 사용하여 조건에 맞는 키-값 쌍을 업데이트할 수도 있다.\n\n# 딕셔너리 생성\nperson = {\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}\n\n# 나이가 30 이상인 사람의 나이 1 증가\nperson = {key: (value + 1 if key == \"age\" else value) for key, value in person.items()}\n\nprint(person)\n\n{'name': 'John', 'age': 31, 'city': 'New York'}\n\n\n\n\ndict()와 update()로 새로운 딕셔너리 생성\n기존 딕셔너리를 기반으로 새로운 딕셔너리를 만들고 업데이트할 수도 있다.\n\n# 딕셔너리 생성\nperson = {\"name\": \"John\", \"age\": 30}\n\n# 새로운 딕셔너리 생성 후 update로 수정\nnew_person = dict(person)\nnew_person.update({\"age\": 35, \"city\": \"New York\"})\n\nprint(new_person)\n\n{'name': 'John', 'age': 35, 'city': 'New York'}\n\n\n\n\n\n딕셔너리 원소 추가\n딕셔너리에서 원소를 추가하는 방법은 매우 간단하다. 새로운 키-값 쌍을 삽입하는 방식으로 원소를 추가할 수 있다. 딕셔너리는 키를 통해 값을 추가하며, 존재하지 않는 키에 값을 할당하면 새로운 원소가 추가된다.\n\n\n\n\n\n\n\n\n방법\n설명\n예제\n\n\n\n\n직접 추가\n새로운 키-값 쌍을 직접 추가\nperson[\"city\"] = \"New York\"\n\n\nupdate() 메서드\n여러 키-값 쌍을 한 번에 추가\nperson.update({\"city\": \"New York\"})\n\n\nsetdefault() 메서드\n키가 존재하지 않으면 값을 추가, 존재하면 값 유지\nperson.setdefault(\"city\", \"New York\")\n\n\n딕셔너리 컴프리헨션\n조건에 맞는 동적 추가\n{**person, **{\"city\": \"New York\"}}\n\n\n\n딕셔너리는 새로운 키-값 쌍을 추가하는 데 매우 유연하다. update()나 setdefault()를 사용하면 여러 키-값 쌍을 동시에 추가하거나 기존 값을 수정할 수 있으며, 딕셔너리 컴프리헨션을 사용하여 동적으로 새로운 원소를 추가할 수 있다.\n\n키-값 쌍을 직접 추가\n딕셔너리에서 새로운 키-값 쌍을 추가하려면, 새로운 키를 지정하고 값을 할당하면 된다.\n\n# 딕셔너리 생성\nperson = {\"name\": \"John\", \"age\": 30}\n\n# 'city'라는 새로운 키와 값을 추가\nperson[\"city\"] = \"New York\"\n\nprint(person)\n\n{'name': 'John', 'age': 30, 'city': 'New York'}\n\n\n\n\nupdate() 메서드 사용\nupdate() 메서드는 기존 딕셔너리에 새로운 키-값 쌍을 추가하거나 기존 키의 값을 수정하는 데 사용된다. 새로운 키가 있을 경우, 그 키와 값이 추가된다.\n\n# 딕셔너리 생성\nperson = {\"name\": \"John\", \"age\": 30}\n\n# `update()`로 새로운 키-값 추가\nperson.update({\"city\": \"New York\", \"email\": \"john@example.com\"})\n\nprint(person)\n\n{'name': 'John', 'age': 30, 'city': 'New York', 'email': 'john@example.com'}\n\n\nupdate() 메서드는 여러 키-값 쌍을 한 번에 추가할 수 있다.\n\n# 여러 개의 키-값 쌍을 한 번에 추가\nperson.update({\"phone\": \"123-456-7890\", \"address\": \"123 Street, NY\"})\n\nprint(person)\n\n{'name': 'John', 'age': 30, 'city': 'New York', 'email': 'john@example.com', 'phone': '123-456-7890', 'address': '123 Street, NY'}\n\n\n\n\nsetdefault() 메서드 사용\nsetdefault() 메서드는 새로운 키-값 쌍을 추가하는 방법 중 하나다. 만약 키가 존재하지 않으면 값을 추가하고, 존재하면 기존 값을 그대로 두는 방식이다. 이 메서드는 기존 키의 값을 수정하지 않으며, 키가 없으면 기본값을 추가한다.\n\n# 딕셔너리 생성\nperson = {\"name\": \"John\", \"age\": 30}\n\n# 'city'가 없으면 추가, 'city'가 이미 있으면 수정하지 않음\nperson.setdefault(\"city\", \"New York\")\n\nprint(person)\n\n{'name': 'John', 'age': 30, 'city': 'New York'}\n\n\n만약 기존에 ‘city’ 키가 존재하면, 값을 변경하지 않음.\n\n# 'city'는 이미 존재하므로 값은 변경되지 않음\nperson.setdefault(\"city\", \"Los Angeles\")\n\nprint(person)\n\n{'name': 'John', 'age': 30, 'city': 'New York'}\n\n\n\n\n딕셔너리 컴프리헨션을 사용한 추가\n딕셔너리 컴프리헨션(dictionary comprehension)을 사용하여 조건에 맞는 키-값 쌍을 추가할 수 있다. 예를 들어, 특정 조건에 맞는 새로운 키-값 쌍을 동적으로 생성할 수 있다.\n\n# 기존 딕셔너리\nperson = {\"name\": \"John\", \"age\": 30}\n\n# 딕셔너리 컴프리헨션을 사용하여 새로운 키-값 쌍 추가\nperson = {**person, **{\"city\": \"New York\", \"email\": \"john@example.com\"}}\n\nprint(person)\n\n{'name': 'John', 'age': 30, 'city': 'New York', 'email': 'john@example.com'}\n\n\n\n\n\n딕셔너리 원소 삭제\n딕셔너리에서 원소를 삭제하는 방법은 여러 가지가 있다. 키를 사용하여 원소를 삭제하거나, 특정 메서드를 사용하여 원소를 제거할 수 있다. 딕셔너리에서 원소를 삭제하면, 그 키와 값이 함께 삭제된다.\n\n\n\n\n\n\n\n\n방법\n설명\n예제\n\n\n\n\ndel 키워드\n특정 키-값 쌍을 삭제\ndel person[\"age\"]\n\n\npop() 메서드\n특정 키-값 쌍을 삭제하고 값을 반환\nperson.pop(\"age\")\n\n\npopitem() 메서드\n마지막 키-값 쌍을 삭제하고 반환\nperson.popitem()\n\n\nclear() 메서드\n모든 원소를 삭제\nperson.clear()\n\n\ndel 키워드 (전체 삭제)\n딕셔너리 자체를 삭제\ndel person\n\n\n\n딕셔너리에서 원소를 삭제하는 방법은 다양한데, del 키워드, pop(), popitem(), clear() 메서드를 적절히 사용하여 원소나 전체 딕셔너리를 삭제할 수 있다.\n\ndel 키워드 사용\ndel 키워드는 딕셔너리에서 특정 키-값 쌍을 삭제하는 데 사용된다.\n\n# 딕셔너리 생성\nperson = {\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}\n\n# 'age' 키와 그 값을 삭제\ndel person[\"age\"]\n\nprint(person)\n\n{'name': 'John', 'city': 'New York'}\n\n\n만약 존재하지 않는 키를 삭제하려고 하면 KeyError가 발생한다.\n\n# 존재하지 않는 키를 삭제 시 오류 발생\ndel person[\"email\"]  # KeyError: 'email'\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[113], line 2\n      1 # 존재하지 않는 키를 삭제 시 오류 발생\n----&gt; 2 del person[\"email\"]  # KeyError: 'email'\n\nKeyError: 'email'\n\n\n\n\n\npop() 메서드 사용\npop() 메서드는 딕셔너리에서 특정 키에 해당하는 값을 삭제하고, 그 값을 반환한다. 이 메서드는 삭제하려는 키가 존재하지 않으면 KeyError를 발생시킨다. 또한, 두 번째 인자로 기본값을 설정할 수 있어, 키가 없을 때 기본값을 반환하도록 할 수 있다.\n\n# 딕셔너리 생성\nperson = {\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}\n\n# 'age' 키와 그 값을 삭제하고, 값을 반환\nremoved_value = person.pop(\"age\")\n\nprint(person)\nprint(removed_value)\n\n{'name': 'John', 'city': 'New York'}\n30\n\n\n기본값을 설정하는 경우:\n\n# 존재하지 않는 키에 대해 기본값 반환\nremoved_value = person.pop(\"email\", \"Not Found\")\n\nprint(removed_value)\n\nNot Found\n\n\n\n\npopitem() 메서드 사용\npopitem() 메서드는 딕셔너리에서 마지막 키-값 쌍을 삭제하고, 그 쌍을 반환한다. 이 메서드는 LIFO(Last-In-First-Out) 방식으로 작동한다. 즉, 딕셔너리에서 가장 마지막에 삽입된 원소를 삭제한다.\n\n# 딕셔너리 생성\nperson = {\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}\n\n# 마지막 원소를 삭제하고 반환\nremoved_item = person.popitem()\n\nprint(person)\n\nprint(removed_item)\n\n{'name': 'John', 'age': 30}\n('city', 'New York')\n\n\npopitem()은 비어있는 딕셔너리에서 호출하면 KeyError를 발생시킨다.\n\n# 빈 딕셔너리에서 popitem() 호출 시 오류 발생\nempty_dict = {}\nempty_dict.popitem()  # KeyError\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[117], line 3\n      1 # 빈 딕셔너리에서 popitem() 호출 시 오류 발생\n      2 empty_dict = {}\n----&gt; 3 empty_dict.popitem()  # KeyError\n\nKeyError: 'popitem(): dictionary is empty'\n\n\n\n\n\nclear() 메서드 사용\nclear() 메서드는 딕셔너리의 모든 원소를 삭제하는 데 사용된다. 이 메서드는 딕셔너리를 비우고 빈 딕셔너리를 반환한다.\n\n# 딕셔너리 생성\nperson = {\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}\n\n# 모든 원소를 삭제\nperson.clear()\n\nprint(person)\n\n{}\n\n\n\n\ndel로 딕셔너리 전체 삭제\ndel 키워드를 사용하여 딕셔너리 자체를 삭제할 수도 있다. 이렇게 삭제하면, 딕셔너리가 메모리에서 완전히 사라지므로 더 이상 사용할 수 없다.\n\n# 딕셔너리 생성\nperson = {\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}\n\n# 딕셔너리 전체 삭제\ndel person\n\n# person은 더 이상 존재하지 않음\nprint(person)  # NameError: name 'person' is not defined\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[119], line 8\n      5 del person\n      7 # person은 더 이상 존재하지 않음\n----&gt; 8 print(person)  # NameError: name 'person' is not defined\n\nNameError: name 'person' is not defined",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>자료형</span>"
    ]
  },
  {
    "objectID": "30datatype.html#sec-set",
    "href": "30datatype.html#sec-set",
    "title": "자료형",
    "section": "집합",
    "text": "집합\n파이썬에서 집합(set)은 중복을 허용하지 않으며, 순서가 없는 자료형이다. 집합은 수학적인 집합을 표현하며, 교집합, 합집합, 차집합과 같은 집합 연산을 지원한다.\n\n집합 생성\n집합은 {}를 사용하여 생성할 수 있으며, 리스트나 튜플과는 달리 중복된 원소를 자동으로 제거한다.\n\n\n\n\n\n\n\n\n방법\n설명\n예제\n\n\n\n\n중괄호 {} 사용\n중복을 자동으로 제거하고 집합 생성\nmy_set = {1, 2, 3, 4}\n\n\nset() 함수 사용\n리스트, 튜플, 문자열 등 다른 자료형을 집합으로 변환\nmy_set = set([1, 2, 3])\n\n\n빈 집합 생성\nset() 함수를 사용하여 빈 집합 생성\nempty_set = set()\n\n\n\n집합은 중복을 허용하지 않으며, 순서가 없는 자료형으로 다양한 자료형을 집합으로 변환할 수 있다. 리스트에서 중복을 제거하거나 다양한 연산을 수행할 때 유용하게 사용할 수 있다.\n\n중괄호 {}를 사용하여 집합 생성\n가장 간단한 방법은 중괄호 {}를 사용하여 집합을 생성하는 것이다. 이때 중복된 원소는 자동으로 제거된다.\n\n# 집합 생성\nmy_set = {1, 2, 3, 4, 5}\n\nprint(my_set)\n\n{1, 2, 3, 4, 5}\n\n\n중복된 원소를 포함한 경우:\n\n# 중복된 원소가 있는 경우\nmy_set = {1, 2, 2, 3, 4, 5, 5}\n\nprint(my_set) # 중복된 2와 5는 자동으로 제거됨\n\n{1, 2, 3, 4, 5}\n\n\n\n\nset() 함수 사용\nset() 함수를 사용하여 다른 자료형을 집합으로 변환할 수도 있다. 이 방법은 리스트, 튜플, 문자열 등을 집합으로 변환할 때 유용하다.\n\n# 리스트를 집합으로 변환\nmy_list = [1, 2, 3, 4, 4, 5, 5]\nmy_set = set(my_list)\n\nprint(my_set)\n\n{1, 2, 3, 4, 5}\n\n\n\n# 문자열을 집합으로 변환\nmy_string = \"apple\"\nmy_set = set(my_string)\n\nprint(my_set) # 각 문자가 집합의 원소로 변환됨\n\n{'p', 'a', 'l', 'e'}\n\n\n\n\n빈 집합 생성\n빈 집합을 생성하려면 {}를 사용할 수 없다. {}는 빈 딕셔너리를 생성하기 때문이다. 빈 집합을 생성하려면 set() 함수를 사용해야 한다.\n\n# 빈 집합 생성\nempty_set = set()\n\nprint(empty_set)\n\nset()\n\n\n\n\n집합을 사용하여 중복 제거\n집합은 중복된 원소를 자동으로 제거하므로, 리스트나 다른 자료형에서 중복을 제거할 때 유용하다.\n\n# 리스트에서 중복을 제거한 집합 생성\nmy_list = [1, 2, 2, 3, 4, 4, 5]\nunique_set = set(my_list)\n\nprint(unique_set)\n\n{1, 2, 3, 4, 5}\n\n\n\n\n다양한 자료형을 집합으로 만들기\n집합은 숫자, 문자열, 튜플 등 다양한 자료형을 원소로 가질 수 있다.\n\n# 다양한 자료형을 포함하는 집합\nmy_set = {1, \"apple\", (2, 3)}\n\nprint(my_set)\n\n{(2, 3), 1, 'apple'}\n\n\n단, 집합의 원소는 변경할 수 없는 자료형(불변형)이어야 한다. 즉, 리스트나 딕셔너리는 집합의 원소로 사용할 수 없다.\n\n# 리스트는 집합의 원소로 사용할 수 없음\nmy_set = {1, [2, 3]}  # TypeError: unhashable type: 'list'\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[127], line 2\n      1 # 리스트는 집합의 원소로 사용할 수 없음\n----&gt; 2 my_set = {1, [2, 3]}  # TypeError: unhashable type: 'list'\n\nTypeError: unhashable type: 'list'\n\n\n\n\n# 딕셔너리도 집합의 원소로 사용할 수 없음\nmy_set = {1, {\"a\": 1}}  # TypeError: unhashable type: 'dict'\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[128], line 2\n      1 # 딕셔너리도 집합의 원소로 사용할 수 없음\n----&gt; 2 my_set = {1, {\"a\": 1}}  # TypeError: unhashable type: 'dict'\n\nTypeError: unhashable type: 'dict'\n\n\n\n\n\n\n집합 원소 접근\n집합(set)은 순서가 없는(unordered) 자료형이므로 인덱싱(indexing)이나 키(key)로 직접 접근할 수 없다. 하지만 다음과 같은 방법을 사용하여 원소를 확인할 수 있다.\n\n\n\n\n\n\n\n\n접근 방법\n코드 예제\n설명\n\n\n\n\n반복문으로 접근\nfor item in my_set:\n모든 원소를 순회\n\n\n특정 원소 확인\n10 in my_set\n존재 여부 확인 (True 또는 False)\n\n\npop() 사용\nitem = my_set.pop()\n임의의 원소를 가져오면서 제거\n\n\n리스트 변환 후 접근\nlist(my_set)[0]\n리스트로 변환 후 인덱싱\n\n\n정렬 후 접근\nsorted(my_set)[0]\n정렬된 리스트에서 특정 원소 접근\n\n\n\n집합은 순서가 없기 때문에 인덱싱이 불가능하며, 원소 접근이 필요할 경우 반복문이나 list() 변환을 활용해야 한다.\n\n반복문을 이용한 원소 접근\n집합의 원소를 하나씩 접근하려면 for 문을 사용한다.\n\nmy_set = {10, 20, 30, 40, 50}\n\nfor item in my_set:\n    print(item)\n\n50\n20\n40\n10\n30\n\n\n집합은 순서가 없기 때문에 출력 순서가 매번 달라질 수 있다.\n\n\nin 연산자를 이용한 특정 원소 존재 여부 확인\n집합 내 특정 원소가 존재하는지 확인할 때 in 연산자를 사용할 수 있다.\n\nmy_set = {10, 20, 30}\n\nprint(10 in my_set)  # True\nprint(50 in my_set)  # False\n\nTrue\nFalse\n\n\nin 연산자는 O(1)의 시간 복잡도로 매우 빠르게 원소를 검색할 수 있다.\n\n\npop()을 사용하여 원소 가져오기\npop() 메서드는 집합에서 임의의 원소를 제거하고 반환한다.\n\nmy_set = {100, 200, 300}\n\nitem = my_set.pop()\nprint(item)  # 어떤 값이 출력될지 알 수 없음\nprint(my_set)  # 원소 하나가 제거된 집합 출력\n\n200\n{100, 300}\n\n\n집합은 순서가 없기 때문에 어떤 원소가 제거될지 예측할 수 없다.\n\n\n리스트 변환 후 인덱싱으로 접근\n집합을 리스트로 변환하면 인덱싱을 사용할 수 있다.\n\nmy_set = {1, 2, 3, 4, 5}\n\nmy_list = list(my_set)  # 리스트로 변환\nprint(my_list[0])  # 첫 번째 원소 출력 (순서는 보장되지 않음)\n\n1\n\n\n집합을 리스트로 변환하면 순서가 랜덤하게 정해진다. 원소를 특정 순서로 접근해야 한다면, sorted()를 사용하여 정렬할 수 있다.\n\nsorted_list = sorted(my_set)\nprint(sorted_list[0])  # 가장 작은 값 출력\n\n1\n\n\n\n\n\n집합 원소 수정\n파이썬의 집합은 순서가 없고, 인덱스를 지원하지 않으며 중복된 원소를 허용하지 않는다는 특징을 가지고 있다. 이로 인해 집합의 원소를 수정하는 방법은 직접적으로 수정할 수 없다. 집합의 원소는 불변형(immutable) 자료형이어야 하므로, 한 번 집합에 추가된 원소는 변경할 수 없다.\n하지만 집합에서 원소를 수정하는 대신 원소를 삭제하고 새로운 값을 추가하는 방식으로 간접적으로 수정할 수 있다.\n\n\n\n\n\n\n\n\n방법\n설명\n예제\n\n\n\n\n원소 삭제 후 추가\n집합에서는 원소를 직접 수정할 수 없으므로, 삭제하고 새로운 값을 추가\nmy_set.remove(3) → my_set.add(10)\n\n\ndiscard() 사용\n원소가 없을 경우 오류를 방지하고 삭제\nmy_set.discard(3)\n\n\n\n집합은 원소의 순서나 인덱스를 고려할 수 없기 때문에, 원소의 직접적인 수정은 불가능하지만, 삭제 후 새로운 값을 추가하는 방법을 통해 수정할 수 있다.\n\n\n집합에서 원소 삭제 후 추가\n집합은 원소의 위치나 값 자체를 수정할 수 없기 때문에, 원소를 삭제하고, 수정된 값을 새로 추가하는 방법을 사용한다.\n\n# 집합 생성\nmy_set = {1, 2, 3, 4, 5}\n\n# '3'을 수정하려면 삭제하고 새로 추가해야 한다.\nmy_set.remove(3)  # '3' 삭제\nmy_set.add(10)    # '10' 추가\n\nprint(my_set)\n\n{1, 2, 4, 5, 10}\n\n\n이 방법은 원소를 수정하는 효과를 낼 수 있지만, 원소의 값을 직접 변경하는 것은 아니다.\n\n\ndiscard()와 remove() 메서드 차이점\n\nremove(): 해당 원소가 집합에 존재하지 않으면 KeyError를 발생시킨다.\ndiscard(): 해당 원소가 집합에 존재하지 않으면 오류를 발생시키지 않고 그냥 넘어간다.\n\n따라서 원소가 존재하지 않을 경우 에러를 방지하려면 discard()를 사용하는 것이 좋다.\n\n# '3'이 존재할 때 삭제하는 예시\nmy_set = {1, 2, 3, 4, 5}\nmy_set.remove(3)  # '3'을 삭제\n\nprint(my_set)\n\n# '3'이 존재하지 않으면 오류 발생\nmy_set.remove(3)  # KeyError: 3\n\nprint(my_set)\n\n{1, 2, 4, 5}\n\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[135], line 8\n      5 print(my_set)\n      7 # '3'이 존재하지 않으면 오류 발생\n----&gt; 8 my_set.remove(3)  # KeyError: 3\n     10 print(my_set)\n\nKeyError: 3\n\n\n\n\n# '3'이 존재할 때 삭제하는 예시\nmy_set = {1, 2, 3, 4, 5}\nmy_set.remove(3)  # '3'을 삭제\n\nprint(my_set)\n\n# discard()는 오류를 발생시키지 않는다\nmy_set.discard(3)  # '3'이 없으면 그냥 넘어감\n\nprint(my_set)\n\n{1, 2, 4, 5}\n{1, 2, 4, 5}\n\n\n\n\n집합에서 원소 수정이 필요한 경우\n집합에서 원소를 직접 수정하는 것은 불가능하지만, 원소가 포함된 조건에 맞는 새로운 집합을 생성하거나 기존 집합을 업데이트하는 방식으로 대체할 수 있다.\n예를 들어, 집합에서 특정 값이 있는 경우 이를 새로운 값으로 변경하는 방법은 다음과 같다.\n\n# 집합 생성\nmy_set = {1, 2, 3, 4, 5}\n\n# 집합의 원소 중 3을 10으로 변경\nif 3 in my_set:\n    my_set.remove(3)\n    my_set.add(10)\n\nprint(my_set)\n\n{1, 2, 4, 5, 10}\n\n\n\n\n집합 원소 수정에 대한 주의점\n\n집합은 순서가 없고, 인덱스를 지원하지 않기 때문에 인덱스를 사용하여 원소를 수정할 수 없다.\n집합의 원소는 불변형 자료형이어야 하므로 원소를 수정하려면 삭제 후 추가하는 방법을 사용해야 한다.\nremove()는 원소가 없으면 KeyError를 발생시키고, discard()는 원소가 없으면 아무런 오류도 발생시키지 않는다.\n\n\n\n\n\n\n\n\n\n방법\n설명\n예제\n\n\n\n\n원소 삭제 후 추가\n집합에서는 원소를 직접 수정할 수 없으므로, 삭제하고 새로운 값을 추가\nmy_set.remove(3) → my_set.add(10)\n\n\ndiscard() 사용\n원소가 없을 경우 오류를 방지하고 삭제\nmy_set.discard(3)\n\n\n\n집합은 원소의 순서나 인덱스를 고려할 수 없기 때문에, 원소의 직접적인 수정은 불가능하지만, 삭제 후 새로운 값을 추가하는 방법을 통해 수정할 수 있다.\n\n\n집합에서 원소 삭제 후 추가\n집합은 원소의 위치나 값 자체를 수정할 수 없기 때문에, 원소를 삭제하고, 수정된 값을 새로 추가하는 방법을 사용한다.\n\n# 집합 생성\nmy_set = {1, 2, 3, 4, 5}\n\n# '3'을 수정하려면 삭제하고 새로 추가해야 한다.\nmy_set.remove(3)  # '3' 삭제\nmy_set.add(10)    # '10' 추가\n\nprint(my_set)\n\n{1, 2, 4, 5, 10}\n\n\n이 방법은 원소를 수정하는 효과를 낼 수 있지만, 원소의 값을 직접 변경하는 것은 아니다.\n\n\n\n집합 원소 추가\n파이썬에서 집합의 원소를 추가하는 방법은 두 가지가 있다. add() 메서드를 사용하거나, 여러 원소를 한 번에 추가할 때는 update() 메서드를 사용한다. 집합은 중복을 허용하지 않으며, 순서가 없다는 특징을 갖기 때문에, 추가한 원소가 이미 존재하는 원소라면 중복된 값은 추가되지 않는다.\n\n\n\n\n\n\n\n\n방법\n설명\n예제\n\n\n\n\nadd() 메서드\n단일 원소를 추가\nmy_set.add(4)\n\n\nupdate() 메서드\n여러 원소를 한 번에 추가\nmy_set.update([4, 5, 6])\n\n\n\n집합은 중복을 허용하지 않으며, 순서가 없기 때문에 원소를 추가할 때 기존 원소와 중복이 없다면 새로운 원소가 추가된다. add()는 단일 원소를 추가할 때 사용하고, update()는 여러 원소를 한 번에 추가할 때 사용한다.\n\nadd() 메서드 사용\nadd() 메서드는 집합에 단일 원소를 추가하는 방법이다. 이미 집합에 존재하는 원소를 추가하려 하면 아무 일도 일어나지 않는다.\n\n# 집합 생성\nmy_set = {1, 2, 3}\n\n# 원소 추가\nmy_set.add(4)\n\nprint(my_set)\n\n# 이미 존재하는 원소를 추가하려고 할 때\nmy_set.add(3)\n\nprint(my_set) # 3은 이미 존재하므로 변경되지 않음\n\n{1, 2, 3, 4}\n{1, 2, 3, 4}\n\n\n\n\nupdate() 메서드 사용\nupdate() 메서드는 집합에 여러 원소를 한 번에 추가할 때 사용된다. 리스트, 튜플, 문자열 등 반복 가능한(iterable) 자료형을 인자로 받을 수 있으며, 중복된 값은 자동으로 제거된다.\n\n# 집합 생성\nmy_set = {1, 2, 3}\n\n# 여러 원소를 추가\nmy_set.update([4, 5, 6])\n\nprint(my_set)\n\n# 리스트를 추가하려면\nmy_set.update([7, 8])\n\nprint(my_set)\n\n# 중복된 원소를 추가하려 해도 자동으로 제거\nmy_set.update([3, 5])\n\nprint(my_set)\n\n{1, 2, 3, 4, 5, 6}\n{1, 2, 3, 4, 5, 6, 7, 8}\n{1, 2, 3, 4, 5, 6, 7, 8}\n\n\nupdate() 메서드는 리스트뿐만 아니라 튜플, 문자열, 다른 집합 등을 받을 수 있다.\n\n# 튜플 추가\nmy_set.update((9, 10))\n\nprint(my_set)\n\n# 문자열 추가\nmy_set.update(\"hello\")\n\nprint(my_set)\n\n{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 'e', 'h', 'o', 'l'}\n\n\n\n\n집합 원소 추가 시 유의점\n집합은 중복된 원소를 허용하지 않으므로, 추가된 원소가 기존에 이미 존재하면 변화가 없다. 집합에 추가할 수 있는 원소는 변경할 수 없는 자료형(불변형)이어야 한다. 예를 들어, 리스트나 딕셔너리는 집합의 원소로 사용할 수 없다.\n\n# 집합에 리스트를 원소로 추가하려면 오류가 발생\nmy_set.add([11, 12])  # TypeError: unhashable type: 'list'\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[142], line 2\n      1 # 집합에 리스트를 원소로 추가하려면 오류가 발생\n----&gt; 2 my_set.add([11, 12])  # TypeError: unhashable type: 'list'\n\nTypeError: unhashable type: 'list'\n\n\n\n\n# 집합에 딕셔너리를 원소로 추가하려면 오류가 발생\nmy_set.add({\"key\": \"value\"})  # TypeError: unhashable type: 'dict'\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[143], line 2\n      1 # 집합에 딕셔너리를 원소로 추가하려면 오류가 발생\n----&gt; 2 my_set.add({\"key\": \"value\"})  # TypeError: unhashable type: 'dict'\n\nTypeError: unhashable type: 'dict'\n\n\n\n\n\n\n집합 원소 삭제\n파이썬에서 집합의 원소를 삭제하는 방법은 여러 가지가 있다. 집합은 중복된 원소를 허용하지 않으며, 순서가 없다는 특징을 갖고 있기 때문에 원소를 삭제할 때 값을 기준으로 삭제가 이루어진다. 삭제 방법으로는 remove(), discard(), pop(), clear() 메서드가 있다.\n\n\n\n\n\n\n\n\n\n메서드\n설명\n원소가 없을 경우 처리\n반환값\n\n\n\n\nremove()\n특정 원소를 삭제\n오류 발생 (KeyError)\n없음\n\n\ndiscard()\n특정 원소를 삭제\n오류 발생하지 않음\n없음\n\n\npop()\n임의의 원소를 삭제하고 해당 원소를 반환\n오류 발생 (KeyError)\n삭제된 원소 반환\n\n\nclear()\n집합의 모든 원소를 삭제\n없음\n없음\n\n\n\n\nremove() 메서드\nremove() 메서드는 집합에서 특정 원소를 삭제하는 데 사용된다. 만약 삭제하려는 원소가 집합에 존재하지 않으면 KeyError가 발생한다.\n\n# 집합 생성\nmy_set = {1, 2, 3, 4, 5}\n\n# 원소 삭제\nmy_set.remove(3)\n\nprint(my_set)\n\n# 원소가 존재하지 않으면 오류 발생\nmy_set.remove(10)  # KeyError: 10\n\n{1, 2, 4, 5}\n\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[144], line 10\n      7 print(my_set)\n      9 # 원소가 존재하지 않으면 오류 발생\n---&gt; 10 my_set.remove(10)  # KeyError: 10\n\nKeyError: 10\n\n\n\n\n\n\ndiscard() 메서드\ndiscard() 메서드는 집합에서 특정 원소를 삭제하는 데 사용된다. remove()와의 차이점은 원소가 집합에 존재하지 않으면 오류를 발생시키지 않고 그냥 넘어간다는 점이다.\n\n# 집합 생성\nmy_set = {1, 2, 3, 4, 5}\n\n# 원소 삭제\nmy_set.discard(3)\n\nprint(my_set)\n\n# 원소가 존재하지 않으면 오류를 발생시키지 않음\nmy_set.discard(10)  # 10은 집합에 없지만 오류는 발생하지 않음\n\nprint(my_set) # 집합에는 여전히 변화 없음\n\n{1, 2, 4, 5}\n{1, 2, 4, 5}\n\n\n\n\npop() 메서드\npop() 메서드는 집합에서 임의의 원소를 하나 삭제하고 그 값을 반환한다. 집합은 순서가 없으므로, pop() 메서드는 삭제된 원소의 값을 예측할 수 없다. 또한, 집합이 비어있으면 KeyError가 발생한다.\n\n# 집합 생성\nmy_set = {1, 2, 3, 4, 5}\n\n# 임의의 원소 삭제\nremoved_element = my_set.pop()\n\nprint(f\"삭제된 원소: {removed_element}\")\nprint(my_set)\n\n# 집합이 비어있을 경우 오류 발생\nempty_set = set()\nempty_set.pop()  # KeyError: 'pop from an empty set'\n\n삭제된 원소: 1\n{2, 3, 4, 5}\n\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[146], line 12\n     10 # 집합이 비어있을 경우 오류 발생\n     11 empty_set = set()\n---&gt; 12 empty_set.pop()  # KeyError: 'pop from an empty set'\n\nKeyError: 'pop from an empty set'\n\n\n\n\n\nclear() 메서드\nclear() 메서드는 집합의 모든 원소를 삭제하는 데 사용된다. 이 메서드를 호출하면 집합이 빈 집합으로 변한다.\n\n# 집합 생성\nmy_set = {1, 2, 3, 4, 5}\n\n# 모든 원소 삭제\nmy_set.clear()\n\nprint(my_set) # 빈 집합으로 변경됨\n\nset()\n\n\n\n\n집합 원소 삭제 시 유의점\n\nremove()와 discard()는 집합에 존재하는 특정 원소를 삭제하는 데 사용되며, 차이점은 remove()는 원소가 없으면 오류를 발생시키고, discard()는 오류 없이 넘어간다는 점이다.\npop()은 집합에서 임의의 원소를 삭제하는 메서드이며, 순서가 없기 때문에 삭제된 원소는 예측할 수 없다.\nclear()는 집합의 모든 원소를 삭제하며, 빈 집합을 만든다.\n\n집합의 원소를 삭제하는 데 사용되는 메서드는 목적에 따라 적절히 선택하여 사용할 수 있다.",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>자료형</span>"
    ]
  },
  {
    "objectID": "30datatype.html#footnotes",
    "href": "30datatype.html#footnotes",
    "title": "자료형",
    "section": "",
    "text": "for문에서 (index, element) 쌍으로 순회하는데 사용되는 함수\nenumerate(iterable, start=0) \n↩︎\n반복 가능한 모든 객체에 대해 주어진 함수를 수행\nmap(function, iterable)\n↩︎",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>자료형</span>"
    ]
  },
  {
    "objectID": "40controlflow.html",
    "href": "40controlflow.html",
    "title": "제어문",
    "section": "",
    "text": "조건문\n파이썬에서 제어문(Control Statements)은 프로그램의 흐름을 제어하는 명령어로, 조건문(Conditional Statements)과 반복문(Loop Statements)이 있다. 이를 통해 프로그램이 특정 조건을 만족할 때 실행되거나, 특정 동작을 반복하도록 만들 수 있다.\n제어문을 적절히 활용하면 프로그램의 흐름을 효과적으로 제어할 수 있다.\n조건문은 주어진 조건에 따라 특정 코드블록을 실행할 수 있도록 제어한다.",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>제어문</span>"
    ]
  },
  {
    "objectID": "40controlflow.html#조건문",
    "href": "40controlflow.html#조건문",
    "title": "제어문",
    "section": "",
    "text": "if문\nif문은 주어진 조건이 참(True)일 때 특정 코드 블록을 실행하는 조건문이다. 프로그램의 흐름을 제어할 때 필수적으로 사용되며, if, elif, else 키워드를 활용하여 다양한 조건을 설정할 수 있다.\n\n\n\n기능\n코드 예시\n\n\n\n\n기본 if 문\nif x &gt; 5: print(\"x는 5보다 크다\")\n\n\nif-else\nif x &gt; 5: ... else: ...\n\n\nif-elif-else\nif x &gt; 10: ... elif x &gt; 5: ... else: ...\n\n\n중첩 if\nif x &gt; 10: if x &gt; 20: ...\n\n\n논리 연산자\nif x &gt; 5 and x &lt; 10: ...\n\n\n비교 연산자 연속 사용\nif 5 &lt; x &lt; 10: ...\n\n\nin, not in\nif \"apple\" in fruits: ...\n\n\n삼항 연산자\nresult = \"참\" if x &gt; 5 else \"거짓\"\n\n\nis와 == 비교\nif a is b: ...\n\n\n\nif문을 활용하면 프로그램이 입력값에 따라 다양한 동작을 수행할 수 있다. 논리 연산자, 비교 연산자, in 등의 기능과 조합하면 더욱 유용하게 사용할 수 있다.\n\n기본 if 문\nif문은 조건식이 True일 때 실행된다.\n\nx = 10\n\nif x &gt; 5:\n    print(\"x는 5보다 크다\")  # 조건이 참이므로 실행됨\n\nx는 5보다 크다\n\n\n\nif 다음에 조건식을 작성하며, 조건이 True일 경우 : 뒤의 코드 블록이 실행된다.\nif문에 속하는 코드 블록은 반드시 들여쓰기해야 한다.\n\n\n\nif-else 문\nif문 뒤에 else를 추가하면 조건이 거짓(False)일 때 실행할 코드를 지정할 수 있다.\n\nx = 3\n\nif x &gt; 5:\n    print(\"x는 5보다 크다\")\nelse:\n    print(\"x는 5 이하이다\")  # 조건이 False이므로 실행됨\n\nx는 5 이하이다\n\n\n\nif의 조건이 False이면 else 블록의 코드가 실행된다.\n\n\n\nif-elif-else 문\n여러 개의 조건을 검사할 때 elif(else if)를 사용하여 다중 조건문을 만들 수 있다.\n\nx = 7\n\nif x &gt; 10:\n    print(\"x는 10보다 크다\")\nelif x &gt; 5:\n    print(\"x는 5보다 크다\")  # 이 조건이 True이므로 실행됨\nelse:\n    print(\"x는 5 이하이다\")\n\nx는 5보다 크다\n\n\n\nif 조건이 False이면 elif의 조건을 검사한다.\n첫 번째로 True인 elif 블록이 실행되며, 이후의 elif는 검사하지 않는다.\n모든 조건이 False이면 else 블록이 실행된다.\n\n\n\n중첩 if문\nif문 내부에 또 다른 if문을 포함하여 조건을 중첩할 수 있다.\n\nx = 15\n\nif x &gt; 10:\n    print(\"x는 10보다 크다\")\n    if x &gt; 20:\n        print(\"x는 20보다 크다\")\n    else:\n        print(\"x는 10보다 크지만 20 이하는 아니다\")\n\nx는 10보다 크다\nx는 10보다 크지만 20 이하는 아니다\n\n\n\nif문 안에 또 다른 if문을 넣을 수 있으며, 들여쓰기 수준에 따라 실행이 결정된다.\n\n\n\n조건 표현식 (삼항 연산자)\nif-else를 한 줄로 표현할 수도 있다.\n\nx = 10\nresult = \"x는 5보다 크다\" if x &gt; 5 else \"x는 5 이하이다\"\n\nprint(result)  # 출력: x는 5보다 크다\n\nx는 5보다 크다\n\n\n\n조건식 if 참일 때 값 else 거짓일 때 값 형태로 작성된다.\n\n\n\n여러 조건을 한 번에 검사하기\n\n논리 연산자 사용 (and, or, not)\n조건문에서 and, or, not을 사용하여 여러 개의 조건을 조합할 수 있다.\n\nx = 8\n\n# and 연산자: 두 조건이 모두 참이어야 실행\nif x &gt; 5 and x &lt; 10:\n    print(\"x는 5보다 크고 10보다 작다\")\n\n# or 연산자: 둘 중 하나만 참이면 실행\nif x &lt; 5 or x &gt; 7:\n    print(\"x는 5보다 작거나 7보다 크다\")\n\n# not 연산자: 조건을 반대로 변경\nif not x == 5:\n    print(\"x는 5가 아니다\")\n\nx는 5보다 크고 10보다 작다\nx는 5보다 작거나 7보다 크다\nx는 5가 아니다\n\n\n\n\n비교 연산자 연속 사용\n파이썬에서는 비교 연산자를 연속해서 사용할 수 있다.\n\nx = 7\n\nif 5 &lt; x &lt; 10:  # 5 &lt; x and x &lt; 10 과 동일\n    print(\"x는 5보다 크고 10보다 작다\")\n\nx는 5보다 크고 10보다 작다\n\n\n\n\n\nif문과 in, not in 사용\n리스트, 튜플, 문자열, 딕셔너리 등에서 특정 요소가 존재하는지 확인할 때 in과 not in을 사용할 수 있다.\n\nfruits = [\"apple\", \"banana\", \"cherry\"]\n\nif \"banana\" in fruits:\n    print(\"바나나가 리스트에 포함되어 있다.\")\n\nif \"grape\" not in fruits:\n    print(\"포도는 리스트에 포함되어 있지 않다.\")\n\n바나나가 리스트에 포함되어 있다.\n포도는 리스트에 포함되어 있지 않다.\n\n\n\n\nis와 ==의 차이\n\n== 연산자는 값이 같은지 비교한다.\nis 연산자는 객체(메모리 주소)가 같은지 비교한다.\n\n\na = [1, 2, 3]\nb = [1, 2, 3]\nc = a\n\nprint(a == b)  # True (값이 같음)\nprint(a is b)  # False (다른 객체)\nprint(a is c)  # True (같은 객체)\n\nTrue\nFalse\nTrue\n\n\n\n\n실전 예제\n\n사용자 입력값 조건 처리\nage = int(input(\"나이를 입력하세요: \"))\n\nif age &gt;= 18:\n    print(\"성인입니다.\")\nelif age &gt;= 13:\n    print(\"청소년입니다.\")\nelse:\n    print(\"어린이입니다.\")\n\n\n숫자 판별 (양수, 음수, 0)\nnum = int(input(\"숫자를 입력하세요: \"))\n\nif num &gt; 0:\n    print(\"양수입니다.\")\nelif num &lt; 0:\n    print(\"음수입니다.\")\nelse:\n    print(\"0입니다.\")",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>제어문</span>"
    ]
  },
  {
    "objectID": "40controlflow.html#반복문",
    "href": "40controlflow.html#반복문",
    "title": "제어문",
    "section": "반복문",
    "text": "반복문\n반복문(iteration)은 제어문중 하나로, 프로그램 소스 코드내에서 특정한 부분의 코드가 반복적으로 수행될 수 있도록 하는 구문이다. 대표적인 구문으로 for문과 while문이 있다.\n\nfor문\nfor 문은 반복 가능한(iterable) 객체(리스트, 튜플, 문자열, 딕셔너리, range 등)의 요소를 순차적으로 순회하면서 실행되는 반복문이다.\n\n\n\n사용 방식\n예제\n\n\n\n\n리스트 순회\nfor x in [1, 2, 3]: print(x)\n\n\nrange() 사용\nfor i in range(5): print(i)\n\n\n문자열 순회\nfor char in \"hello\": print(char)\n\n\n딕셔너리 순회\nfor key, value in dict.items(): print(key, value)\n\n\nenumerate() 사용\nfor i, v in enumerate(lst): print(i, v)\n\n\nzip() 사용\nfor x, y in zip(lst1, lst2): print(x, y)\n\n\n중첩 반복문\nfor i in range(3): for j in range(2): print(i, j)\n\n\n\nfor 문을 활용하면 데이터를 효율적으로 반복 처리할 수 있다.\n\n기본 for 문\n리스트의 각 요소를 하나씩 가져와서 변수에 할당한 후, 코드 블록을 실행한다.\n\nfruits = [\"apple\", \"banana\", \"cherry\"]\n\nfor fruit in fruits:\n    print(fruit)\n\napple\nbanana\ncherry\n\n\n\nfor 변수 in iterable: 형식으로 작성된다.\niterable의 각 요소가 변수에 차례대로 할당되면서 반복 실행된다.\n\n\n\nrange() 함수와 함께 사용\nrange() 함수는 일정 범위의 숫자를 생성하며, for 문과 함께 자주 사용된다.\n\nfor i in range(5):  # 0부터 4까지 반복\n    print(i)\n\n0\n1\n2\n3\n4\n\n\n\nrange(start, end, step) 사용\n\nrange(시작, 끝, 증가값) 형식으로 사용하면 특정 범위에서 일정 간격으로 값을 생성할 수 있다.\n\n\nfor i in range(1, 10, 2):  # 1부터 9까지 2씩 증가\n    print(i)\n\n1\n3\n5\n7\n9\n\n\n\n\n문자열 순회\n문자열도 for 문을 사용하여 한 글자씩 순회할 수 있다.\n\nword = \"Python\"\n\nfor char in word:\n    print(char)\n\nP\ny\nt\nh\no\nn\n\n\n\n\n\n튜플 순회\n튜플도 for 문을 사용하여 요소를 순회할 수 있다.\n\nnumbers = (10, 20, 30)\n\nfor num in numbers:\n    print(num)\n\n10\n20\n30\n\n\n\n\n딕셔너리 순회\n딕셔너리는 기본적으로 키를 순회하며, keys(), values(), items() 메서드를 활용하여 다양한 방식으로 순회할 수 있다.\n\n키(key) 순회\n\nperson = {\"name\": \"Alice\", \"age\": 25, \"city\": \"Seoul\"}\n\nfor key in person:\n    print(key)  # 키만 출력\n\nname\nage\ncity\n\n\n\n값(value) 순회\n\nfor value in person.values():\n    print(value)  # 값만 출력\n\nAlice\n25\nSeoul\n\n\n\n\n\n키-값(key-value) 쌍 순회\n\nfor key, value in person.items():\n    print(f\"{key}: {value}\")\n\nname: Alice\nage: 25\ncity: Seoul\n\n\n\n\n\nenumerate()를 사용하여 인덱스와 함께 순회\nenumerate() 함수는 반복 가능한 객체를 순회하면서 인덱스와 요소를 함께 제공한다.\n\nfruits = [\"apple\", \"banana\", \"cherry\"]\n\nfor index, fruit in enumerate(fruits):\n    print(f\"{index}: {fruit}\")\n\n0: apple\n1: banana\n2: cherry\n\n\n\n\nzip()을 사용하여 여러 리스트 동시에 순회\nzip() 함수는 여러 리스트를 묶어서 동시에 순회할 때 사용한다.\n\nnames = [\"Alice\", \"Bob\", \"Charlie\"]\nages = [25, 30, 35]\n\nfor name, age in zip(names, ages):\n    print(f\"{name}의 나이는 {age}살입니다.\")\n\nAlice의 나이는 25살입니다.\nBob의 나이는 30살입니다.\nCharlie의 나이는 35살입니다.\n\n\n\n\n중첩 for 문\nfor 문 안에 또 다른 for 문을 넣어서 이중 반복문을 만들 수 있다.\n\nfor i in range(3):  # 0, 1, 2\n    for j in range(2):  # 0, 1\n        print(f\"i={i}, j={j}\")\n\ni=0, j=0\ni=0, j=1\ni=1, j=0\ni=1, j=1\ni=2, j=0\ni=2, j=1\n\n\n\n\n반복문 제어문 (break, continue, pass)\n\nbreak 문\nbreak 문은 반복문을 즉시 종료한다.\n\nfor i in range(5):\n    if i == 3:\n        break  # 3이 되면 반복 종료\n    print(i)\n\n0\n1\n2\n\n\n\n\ncontinue 문\ncontinue 문은 현재 반복을 건너뛰고 다음 반복을 수행한다.\n\nfor i in range(5):\n    if i == 2:\n        continue  # 2일 때 건너뛰기\n    print(i)\n\n0\n1\n3\n4\n\n\n\n\npass 문\npass 문은 실행할 코드가 없을 때 사용하며, 문법적으로 오류가 발생하지 않도록 한다.\n\nfor i in range(5):\n    if i == 2:\n        pass  # 아무 동작도 하지 않음\n    else:\n        print(i)\n\n0\n1\n3\n4\n\n\n\n\n\n반복문과 else\n반복문에 else를 추가하면, 반복문이 정상적으로 끝났을 때 실행된다. (break로 종료되면 실행되지 않음)\n\nfor i in range(5):\n    print(i)\nelse:\n    print(\"반복이 끝났습니다.\")  # 정상 종료되면 실행\n\n0\n1\n2\n3\n4\n반복이 끝났습니다.\n\n\n\nfor i in range(5):\n    if i == 3:\n        break  # 반복 중단\n    print(i)\nelse:\n    print(\"반복이 끝났습니다.\")  # 실행되지 않음\n\n0\n1\n2\n\n\n\n\n리스트 내포 (List Comprehension)\nfor 문을 사용하여 리스트를 간결하게 생성할 수 있다.\n\n# 기존 방식\nsquares = []\nfor i in range(1, 6):\n    squares.append(i * i)\n\nprint(squares)\n\n[1, 4, 9, 16, 25]\n\n\n\n# 리스트 내포 방식\nsquares = [i * i for i in range(1, 6)]\nprint(squares)  \n\n[1, 4, 9, 16, 25]\n\n\n\n\n\nwhile문\nwhile 문은 조건이 참(True)인 동안 반복 실행하는 루프이다. 반복 횟수가 정해지지 않았거나, 특정 조건이 만족될 때까지 실행해야 하는 경우에 유용하다.\n\n\n\n개념\n설명\n예제\n\n\n\n\n기본 구조\n조건이 참인 동안 실행\nwhile 조건:\n\n\n무한 루프\n계속 반복\nwhile True:\n\n\nbreak\n반복문 강제 종료\nif 조건: break\n\n\ncontinue\n현재 반복 건너뛰기\nif 조건: continue\n\n\nelse\nwhile 정상 종료 시 실행\nwhile 조건: ... else: ...\n\n\n\nwhile 문은 특정 조건이 만족될 때까지 실행되므로, 종료 조건을 명확히 설정하는 것이 중요하다.\n\n기본 구조\nwhile 조건:\n    실행할 코드\n\n조건이 참(True)이면 블록 내부의 코드가 실행된다.\n실행이 끝나면 다시 조건을 검사하며, 조건이 거짓(False)이 될 때까지 반복한다.\n\n\ncount = 0\n\nwhile count &lt; 5:  # count가 5보다 작을 때까지 반복\n    print(\"반복 중:\", count)\n    count += 1  # count 값을 증가시켜 반복 조건을 변경\n\n반복 중: 0\n반복 중: 1\n반복 중: 2\n반복 중: 3\n반복 중: 4\n\n\n\ncount가 5가 되면 count &lt; 5 조건이 거짓(False)이므로 반복문이 종료된다.\n\n\n\n무한 루프 (while True)\nwhile True를 사용하면 무한 루프가 생성된다. 특정 조건을 만족하면 break 문을 사용하여 종료해야 한다.\nwhile True:\n    answer = input(\"종료하려면 'exit' 입력: \")\n    if answer == \"exit\":\n        print(\"반복문 종료\")\n        break  # 루프 종료\n\n사용자가 \"exit\"을 입력하면 break가 실행되어 루프가 종료된다.\n\n\n\nbreak 문을 이용한 반복문 종료\nbreak 문은 조건을 만족하면 반복문을 즉시 종료한다.\n\nnum = 1\n\nwhile num &lt;= 10:\n    print(num)\n    if num == 5:  # num이 5가 되면 루프 종료\n        break\n    num += 1\n\n1\n2\n3\n4\n5\n\n\n\n\ncontinue 문을 이용한 반복 건너뛰기\ncontinue 문은 특정 조건을 만나면 현재 반복을 건너뛰고 다음 반복으로 이동한다.\n\nnum = 0\n\nwhile num &lt; 5:\n    num += 1\n    if num == 3:  # num이 3이면 건너뛰기\n        continue\n    print(num)\n\n1\n2\n4\n5\n\n\n\nnum == 3일 때 continue가 실행되므로 print(num)이 실행되지 않는다.\n\n\n\nelse 블록 사용\nwhile 문이 정상적으로 종료되었을 때(즉, break 없이 종료) 실행된다.\n\nnum = 1\n\nwhile num &lt; 5:\n    print(num)\n    num += 1\nelse:\n    print(\"반복이 정상적으로 종료됨\")\n\n1\n2\n3\n4\n반복이 정상적으로 종료됨\n\n\n\nnum이 5가 되어 while 조건이 False가 되면 else 블록이 실행된다.\n만약 break로 while을 중단하면 else 블록은 실행되지 않는다.\n\n\nnum = 1\n\nwhile num &lt; 5:\n    print(num)\n    if num == 3:\n        break  # 루프 강제 종료\n    num += 1\nelse:\n    print(\"반복이 정상적으로 종료됨\")  # 실행되지 않음\n\n1\n2\n3\n\n\n\nnum == 3일 때 break가 실행되었으므로 else 블록은 실행되지 않는다.\n\n\n\nwhile 문 활용 예제\n\n사용자 입력을 받을 때까지 반복\npassword = \"python123\"\n\nwhile True:\n    user_input = input(\"비밀번호를 입력하세요: \")\n    if user_input == password:\n        print(\"비밀번호가 올바릅니다!\")\n        break\n    print(\"비밀번호가 틀렸습니다. 다시 입력하세요.\")\n\n올바른 비밀번호를 입력할 때까지 반복한다.\n\n\n\n숫자 맞히기 게임\nimport random\n\ntarget = random.randint(1, 10)  # 1부터 10 사이의 난수 생성\n\nwhile True:\n    guess = int(input(\"숫자를 맞혀보세요 (1~10): \"))\n    if guess == target:\n        print(\"정답입니다!\")\n        break\n    elif guess &lt; target:\n        print(\"더 큰 숫자를 입력하세요.\")\n    else:\n        print(\"더 작은 숫자를 입력하세요.\")\n\n사용자가 정답을 맞힐 때까지 반복된다.",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>제어문</span>"
    ]
  },
  {
    "objectID": "40controlflow.html#기타-제어문",
    "href": "40controlflow.html#기타-제어문",
    "title": "제어문",
    "section": "기타 제어문",
    "text": "기타 제어문\n파이썬에는 if, for, while 같은 기본적인 제어문 외에도 반복문을 제어하거나 흐름을 변경하는 다양한 제어문이 있다. 대표적인 제어문은 다음과 같다.\n\n\n\n제어문\n설명\n예제\n\n\n\n\nbreak\n반복문 강제 종료\nif 조건: break\n\n\ncontinue\n현재 반복 건너뛰기\nif 조건: continue\n\n\nelse (반복문)\n정상 종료 시 실행\nfor ... else:\n\n\npass\n실행할 코드가 없을 때 사용\nif 조건: pass\n\n\nassert\n조건 검증 및 예외 발생\nassert x &gt; 0, \"오류 메시지\"\n\n\nwith\n리소스 자동 관리\nwith open(\"파일\") as f:\n\n\n\n이러한 제어문을 활용하면 코드를 더 효율적으로 관리하고, 오류를 방지할 수 있다.\n\nbreak 문: 반복문 강제 종료\nbreak 문은 현재 실행 중인 반복문(for, while)을 즉시 종료한다.\n\nfor i in range(1, 6):\n    if i == 3:\n        break  # i가 3일 때 반복문 종료\n    print(i)\n\n1\n2\n\n\n\ni == 3일 때 break가 실행되어 반복문이 종료된다.\n\n\nwhile 문에서 break 사용\n\ncount = 0\n\nwhile count &lt; 10:\n    print(count)\n    if count == 5:\n        break  # count가 5일 때 루프 종료\n    count += 1\n\n0\n1\n2\n3\n4\n5\n\n\n\n\n\ncontinue 문: 현재 반복 건너뛰기\ncontinue 문은 현재 반복을 건너뛰고 다음 반복으로 이동한다.\n\nfor i in range(1, 6):\n    if i == 3:\n        continue  # i가 3일 때 아래 코드를 실행하지 않고 다음 반복으로 이동\n    print(i)\n\n1\n2\n4\n5\n\n\n\ni == 3일 때 print(i)가 실행되지 않고 다음 반복으로 넘어간다.\n\n\nwhile 문에서 continue 사용\n\ncount = 0\n\nwhile count &lt; 5:\n    count += 1\n    if count == 3:\n        continue  # count가 3일 때 print() 실행을 건너뜀\n    print(count)\n\n1\n2\n4\n5\n\n\n\ncount == 3일 때 print(count)가 실행되지 않는다.\n\n\n\n\nelse 문과 반복문\nfor 또는 while 반복문에서 정상적으로 종료되었을 때(break 없이 종료될 때) else 블록이 실행된다.\n\nfor 문에서 else 사용\n\nfor i in range(1, 6):\n    print(i)\nelse:\n    print(\"반복문이 정상적으로 종료됨\")\n\n1\n2\n3\n4\n5\n반복문이 정상적으로 종료됨\n\n\n\nbreak가 발생하지 않았기 때문에 else 블록이 실행된다.\n\n\nfor i in range(1, 6):\n    print(i)\n    if i == 3:\n        break  # 반복문 강제 종료\nelse:\n    print(\"반복문이 정상적으로 종료됨\")  # 실행되지 않음\n\n1\n2\n3\n\n\n\nbreak로 종료되었기 때문에 else 블록이 실행되지 않는다.\n\n\n\nwhile 문에서 else 사용\n\ncount = 0\n\nwhile count &lt; 5:\n    print(count)\n    count += 1\nelse:\n    print(\"반복문이 정상적으로 종료됨\")\n\n0\n1\n2\n3\n4\n반복문이 정상적으로 종료됨\n\n\n\nwhile 조건이 False가 되어 정상 종료되었으므로 else가 실행된다.\n\n\n\n\npass 문: 코드 실행을 미룸\npass 문은 아무 동작도 하지 않는 문장으로, 문법적으로 코드가 필요하지만 실행할 내용이 없을 때 사용한다.\n\nfor i in range(5):\n    if i == 2:\n        pass  # 실행할 코드가 없지만 문법적으로 필요할 때 사용\n    print(i)\n\n0\n1\n2\n3\n4\n\n\n\npass 문이 있어도 프로그램 흐름에는 영향을 주지 않는다.\n\n\nfor i in range(5):\n    if i == 2:\n        continue  # 실행할 코드가 없지만 문법적으로 필요할 때 사용\n    print(i)\n\n0\n1\n3\n4\n\n\n\ncontinue문을 사용하게 되면 i == 2인 경우 실행하지 않고 다음 반복을 진행하게 된다.\n\n\n예제: 함수 또는 클래스의 구조만 미리 작성\n\ndef my_function():\n    pass  # 함수 구현은 나중에 작성\n\nclass MyClass:\n    pass  # 클래스 구현은 나중에 작성\n\n\npass를 사용하면 추후 구현할 내용을 미리 작성해둘 수 있다.\n\n\n\n\nassert 문: 조건 검증\nassert 문은 조건이 참(True)인지 확인하고, 거짓(False)이면 AssertionError 예외를 발생시킨다. 주로 디버깅이나 테스트용으로 사용된다.\n\nx = 10\nassert x &gt; 0  # 정상 실행됨\n\ny = -5\nassert y &gt; 0, \"y는 0보다 커야 합니다.\"  # AssertionError 발생\n\n\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nCell In[43], line 5\n      2 assert x &gt; 0  # 정상 실행됨\n      4 y = -5\n----&gt; 5 assert y &gt; 0, \"y는 0보다 커야 합니다.\"  # AssertionError 발생\n\nAssertionError: y는 0보다 커야 합니다.\n\n\n\n\nassert는 개발 중 오류를 조기에 감지하는 용도로 활용된다.\n\n\nwith 문: 리소스 자동 관리\nwith 문은 파일, 네트워크 연결 등 리소스를 자동으로 관리한다. with 문을 사용하면 파일을 자동으로 닫을 수 있어 close()를 직접 호출할 필요가 없다.\nwith open(\"example.txt\", \"w\") as file:\n    file.write(\"Hello, World!\")\n\nwith 문이 끝나면 파일이 자동으로 닫힌다.\n\nfile = open(\"example.txt\", \"w\")\ntry:\n    file.write(\"Hello, World!\")\nfinally:\n    file.close()  # 직접 파일을 닫아야 함\n\nwith 문을 사용하면 try-finally 없이 리소스를 안전하게 정리할 수 있다.",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>제어문</span>"
    ]
  },
  {
    "objectID": "50function.html",
    "href": "50function.html",
    "title": "함수 및 모듈",
    "section": "",
    "text": "함수\n함수는(Function) 특정 작업을 수행하는 코드 블록으로, 코드의 재사용성을 높이고 가독성을 개선하는 역할을 한다. Python에서 함수는 def 키워드를 사용하여 정의한다.",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>함수 및 모듈</span>"
    ]
  },
  {
    "objectID": "50function.html#sec-function",
    "href": "50function.html#sec-function",
    "title": "함수 및 모듈",
    "section": "",
    "text": "Note 5.1: 함수 문법\n\n\n\ndef 함수이름(매개변수1, 매개변수2, ...):\n    \"\"\"문서화 문자열 (docstring)\"\"\"\n    실행할 코드\n    return 반환값  # (선택 사항)\n\ndef 키워드로 함수 정의를 시작한다.\n함수이름은 함수의 이름을 나타낸다.\n매개변수(parameter)는 함수에 전달될 값을 받는 변수이며, 생략 가능하다. d- ocstring(선택 사항)은 함수의 목적을 설명하는 문자열이다. return 문을 사용하여 값을 반환할 수 있다. 반환이 필요하지 않다면 생략 가능하다.\n\n\n\n\n함수 정의 및 호출\n함수 정의 및 호출 문법 Note 5.1에 따라 수행한다.\n\ndef add(a, b):\n    return a + b\n\nresult = add(3, 5)\nprint(result) \n\n8\n\n\n\ndef 키워드로 함수를 정의한다.\nadd(a, b): 두 개의 매개변수(a, b)를 받아 더한 값을 반환한다.\nreturn 문을 사용하여 결과를 반환한다.\nadd(3, 5)와 같이 호출하면 8이 출력된다.\n\n\n\n매개변수와 반환값\nPython에서 함수 매개변수는 함수를 호출할 때 전달되는 값(인자, argument)을 받는 변수이다. 매개변수를 설정하는 방식에 따라 다양한 형태로 사용할 수 있다.\n\n함수 매개변수 유형\n\n\n\n\n\n\n\n매개변수 유형\n설명\n예시\n\n\n\n\n기본 매개변수\n필수 인자를 받아야 하는 매개변수\ndef func(a, b):\n\n\n기본값 매개변수\n기본값을 설정할 수 있는 매개변수\ndef func(a, b=10):\n\n\n위치 인자\n순서에 따라 전달되는 인자\nfunc(1, 2)\n\n\n키워드 인자\n매개변수명=값 형식으로 전달되는 인자\nfunc(a=1, b=2)\n\n\n가변 위치 인자(*args)\n여러 개의 위치 인자를 튜플로 받을 수 있음\ndef func(*args):\n\n\n가변 키워드 인자(**kwargs)\n여러 개의 키워드 인자를 딕셔너리로 받을 수 있음\ndef func(**kwargs):\n\n\n위치 전용 매개변수\n/ 앞의 매개변수는 위치 인자로만 사용 가능\ndef func(a, b, /):\n\n\n키워드 전용 매개변수\n* 뒤의 매개변수는 키워드 인자로만 사용 가능\ndef func(*, a, b):\n\n\n\n이러한 매개변수 방식을 조합하여 다양한 형태의 함수를 정의할 수 있다.\n\n기본 매개변수\n함수를 정의할 때 매개변수를 지정하면, 해당 함수는 반드시 인자를 전달받아야 한다.\n\ndef greet(name):\n    print(f\"안녕하세요, {name}님!\")\n\ngreet(\"철수\") \n\ngreet()  # 오류 발생 (TypeError)\n\n안녕하세요, 철수님!\n\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[2], line 6\n      2     print(f\"안녕하세요, {name}님!\")\n      4 greet(\"철수\") \n----&gt; 6 greet()  # 오류 발생 (TypeError)\n\nTypeError: greet() missing 1 required positional argument: 'name'\n\n\n\n\ngreet(name) 함수는 name 매개변수를 필수로 요구한다.\ngreet() 호출 시 인자를 전달하지 않으면 TypeError가 발생한다.\n\n\n\n기본값 매개변수\n매개변수에 기본값(Default Parameters)을 설정하면, 호출 시 인자를 전달하지 않아도 된다.\n\ndef greet(name=\"손님\"):\n    print(f\"안녕하세요, {name}님!\")\n\ngreet(\"철수\")  \n\ngreet()  \n\n안녕하세요, 철수님!\n안녕하세요, 손님님!\n\n\n\nname=\"손님\"과 같이 기본값을 설정하면, 인자를 전달하지 않을 경우 기본값이 사용된다.\n\n\n\n위치 인자\n함수 호출 시 인자의 순서(Positional Arguments)에 따라 매개변수에 값이 할당된다.\n\ndef introduce(name, age):\n    print(f\"제 이름은 {name}이고, {age}살입니다.\")\n\nintroduce(\"영희\", 25) \n\nintroduce(25, \"영희\") \n\n제 이름은 영희이고, 25살입니다.\n제 이름은 25이고, 영희살입니다.\n\n\n\n인자의 순서가 중요하므로, 잘못된 순서로 전달하면 예상치 못한 결과가 나올 수 있다.\n\n\n\n키워드 인자\n함수 호출 시 매개변수명=값 형식(Keyword Arguments)으로 지정하여 순서를 무시할 수 있다.\n\nintroduce(age=30, name=\"민수\")  \n# 출력: 제 이름은 민수이고, 30살입니다.\n\n제 이름은 민수이고, 30살입니다.\n\n\n\n키워드 인자를 사용하면 가독성이 좋아지고, 인자 순서에 의존하지 않는다.\n\n\n\n가변 인자\n여러 개의 위치 인자(*args)를 튜플(tuple) 형태로 받을 수 있다.\n\ndef sum_numbers(*args):\n    total = sum(args)\n    print(f\"합계: {total}\")\n\nsum_numbers(1, 2, 3)  \n\nsum_numbers(10, 20, 30, 40, 50) \n\n합계: 6\n합계: 150\n\n\n\n*args는 여러 개의 인자를 받을 수 있으며, 튜플 형태로 저장된다.\n매개변수명이 args가 아니어도 되지만, 관례적으로 args를 사용한다.\n\n\n\n키워드 가변 인자\n여러 개의 키워드 인자(**kwargs)를 딕셔너리(dict) 형태로 받을 수 있다.\n\ndef print_info(**kwargs):\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nprint_info(name=\"철수\", age=25, city=\"서울\")\n\nname: 철수\nage: 25\ncity: 서울\n\n\n\n**kwargs는 키워드 인자를 받을 수 있으며, 딕셔너리 형태로 저장된다.\nkwargs.items()를 사용하여 키와 값을 출력할 수 있다.\n\n\n\n위치 전용 매개변수\nPython 3.8부터 / 기호를 사용하여 특정 매개변수를 위치 인자(Positional-Only Parameters)로만 받을 수 있다.\n\ndef multiply(a, b, /):\n    return a * b\n\nprint(multiply(3, 4))  \n# 출력: 12\n\nprint(multiply(a=3, b=4))  \n# 오류 발생 (TypeError)\n\n12\n\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[8], line 7\n      4 print(multiply(3, 4))  \n      5 # 출력: 12\n----&gt; 7 print(multiply(a=3, b=4))  \n      8 # 오류 발생 (TypeError)\n\nTypeError: multiply() got some positional-only arguments passed as keyword arguments: 'a, b'\n\n\n\n\n/ 이전의 매개변수들은 위치 인자로만 전달해야 하며, 키워드 인자로 사용할 수 없다.\n\n\n\n키워드 전용 매개변수\n* 기호 이후에 정의된 매개변수는 키워드 인자(Keyword-Only Parameters)로만 전달해야 한다.\n\ndef divide(*, x, y):\n    return x / y\n\nprint(divide(x=10, y=2))  \n# 출력: 5.0\n\nprint(divide(10, 2))  \n# 오류 발생 (TypeError)\n\n5.0\n\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[9], line 7\n      4 print(divide(x=10, y=2))  \n      5 # 출력: 5.0\n----&gt; 7 print(divide(10, 2))  \n      8 # 오류 발생 (TypeError)\n\nTypeError: divide() takes 0 positional arguments but 2 were given\n\n\n\n\n* 이후의 매개변수들은 반드시 키워드 인자로 전달해야 한다.\n\n\n\n위치 및 키워드 혼합\n/와 *를 함께 사용하여 위치 인자, 키워드 인자, 일반 매개변수를 조합할 수 있다.\n\ndef function(a, b, /, c, *, d):\n    print(a, b, c, d)\n\nfunction(1, 2, 3, d=4)  \n\nfunction(1, 2, c=3, d=4)  \n\nfunction(a=1, b=2, c=3, d=4)  \n# 오류 발생 (TypeError)\n\n1 2 3 4\n1 2 3 4\n\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[10], line 8\n      4 function(1, 2, 3, d=4)  \n      6 function(1, 2, c=3, d=4)  \n----&gt; 8 function(a=1, b=2, c=3, d=4)  \n      9 # 오류 발생 (TypeError)\n\nTypeError: function() got some positional-only arguments passed as keyword arguments: 'a, b'\n\n\n\n\na와 b는 위치 인자로만 사용 가능하다.\nc는 위치 또는 키워드 인자로 사용할 수 있다.\nd는 키워드 인자로만 사용할 수 있다.\n\n\n\n매개변수의 기본값과 가변 인자 조합\n기본값이 있는 매개변수와 *args, **kwargs를 함께 사용할 수 있다.\n\ndef example(a, b=10, *args, c=20, **kwargs):\n    print(f\"a: {a}, b: {b}, c: {c}\")\n    print(f\"args: {args}\")\n    print(f\"kwargs: {kwargs}\")\n\nexample(1, 2, 3, 4, c=5, d=6, e=7)\n\na: 1, b: 2, c: 5\nargs: (3, 4)\nkwargs: {'d': 6, 'e': 7}\n\n\n\nb와 c는 기본값을 가진다.\n*args는 위치 인자를 추가적으로 받을 수 있다.\n**kwargs는 키워드 인자를 추가적으로 받을 수 있다.\n\n\n\n\n익명 함수(lambda)\nPython에서 익명 함수(lambda)는 lambda 키워드를 사용하여 정의하는 한 줄짜리 함수이다. 일반적인 def 함수와 달리 이름이 없으며, 간단한 연산을 수행하는 데 사용된다.\n\nlambda 함수 기본 구조\nlambda 매개변수1, 매개변수2, ... : 표현식\n\nlambda 키워드로 함수를 정의한다.\n매개변수는 여러 개 입력받을 수 있다.\n: 이후에 오는 표현식(expression)이 반환값이 된다.\n여러 줄 코드를 작성할 수 없으며, 단일 표현식만 사용 가능하다.\n\n\n\nlambda 함수 예제\n\n# 일반적인 함수 정의\ndef add(a, b):\n    return a + b\n\n# lambda로 변환\nadd_lambda = lambda a, b: a + b\n\nprint(add(3, 5))        # 8\nprint(add_lambda(3, 5)) # 8\n\n8\n8\n\n\n\nlambda a, b: a + b는 add(a, b) 함수와 동일하게 동작한다.\n\n\n\nlambda 함수 활용 예시\n\n변수에 할당하여 사용\n\n\n\n\n\nmultiply = lambda x, y: x * y\nprint(multiply(4, 5))  # 20\n\n20\n\n\n\nlambda x, y: x * y는 두 숫자의 곱을 반환하는 함수이다.\n\n\nlambda와 map() 함수\n\n\n\n\n\nnumbers = [1, 2, 3, 4, 5]\nsquared = list(map(lambda x: x ** 2, numbers))\nprint(squared)  # [1, 4, 9, 16, 25]\n\n[1, 4, 9, 16, 25]\n\n\n\nmap(lambda x: x ** 2, numbers)는 리스트의 각 요소를 제곱한다.\n\n\nlambda와 filter() 함수\n\n\n\n\n\nnumbers = [1, 2, 3, 4, 5, 6]\neven_numbers = list(filter(lambda x: x % 2 == 0, numbers))\nprint(even_numbers)  # [2, 4, 6]\n\n[2, 4, 6]\n\n\n\nfilter(lambda x: x % 2 == 0, numbers)는 리스트에서 짝수만 필터링한다.\n\n\nlambda와 sorted() 함수\n\n\n\n\n\nstudents = [(\"철수\", 90), (\"영희\", 85), (\"민수\", 95)]\nsorted_students = sorted(students, key=lambda x: x[1], reverse=True)\nprint(sorted_students)\n\n[('민수', 95), ('철수', 90), ('영희', 85)]\n\n\n\nkey=lambda x: x[1]을 사용하여 두 번째 요소(점수)를 기준으로 정렬한다.\n\n\nlambda와 reduce() 함수\n\n\n\n\n\nfrom functools import reduce\n\nnumbers = [1, 2, 3, 4, 5]\nresult = reduce(lambda x, y: x * y, numbers)\nprint(result)  # 120 (1 * 2 * 3 * 4 * 5)\n\n120\n\n\n\nreduce(lambda x, y: x * y, numbers)는 리스트의 모든 요소를 곱한다.\n\n\n\nlambda와 일반 함수 비교\n\nlambda와 일반함수 비교\n\n\n비교 항목\nlambda 함수\n일반 함수 (def)\n\n\n\n\n정의 방식\nlambda 키워드 사용\ndef 키워드 사용\n\n\n이름\n없음(익명 함수)\n있음\n\n\n코드 길이\n한 줄로 작성\n여러 줄 작성 가능\n\n\n반환값\n자동으로 표현식의 결과 반환\nreturn을 사용해야 함\n\n\n사용 용도\n간단한 연산\n복잡한 로직 구현\n\n\n\n\n\nlambda 함수 사용이 적절한 경우\n\n한 줄로 간단한 연산을 수행할 때\nmap, filter, sorted 등의 함수와 함께 사용할 때\n굳이 별도 함수를 정의할 필요가 없을 때\n\n하지만, 복잡한 연산이나 여러 줄의 코드가 필요한 경우에는 def 함수가 더 적합하다.\n\n\n\n함수 반환값\nPython에서 함수는 return 키워드를 사용하여 값을 반환할 수 있다. 반환값을 이용하면 함수의 실행 결과를 저장하고, 다른 연산에 활용할 수 있다.\n\n함수 반환값\n\n\n\n\n\n\n개념\n설명\n\n\n\n\n기본 반환값\nreturn 값을 사용해 특정 값을 반환\n\n\n여러 개 반환\nreturn a, b를 사용하면 튜플로 반환\n\n\n조건부 반환\nif 문을 사용해 특정 조건에서만 반환 가능\n\n\n리스트/딕셔너리 반환\n여러 데이터를 리스트나 딕셔너리 형태로 반환 가능\n\n\nreturn 없음\nNone을 반환\n\n\n제너레이터 반환\nyield를 사용하면 값들을 순차적으로 생성\n\n\n\nPython의 return 문은 함수의 종료를 의미하며, 다양한 형태의 데이터를 반환할 수 있다.\n\n기본적인 반환값\n\ndef add(a, b):\n    return a + b\n\nresult = add(3, 5)\nprint(result)  # 8\n\n8\n\n\n\nreturn a + b: 두 숫자의 합을 반환한다.\n함수 호출 결과 result 변수에 저장된다.\n\n\n\n여러 개의 반환값\nPython에서는 여러 개의 값을 반환할 수 있으며, 이는 튜플(tuple)로 반환된다.\n\ndef get_info():\n    name = \"철수\"\n    age = 25\n    return name, age\n\ninfo = get_info()\nprint(info)       # ('철수', 25)\nprint(info[0])    # 철수\nprint(info[1])    # 25\n\n('철수', 25)\n철수\n25\n\n\n\nreturn name, age는 (name, age) 형태의 튜플을 반환한다.\n반환값을 여러 변수에 언패킹(unpacking)하여 받을 수도 있다.\n\n\nname, age = get_info()\nprint(name)  # 철수\nprint(age)   # 25\n\n철수\n25\n\n\n\n\nreturn이 없는 함수\n\nreturn 문이 없거나, return 키워드만 사용하면 None이 반환된다.\n\n\ndef greet():\n    print(\"안녕하세요!\")\n\nresult = greet()\nprint(result)  # None\n\n안녕하세요!\nNone\n\n\n\nprint() 함수는 값을 반환하지 않으므로 None이 저장된다.\n\n\n\n조건에 따른 반환값\n\n함수 내에서 특정 조건을 만족할 때만 값을 반환할 수 있다.\n\n\ndef check_even(n):\n    if n % 2 == 0:\n        return \"짝수\"\n    return \"홀수\"\n\nprint(check_even(4))  # 짝수\nprint(check_even(7))  # 홀수\n\n짝수\n홀수\n\n\n\nreturn \"짝수\" 실행 후 함수가 종료되므로, 이후 코드는 실행되지 않는다.\n\n\n\n리스트나 딕셔너리 반환\n먼저 리스트 반환이다.\n\ndef get_numbers():\n    return [1, 2, 3, 4, 5]\n\nprint(get_numbers())  # [1, 2, 3, 4, 5]\n\n[1, 2, 3, 4, 5]\n\n\n딕셔너리 반환이다.\n\ndef get_student():\n    return {\"name\": \"영희\", \"age\": 22}\n\nprint(get_student())  # {'name': '영희', 'age': 22}\n\n{'name': '영희', 'age': 22}\n\n\n\n\nreturn과 None 비교\n\nreturn과 None 비교\n\n\n상황\n반환값\n\n\n\n\nreturn 값 사용\n해당 값 반환\n\n\nreturn만 사용\nNone 반환\n\n\nreturn이 없는 함수\nNone 반환\n\n\n\n\ndef example():\n    return\n\nprint(example())  # None\n\nNone\n\n\n\n\nyield를 사용한 제너레이터 반환\n\nreturn 대신 yield를 사용하면 제너레이터(generator)를 반환한다.\n\n\ndef count_up(n):\n    for i in range(n):\n        yield i\n\ngen = count_up(3)\nprint(list(gen))  # [0, 1, 2]\n\n[0, 1, 2]\n\n\n\nyield는 값을 하나씩 생성하며, return과 달리 함수를 종료하지 않는다.\n\n\n\n\n재귀함수\nPython에서 재귀함수(recursive function)는 자기 자신을 호출하는 함수를 의미한다. 반복문 없이 특정 작업을 반복할 수 있으며, 분할 정복(Divide and Conquer) 같은 알고리즘에서 자주 사용된다.\n\n재귀함수의 기본 구조\ndef recursive():\n    print(\"재귀 호출\")\n    recursive()  # 자기 자신을 호출\n\nrecursive()  # 실행하면 무한 루프 발생\n\n함수 recursive() 내부에서 다시 recursive()를 호출한다.\n종료 조건이 없으면 무한 루프에 빠지므로, 반드시 종료 조건(base case)을 설정해야 한다.\n\n\n\n종료 조건을 포함한 재귀함수\n\ndef countdown(n):\n    if n &lt;= 0:  # 종료 조건\n        print(\"끝!\")\n        return\n    print(n)\n    countdown(n - 1)  # 자기 자신을 호출 (n 감소)\n\ncountdown(5)\n\n5\n4\n3\n2\n1\n끝!\n\n\n\nn이 0 이하가 되면 return하여 종료된다.\n종료 조건이 없다면 무한 재귀(infinite recursion)가 발생한다.\n\n\n\n재귀함수를 이용한 팩토리얼 계산\n\ndef factorial(n):\n    if n == 0 or n == 1:  # 종료 조건\n        return 1\n    return n * factorial(n - 1)  # 자기 자신을 호출\n\nprint(factorial(5))  # 120\n\n120\n\n\n\nfactorial(5) = 5 * 4 * 3 * 2 * 1 = 120\n종료 조건 if n == 0 or n == 1을 설정하여 재귀를 멈춘다.\n\n\n\n재귀함수를 이용한 피보나치 수열\n피보나치 수열:\n\\[F(n) = F(n-1) + F(n-2), \\quad F(0) = 0, \\quad F(1) = 1\\]\n\ndef fibonacci(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    return fibonacci(n - 1) + fibonacci(n - 2)  # 재귀 호출\n\nprint(fibonacci(6))  # 8\n\n8\n\n\n\nfibonacci(6) = fibonacci(5) + fibonacci(4) = 8\n종료 조건을 설정하지 않으면 무한 루프에 빠질 수 있다.\n\n\n\n재귀 깊이 제한\nPython은 기본적으로 재귀 호출 가능 횟수(깊이)를 제한(Recursion Limit)한다.\n기본 최대 깊이: 1,000번\nimport sys\nprint(sys.getrecursionlimit())  # 1000\n\n너무 깊이 재귀 호출하면 RecursionError 발생\n\n재귀 깊이 제한 변경 가능\nsys.setrecursionlimit(2000)  # 최대 재귀 깊이를 2000으로 설정\n\n하지만 너무 높은 값으로 설정하면 메모리 부족 오류 발생 가능\n\n\n\n재귀와 반복문의 비교\n\n재귀함수와 반복문 비교\n\n\n\n\n\n\n\n비교 항목\n재귀함수\n반복문\n\n\n\n\n사용 방식\n자기 자신을 호출\nfor 또는 while 사용\n\n\n메모리 사용\n호출마다 스택 메모리 사용\n상대적으로 적은 메모리 사용\n\n\n속도\n함수 호출 오버헤드로 느릴 수 있음\n일반적으로 빠름\n\n\n코드 가독성\n일부 문제에서 직관적\n대부분의 경우 더 명확\n\n\n종료 필요\n종료 조건(base case) 필수\nbreak나 조건문 사용\n\n\n\n\n\n꼬리 재귀\n꼬리 재귀(Tail Recursion): 함수의 마지막 동작이 자기 자신을 호출하는 형태, 일반적으로 반복문으로 변환 가능하며, 일부 언어에서는 최적화(Tail Call Optimization, TCO)를 지원하지만, Python은 지원하지 않는다.\n\ndef tail_recursive(n, result=1):\n    if n == 0:\n        return result\n    return tail_recursive(n - 1, n * result)  # 변수로 결과 유지\n\nprint(tail_recursive(5))  # 120\n\n120\n\n\n\n\n재귀함수 사용이 적절한 경우\n\n문제를 작은 부분으로 나눌 수 있는 경우\n\n이진 탐색(Binary Search)\n분할 정복 알고리즘 (Merge Sort, Quick Sort)\n트리(Tree) 또는 그래프(Graph) 탐색 (DFS)\n하노이 탑(Tower of Hanoi) 문제\n\n하지만, 일반적인 반복문으로 해결 가능한 경우에는 재귀보다 반복문을 사용하는 것이 성능상 유리하다.\n\n\n\n함수 범위\nPython에서 변수의 유효 범위(Scope)는 변수가 어디에서 접근할 수 있는지를 결정한다. Python은 LEGB 규칙(Local → Enclosing → Global → Built-in)에 따라 변수를 찾는다.\n\n\n\n\n\n\n\n\n\n범위\n선언 위치\n접근 가능 범위\n변경 가능 여부\n\n\n\n\n지역(Local)\n함수 내부\n함수 내부에서만 가능\nO\n\n\n비지역(Enclosing)\n중첩 함수의 바깥 함수\n내부 함수에서 접근 가능\nnonlocal 사용 시 가능\n\n\n전역(Global)\n함수 외부\n프로그램 전체에서 접근 가능\nglobal 사용 시 가능\n\n\n내장(Built-in)\nPython 기본 제공\n모든 코드에서 접근 가능\n변경 불가\n\n\n\nPython은 LEGB 규칙에 따라 변수를 찾으며, 함수 내부에서 전역 변수나 바깥 함수 변수를 변경하려면 global 또는 nonlocal 키워드를 사용해야 한다.\n\nLEGB 변수 탐색 규칙\n\nLEGB 변수 탐색 규칙\n\n\n\n\n\n\n\n범위\n설명\n예시\n\n\n\n\nLocal (지역 범위)\n현재 함수 내부에서 선언된 변수\n함수 내부의 변수\n\n\nEnclosing (비지역 범위)\n중첩 함수(내부 함수)에서 바깥쪽 함수의 변수\n내부 함수에서 바깥 함수 변수 참조\n\n\nGlobal (전역 범위)\n파일 전체에서 접근 가능한 변수\n함수 외부에서 선언된 변수\n\n\nBuilt-in (내장 범위)\nPython이 기본 제공하는 변수 및 함수\nlen(), print(), sum() 등\n\n\n\n\n\n지역(Local) 범위\n함수 내부에서 선언된 변수는 지역 변수이며, 함수 내부에서만 접근 가능하다.\n\ndef my_function():\n    x = 10  # 지역 변수\n    print(x)\n\nmy_function()\nprint(x)  # 오류 발생 (NameError)\n\n10\n\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[31], line 6\n      3     print(x)\n      5 my_function()\n----&gt; 6 print(x)  # 오류 발생 (NameError)\n\nNameError: name 'x' is not defined\n\n\n\n\nx는 my_function() 내부에서만 사용 가능하다.\n함수 바깥에서 x를 호출하면 오류(NameError)가 발생한다.\n\n\n\n전역(Global) 범위\n함수 바깥에서 선언된 변수는 전역 변수이며, 코드 전체에서 접근 가능하다.\n\ny = 20  # 전역 변수\n\ndef my_function():\n    print(y)  # 전역 변수 사용 가능\n\nmy_function()  # 20\n\n20\n\n\n\ny는 함수 내부에서도 접근할 수 있다.\n\n\n\nglobal 키워드 (전역 변수 변경)\n함수 내부에서 전역 변수를 변경하려면 global 키워드를 사용해야 한다.\n\nx = 10  # 전역 변수\n\ndef modify_global():\n    global x  # 전역 변수 변경 선언\n    x = 20    # 전역 변수 값 변경\n\nmodify_global()\nprint(x)  # 20\n\n20\n\n\n\nglobal x를 선언하면 함수 내부에서 전역 변수 x를 변경할 수 있다.\nglobal 없이 x = 20을 하면 지역 변수 x가 생성되므로, 전역 변수 x는 변경되지 않는다.\n\n\n\n비지역(Enclosing) 범위\n중첩 함수(nested function)에서 바깥쪽 함수의 변수를 내부 함수에서 참조할 수 있다.\n\ndef outer():\n    a = 5  # 비지역 변수\n\n    def inner():\n        print(a)  # 바깥 함수 변수 사용 가능\n\n    inner()\n\nouter()  # 5\n\n5\n\n\n\ninner() 함수는 outer() 함수의 변수 a를 사용할 수 있다.\n\n\n\nnonlocal 키워드 (비지역 변수 변경)\n내부 함수에서 바깥 함수의 변수를 변경하려면 nonlocal 키워드를 사용해야 한다.\n\ndef outer():\n    a = 5\n\n    def inner():\n        nonlocal a  # 바깥 함수 변수 변경 선언\n        a = 10      # 비지역 변수 변경\n\n    inner()\n    print(a)  # 10\n\nouter()\n\n10\n\n\n\nnonlocal a를 사용하면 a의 값을 변경할 수 있다.\nnonlocal이 없으면 a는 지역 변수로 새롭게 생성된다.\n\n\n\nLEGB 규칙 적용 예시\n\nx = 100  # 전역 변수\n\ndef outer():\n    x = 50  # 비지역 변수\n\n    def inner():\n        x = 10  # 지역 변수\n        print(x)  # 지역 변수 사용 (10)\n\n    inner()\n    print(x)  # 비지역 변수 사용 (50)\n\nouter()\nprint(x)  # 전역 변수 사용 (100)\n\n10\n50\n100\n\n\n\ninner() 내부에서는 가장 가까운 범위(지역 변수 x)를 먼저 찾는다.\ninner()가 실행된 후 outer()에서 x를 출력하면 비지역 변수(50)가 유지된다.\nouter()가 실행된 후 전역 변수(100)는 변하지 않는다.\n\n\n\n\n함수 데코레이터\nPython에서 데코레이터(Decorator)는 기존 함수나 메서드의 동작을 변경하거나 확장할 때 사용되는 기능이다. @데코레이터_함수 형식으로 사용하며, 함수를 감싸는(wrapper) 역할을 수행한다.\n\n기본적인 데코레이터 구조\n\ndef my_decorator(func):  # 데코레이터 함수\n    def wrapper():\n        print(\"함수 실행 전\")\n        func()\n        print(\"함수 실행 후\")\n    return wrapper\n\n@my_decorator\ndef say_hello():\n    print(\"Hello, World!\")\n\nsay_hello()\n\n함수 실행 전\nHello, World!\n함수 실행 후\n\n\n\n@my_decorator를 사용하면 say_hello()가 자동으로 wrapper() 함수로 감싸짐.\n실행 순서:\n\n\"함수 실행 전\" 출력\nsay_hello() 실행\n\"함수 실행 후\" 출력\n\n\n\n\n여러 개의 데코레이터 사용\n여러 개의 데코레이터를 적용하면 위에서부터 차례로 적용된다.\n\ndef decorator1(func):\n    def wrapper():\n        print(\"데코레이터 1 실행\")\n        func()\n    return wrapper\n\ndef decorator2(func):\n    def wrapper():\n        print(\"데코레이터 2 실행\")\n        func()\n    return wrapper\n\n@decorator1\n@decorator2\ndef greet():\n    print(\"안녕하세요!\")\n\ngreet()\n\n데코레이터 1 실행\n데코레이터 2 실행\n안녕하세요!\n\n\n\n적용 순서: @decorator1 → @decorator2\ndecorator1이 가장 바깥쪽에서 실행된다.\n\n\n\n인자가 있는 함수 데코레이팅\n인자가 있는 함수를 데코레이터로 감싸려면 *args, **kwargs를 사용해야 한다.\n\ndef my_decorator(func):\n    def wrapper(*args, **kwargs):\n        print(\"함수 실행 전\")\n        result = func(*args, **kwargs)\n        print(\"함수 실행 후\")\n        return result\n    return wrapper\n\n@my_decorator\ndef add(a, b):\n    return a + b\n\nprint(add(3, 5))\n\n함수 실행 전\n함수 실행 후\n8\n\n\n\nwrapper(*args, **kwargs)를 사용하여 add(a, b)의 인자를 받을 수 있도록 함.\n\n\n\nfunctools.wraps를 사용한 데코레이터\n데코레이터를 사용하면 원래 함수의 이름(name)과 문서(docstring)가 변경될 수 있다. 이를 방지하려면 functools.wraps()를 사용한다.\n\nimport functools\n\ndef my_decorator(func):\n    @functools.wraps(func)  # 원래 함수 정보 유지\n    def wrapper(*args, **kwargs):\n        print(\"함수 실행 전\")\n        result = func(*args, **kwargs)\n        print(\"함수 실행 후\")\n        return result\n    return wrapper\n\n@my_decorator\ndef add(a, b):\n    \"\"\"두 수를 더하는 함수\"\"\"\n    return a + b\n\nprint(add.__name__)  # add (원래 함수 이름 유지)\nprint(add.__doc__)   # 두 수를 더하는 함수 (문서 유지)\n\nadd\n두 수를 더하는 함수\n\n\n\n@functools.wraps(func)를 사용하면 함수 이름과 문서가 변경되지 않음.\n\n\n\n클래스 기반 데코레이터\n데코레이터를 클래스로도 구현 가능하다.\n\nclass MyDecorator:\n    def __init__(self, func):\n        self.func = func\n\n    def __call__(self, *args, **kwargs):\n        print(\"함수 실행 전\")\n        result = self.func(*args, **kwargs)\n        print(\"함수 실행 후\")\n        return result\n\n@MyDecorator\ndef say_hello():\n    print(\"Hello!\")\n\nsay_hello()\n\n함수 실행 전\nHello!\n함수 실행 후\n\n\n\n__call__() 메서드를 사용하면 객체를 함수처럼 호출할 수 있다.\n@MyDecorator를 사용하면 say_hello()가 MyDecorator 객체로 변환된다.\n\n\n\n매개변수가 있는 데코레이터\n데코레이터에 인자를 전달하려면 함수 내부에 함수를 중첩해야 한다.\n\ndef repeat(n):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            for _ in range(n):  # n번 반복 실행\n                func(*args, **kwargs)\n        return wrapper\n    return decorator\n\n@repeat(3)\ndef greet():\n    print(\"안녕하세요!\")\n\ngreet()\n\n안녕하세요!\n안녕하세요!\n안녕하세요!\n\n\n\nrepeat(n)이 먼저 실행된 후 @decorator가 greet()을 감싼다.\n\n\n\n내장 데코레이터\nPython에는 기본 제공 데코레이터가 있다.\n@staticmethod (정적 메서드)\n:- 인스턴스(self) 없이 호출 가능한 메서드\n\nclass Math:\n    @staticmethod\n    def add(a, b):\n        return a + b\n\nprint(Math.add(3, 5))  # 8\n\n8\n\n\n\n@classmethod (클래스 메서드)\n\n\n클래스(cls) 자체를 인자로 받음\n\n\n\n\nclass Example:\n    count = 0\n\n    @classmethod\n    def increase(cls):\n        cls.count += 1\n        return cls.count\n\nprint(Example.increase())  # 1\n\n1\n\n\n\n@property (게터)\n\n\n메서드를 속성처럼 사용 가능\n\n\n\n\nclass Person:\n    def __init__(self, name):\n        self._name = name\n\n    @property\n    def name(self):\n        return self._name  # 속성처럼 사용 가능\n\np = Person(\"철수\")\nprint(p.name)  # 철수\n\n철수\n\n\n\n\n\n함수형 프로그래밍 개념\nmap 함수: 리스트의 각 요소에 함수를 적용한다.\n\nnumbers = [1, 2, 3, 4]\nsquared = list(map(lambda x: x ** 2, numbers))\nprint(squared)\n\n[1, 4, 9, 16]\n\n\nfilter 함수: 리스트의 요소를 조건에 맞게 필터링한다.\n\neven_numbers = list(filter(lambda x: x % 2 == 0, numbers))\nprint(even_numbers)  # [2, 4]\n\n[2, 4]\n\n\nreduce 함수: 리스트의 요소를 누적하여 하나의 결과를 만든다.\n\nfrom functools import reduce\ntotal = reduce(lambda x, y: x + y, numbers)\nprint(total)  # 10\n\n10",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>함수 및 모듈</span>"
    ]
  },
  {
    "objectID": "50function.html#sec-module",
    "href": "50function.html#sec-module",
    "title": "함수 및 모듈",
    "section": "모듈",
    "text": "모듈\nPython에서 모듈(Module)은 관련된 코드(함수, 클래스, 변수 등)를 하나의 파일(.py)로 저장한 것이다. 이를 통해 코드 재사용성을 높이고, 유지보수를 용이하게 하며, 프로그램을 구조화할 수 있다.\n\n파이썬 모듈\n\n\n개념\n설명\n\n\n\n\n모듈\n관련된 함수, 클래스, 변수를 모은 .py 파일\n\n\n모듈 가져오기\nimport 모듈명, from 모듈명 import 이름\n\n\n표준 모듈\nmath, random, datetime, os 등\n\n\n사용자 모듈\n직접 만든 .py 파일을 모듈로 사용 가능\n\n\n패키지\n여러 개의 모듈을 포함하는 디렉토리\n\n\n모듈 재로딩\nimportlib.reload(모듈명)\n\n\n\nPython의 모듈과 패키지를 활용하면 코드 재사용성을 높이고, 프로그램을 체계적으로 관리할 수 있다.\n\n모듈 생성과 사용\n\n모듈 생성\n모듈 생성은 다음과 같다.\n\nPython 파일(.py)을 생성한다.\n파일 내부에 함수, 클래스, 변수 등을 정의한다.\n\n# my_module.py (사용자 정의 모듈)\ndef greet(name):\n    return f\"안녕하세요, {name}!\"\n\npi = 3.14159\n\n\n모듈 가져오기 (import)\nimport 모듈명을 사용하여 모듈을 가져올 수 있다.\nimport my_module\n\nprint(my_module.greet(\"철수\"))  # 안녕하세요, 철수!\nprint(my_module.pi)  # 3.14159\n\n\nimport 방식\n\nimport 방식\n\n\n방법\n설명\n\n\n\n\nimport 모듈명\n모듈 전체를 가져옴 (접근 시 모듈명.이름)\n\n\nimport 모듈명 as 별칭\n모듈에 별칭을 부여\n\n\nfrom 모듈명 import 이름\n특정 함수/클래스/변수만 가져옴\n\n\nfrom 모듈명 import *\n모듈의 모든 내용을 가져옴\n\n\n\n# (1) 모듈 전체 가져오기\nimport my_module\nprint(my_module.greet(\"영희\"))  # 안녕하세요, 영희!\n\n# (2) 모듈 별칭 사용\nimport my_module as mm\nprint(mm.pi)  # 3.14159\n\n# (3) 특정 함수만 가져오기\nfrom my_module import greet\nprint(greet(\"민수\"))  # 안녕하세요, 민수!\n\n# (4) 모든 요소 가져오기 (비추천)\nfrom my_module import *\nprint(greet(\"진수\"))  # 안녕하세요, 진수!\nprint(pi)  # 3.14159\n\nfrom 모듈명 import *는 네임스페이스 충돌 위험이 있어 권장되지 않는다.\n\n\n\n\nname 변수\n모듈이 직접 실행될 때와 import될 때를 구분하기 위해 __name__ 변수를 사용한다.\n# my_module.py\ndef greet(name):\n    return f\"안녕하세요, {name}!\"\n\nif __name__ == \"__main__\":  \n    # 직접 실행할 때만 실행됨\n    print(greet(\"테스트\"))\n\n__name__ == \"__main__\" 조건을 사용하면 import될 때 실행되지 않음.\n직접 실행 시 __name__은 \"__main__\"이지만, import되면 \"my_module\"이 된다.\n\n\n\n표준 모듈\nPython은 기본적으로 제공하는 표준 라이브러리 모듈이 많다.\n\n파이썬 표준 라이브러리\n\n\n모듈\n설명\n\n\n\n\nmath\n수학 관련 함수 제공\n\n\nrandom\n난수 생성\n\n\ndatetime\n날짜 및 시간 관리\n\n\nos\n운영체제(OS) 관련 기능\n\n\nsys\n시스템 관련 기능\n\n\ntime\n시간 관련 기능\n\n\n\n\nimport math\nimport random\nimport datetime\n\nprint(math.sqrt(16))  # 4.0\nprint(random.randint(1, 10))  # 1~10 사이의 난수\nprint(datetime.datetime.now())  # 현재 날짜 및 시간 출력\n\n4.0\n1\n2025-02-06 04:52:38.966785\n\n\n\n\n사용자 정의 모듈 저장 경로\nPython은 모듈을 특정 디렉토리에서 찾는다.\n모듈이 저장된 경로를 확인하려면 sys.path를 사용한다.\nimport sys\nprint(sys.path)  # 모듈 검색 경로 리스트\n사용자 정의 모듈을 특정 디렉토리에 추가하려면 다음과 같이 설정할 수 있다.\nimport sys\nsys.path.append(\"C:/my_modules\")  # 해당 경로 추가\nprint(sys.path)",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>함수 및 모듈</span>"
    ]
  },
  {
    "objectID": "50function.html#패키지",
    "href": "50function.html#패키지",
    "title": "함수 및 모듈",
    "section": "패키지",
    "text": "패키지\n패키지는 여러 모듈을 포함하는 디렉토리(폴더)로 패키지 폴더 안에는 __init__.py 파일이 있어야 한다.\n\n패키지 구조 예시\nmypackage/          # 패키지 폴더\n│── __init__.py   # 패키지 초기화 파일\n│── module1.py    # 모듈 1\n│── module2.py    # 모듈 2\n\n\n패키지 가져오기\nfrom mypackage import module1\nimport mypackage.module2 as m2\n\nprint(module1.greet(\"철수\"))\nprint(m2.pi)\n\n\n모듈 리로드\nPython은 모듈을 한 번만 로드하므로, 수정된 모듈을 다시 가져오려면 importlib.reload()를 사용한다.\nimport my_module\nimport importlib\n\nimportlib.reload(my_module)  # 모듈 다시 로드",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>함수 및 모듈</span>"
    ]
  },
  {
    "objectID": "60file.html",
    "href": "60file.html",
    "title": "파일 입출력",
    "section": "",
    "text": "파일 입출력\nPython에서 파일 입출력(File I/O)은 open() 함수를 사용하여 파일을 읽고 쓰는 작업을 수행한다. 파일을 다룰 때는 반드시 파일을 열고, 작업 후 닫아야 한다.\n파일 입출력을 활용하면 데이터를 저장하고 불러오는 작업을 쉽게 수행할 수 있다.",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>파일 입출력</span>"
    ]
  },
  {
    "objectID": "60file.html#sec-file-io",
    "href": "60file.html#sec-file-io",
    "title": "파일 입출력",
    "section": "",
    "text": "파일 입출력\n\n\n개념\n설명\n\n\n\n\n파일 열기\nopen(\"파일명\", \"모드\")\n\n\n파일 모드\n\"r\", \"w\", \"a\", \"b\", \"t\"\n\n\n파일 쓰기\nwrite() 사용\n\n\n파일 읽기\nread(), readline(), readlines()\n\n\n자동 닫기\nwith open(\"파일명\") as file:\n\n\nCSV 파일\ncsv.reader(), csv.writer()\n\n\nJSON 파일\njson.load(), json.dump()\n\n\n\n\n\n파일 열기\nPython에서 파일을 열 때는 open(\"파일명\", \"모드\")를 사용한다. 파일을 열면 파일 객체(file object)가 반환되며, 이후 읽기(read()), 쓰기(write()) 등의 작업을 수행할 수 있다.\n\n파일 열기 기본 문법\nfile = open(\"example.txt\", \"r\")  # 파일 열기\n# 파일 작업 수행\nfile.close()  # 파일 닫기\n\nopen(\"파일명\", \"모드\")를 사용하여 파일을 연다.\n\n파일을 사용한 후에는 반드시 close()를 호출하여 파일을 닫아야 한다.\n\n\n\n파일 열기 모드\n\n파일 열기 모드\n\n\n\n\n\n\n모드\n설명\n\n\n\n\n\"r\"\n읽기 모드 (파일이 존재해야 함)\n\n\n\"w\"\n쓰기 모드 (파일이 없으면 생성, 있으면 덮어쓰기)\n\n\n\"a\"\n추가 모드 (파일이 없으면 생성, 있으면 이어쓰기)\n\n\n\"x\"\n새로운 파일 생성 (파일이 이미 있으면 오류 발생)\n\n\n\"b\"\n바이너리 모드 (예: \"rb\", \"wb\")\n\n\n\"t\"\n텍스트 모드 (기본값)\n\n\n\n\n(1) 읽기 모드 (\"r\")\n\n\n파일이 존재해야 하며, 파일을 읽기만 할 수 있다.\n\n\n\n# \"example.txt\" 파일이 존재해야 함\nfile = open(\"example.txt\", \"r\")\ncontent = file.read()  # 파일 전체 읽기\nprint(content)\nfile.close()\n\n(2) 쓰기 모드 (\"w\")\n\n\n파일이 없으면 새로 생성됨.\n\n파일이 있으면 기존 내용이 삭제됨.\n\n\n\nfile = open(\"example.txt\", \"w\")\nfile.write(\"Hello, Python!\\n\")\nfile.write(\"파일 입출력 예제입니다.\\n\")\nfile.close()\n\n(3) 추가 모드 (\"a\")\n\n\n파일이 없으면 새로 생성됨.\n\n파일이 있으면 기존 내용은 유지되며, 새로운 내용이 추가됨.\n\n\n\nfile = open(\"example.txt\", \"a\")\nfile.write(\"추가된 내용입니다.\\n\")\nfile.close()\n\n(4) 새로운 파일 생성 (\"x\")\n\n\n파일이 없으면 새로 생성됨.\n\n파일이 이미 존재하면 오류 발생.\n\n\n\nfile = open(\"new_file.txt\", \"x\")  # 파일이 이미 있으면 에러 발생\nfile.write(\"새로운 파일 생성\\n\")\nfile.close()\n\n(5) 바이너리 모드 (\"rb\", \"wb\")\n\n\n이미지, 오디오, 동영상 같은 바이너리 파일을 처리할 때 사용.\n\n\n\n# 바이너리 파일 읽기\nfile = open(\"image.jpg\", \"rb\")\nbinary_data = file.read()\nfile.close()\n\n# 바이너리 파일 쓰기\nfile = open(\"copy.jpg\", \"wb\")\nfile.write(binary_data)\nfile.close()\n\n\nwith 문을 사용한 파일 열기\n파일을 열고 닫는 작업을 자동으로 처리하기 위해 with open() 구문을 사용하면 편리하다.\nwith open(\"example.txt\", \"r\") as file:\n    content = file.read()\n    print(content)  # 파일이 자동으로 닫힘\n\nwith 문을 사용하면 close()를 호출할 필요가 없다.\n예외 발생 시에도 안전하게 파일이 닫힘.\n\n\n\n파일 존재 여부 확인\n파일을 열기 전에 존재 여부를 확인하려면 os.path.exists()를 사용할 수 있다.\nimport os\n\nif os.path.exists(\"example.txt\"):\n    with open(\"example.txt\", \"r\") as file:\n        print(file.read())\nelse:\n    print(\"파일이 존재하지 않습니다.\")\n\n\n파일 모드\n\n파일 모드\n\n\n\n\n\n\n모드\n설명\n\n\n\n\n\"r\"\n읽기 모드 (파일이 존재해야 함)\n\n\n\"w\"\n쓰기 모드 (파일이 없으면 생성, 있으면 덮어쓰기)\n\n\n\"a\"\n추가 모드 (파일이 없으면 생성, 있으면 이어쓰기)\n\n\n\"x\"\n새로운 파일 생성 (파일이 이미 있으면 오류 발생)\n\n\n\"b\"\n바이너리 모드 (예: \"rb\", \"wb\")\n\n\n\"t\"\n텍스트 모드 (기본값)\n\n\n\n\n\n\n파일 쓰기\nPython에서 파일에 데이터를 저장하려면 open(\"파일명\", \"w\") 또는 \"a\" 모드를 사용하여 파일을 연 후, write() 함수를 사용하면 된다. 파일 작업이 끝난 후에는 반드시 close() 또는 with open()을 사용하여 파일을 닫아야 한다.\n\n파일 쓰기\n\n\n\n\n\n\n개념\n설명\n\n\n\n\n파일 쓰기\nopen(\"파일명\", \"w\") 후 write() 사용\n\n\n추가 모드\nopen(\"파일명\", \"a\") (기존 내용 유지)\n\n\n새 파일 생성\nopen(\"파일명\", \"x\") (파일이 존재하면 오류)\n\n\n자동 닫기\nwith open(\"파일명\") as file: 사용\n\n\n여러 줄 쓰기\nwritelines() 사용\n\n\nCSV 파일 저장\ncsv.writer() 사용\n\n\nJSON 파일 저장\njson.dump() 사용\n\n\n\nPython에서 파일 쓰기를 활용하면 다양한 방식으로 데이터를 저장할 수 있다.\n\n파일 쓰기 모드\n\n\n\n\n\n\n모드\n설명\n\n\n\n\n\"w\"\n쓰기 모드 (파일이 없으면 생성, 있으면 기존 내용 삭제)\n\n\n\"a\"\n추가 모드 (파일이 없으면 생성, 있으면 기존 내용 유지하고 새로운 내용 추가)\n\n\n\"x\"\n파일 생성 모드 (파일이 이미 있으면 오류 발생)\n\n\n\n\n(1) 쓰기 모드 (\"w\")\n\n\n기존 파일이 있으면 덮어쓰기(기존 내용 삭제)\n\n파일이 없으면 새로 생성\n\n\n\n# 파일 열기 (쓰기 모드, 기존 내용 삭제)\nfile = open(\"example.txt\", \"w\")\n\n# 파일에 문자열 쓰기\nfile.write(\"Hello, Python!\\n\")\nfile.write(\"파일 쓰기 예제입니다.\\n\")\n\n# 파일 닫기\nfile.close()\n\n\n파일 내용 (example.txt)\n\nHello, Python!\n파일 쓰기 예제입니다.\n\n(2) 추가 모드 (\"a\")\n\n\n기존 파일이 있으면 기존 내용 유지 + 새로운 내용 추가\n\n파일이 없으면 새로 생성됨\n\n\n\nfile = open(\"example.txt\", \"a\")  # 추가 모드로 열기\nfile.write(\"추가된 내용입니다.\\n\")  # 기존 내용 유지\nfile.close()\n\n\n파일 내용 (example.txt)\n\nHello, Python!\n파일 쓰기 예제입니다.\n추가된 내용입니다.\n\n(3) 파일 생성 모드 (\"x\")\n\n\n새로운 파일을 생성\n\n파일이 이미 존재하면 오류 발생\n\n\n\nfile = open(\"new_file.txt\", \"x\")  # 새 파일 생성\nfile.write(\"새로운 파일입니다.\\n\")\nfile.close()\n\n파일이 이미 존재할 경우 :\nFileExistsError: [Errno 17] File exists: 'new_file.txt'\n\nwith 문을 사용한 파일 쓰기\n파일을 열고 닫는 작업을 자동으로 처리하기 위해 with open()을 사용하는 것이 좋다.\nwith open(\"example.txt\", \"w\") as file:\n    file.write(\"자동으로 파일이 닫힙니다.\\n\")\n    file.write(\"with open()을 사용하면 close()가 필요 없습니다.\\n\")\n\nwith 문을 사용하면 파일을 자동으로 닫아주므로 close()를 호출할 필요가 없다.\n예외가 발생해도 자동으로 파일이 닫히므로 안전하다.\n\n\n\n여러 줄 쓰기\nwritelines()를 사용하면 리스트 형식의 여러 줄을 한 번에 쓸 수 있다.\nlines = [\"첫 번째 줄\\n\", \"두 번째 줄\\n\", \"세 번째 줄\\n\"]\n\nwith open(\"example.txt\", \"w\") as file:\n    file.writelines(lines)\n\n\n파일 내용 (example.txt)\n\n첫 번째 줄\n두 번째 줄\n세 번째 줄\n\n\n\n\n숫자 데이터 쓰기\nwrite()는 문자열만 저장할 수 있으므로 숫자는 str()로 변환하여 저장해야 한다.\nwith open(\"numbers.txt\", \"w\") as file:\n    for i in range(1, 6):\n        file.write(f\"숫자: {i}\\n\")\n\n\n파일 내용 (numbers.txt)\n\n숫자: 1\n숫자: 2\n숫자: 3\n숫자: 4\n숫자: 5\n\n\n\n\nCSV 파일 쓰기\nCSV(Comma-Separated Values) 파일을 저장할 때는 csv.writer()를 사용한다.\nimport csv\n\ndata = [\n    [\"이름\", \"나이\", \"직업\"],\n    [\"철수\", 25, \"개발자\"],\n    [\"영희\", 30, \"디자이너\"]\n]\n\nwith open(\"data.csv\", \"w\", newline=\"\", encoding=\"utf-8\") as file:\n    writer = csv.writer(file)\n    writer.writerows(data)  # 여러 줄 쓰기\n\n\n파일 내용 (data.csv)\n\n이름,나이,직업\n철수,25,개발자\n영희,30,디자이너\n\n\n\n\nJSON 파일 쓰기\nJSON 파일을 저장할 때는 json.dump()를 사용한다.\nimport json\n\ndata = {\"이름\": \"철수\", \"나이\": 25, \"직업\": \"개발자\"}\n\nwith open(\"data.json\", \"w\", encoding=\"utf-8\") as file:\n    json.dump(data, file, ensure_ascii=False, indent=4)\n\n\n파일 내용 (data.json)\n\n{\n\"이름\": \"철수\",\n\"나이\": 25,\n\"직업\": \"개발자\"\n}\n\n\n\n\n\n파일 읽기\nPython에서 파일을 읽을 때는 open() 함수로 파일을 연 후, 다양한 방법으로 파일을 읽을 수 있다. 파일을 읽은 후에는 반드시 close()를 호출하거나 with open()을 사용해 자동으로 파일을 닫아야 한다.\n\n파일 읽기\n\n\n\n\n\n\n방법\n설명\n\n\n\n\n전체 내용 읽기\nfile.read()\n\n\n한 줄씩 읽기\nfile.readline()\n\n\n여러 줄 읽기\nfile.readlines()\n\n\n자동 닫기\nwith open(\"파일명\") as file: 사용\n\n\n바이너리 파일 읽기\nopen(\"파일명e\", \"rb\") 사용\n\n\n파일 일부 읽기\nfile.read(size)\n\n\n\n파일을 읽을 때는 필요한 방식에 맞게 read(), readline(), readlines()를 사용하여 효율적으로 파일 내용을 처리할 수 있다.\n\n파일 열기 모드\n\n\n\n모드\n설명\n\n\n\n\n\"r\"\n읽기 모드 (파일이 존재해야 함)\n\n\n\"rb\"\n바이너리 읽기 모드 (이미지, 오디오 파일 등)\n\n\n\n\n\n파일 읽기 방법\n(1) 전체 내용 읽기 (read())\n\nread()는 파일의 전체 내용을 하나의 문자열로 반환한다.\n\n# 파일을 읽기 모드로 열기\nfile = open(\"example.txt\", \"r\")\n\n# 전체 내용 읽기\ncontent = file.read()\n\n# 읽은 내용 출력\nprint(content)\n\n# 파일 닫기\nfile.close()\n\n\n파일 내용 (example.txt)\n\nHello, Python!\n파일 읽기 예제입니다.\n\n\n\n\n출력 결과\n\nHello, Python!\n파일 읽기 예제입니다.\n\n\n(2) 한 줄씩 읽기 (readline())\n\nreadline()은 파일에서 한 줄씩 읽어서 문자열로 반환한다.\n\n줄바꿈 문자(\\n)가 포함된 채로 반환된다.\n\n# 파일을 읽기 모드로 열기\nfile = open(\"example.txt\", \"r\")\n\n# 첫 번째 줄 읽기\nline1 = file.readline()\nprint(line1)\n\n# 두 번째 줄 읽기\nline2 = file.readline()\nprint(line2)\n\n# 파일 닫기\nfile.close()\n\n\n파일 내용 (example.txt)\n\nHello, Python!\n파일 읽기 예제입니다.\n\n\n\n\n출력 결과\n\nHello, Python!\n파일 읽기 예제입니다.\n\n\n(3) 여러 줄 읽기 (readlines())\n\nreadlines()는 파일을 전체 줄을 리스트로 반환한다.\n\n각 줄은 줄바꿈 문자(\\n)와 함께 리스트의 항목으로 저장된다.\n\n# 파일을 읽기 모드로 열기\nfile = open(\"example.txt\", \"r\")\n\n# 모든 줄을 리스트로 읽기\nlines = file.readlines()\n\n# 리스트 내용 출력\nprint(lines)\n\n# 파일 닫기\nfile.close()\n\n\n파일 내용 (example.txt)\n\nHello, Python!\n파일 읽기 예제입니다.\n\n\n\n\n출력 결과\n\n['Hello, Python!\\n', '파일 읽기 예제입니다.\\n']\n\n\n(4) with 문을 사용한 파일 읽기\n\nwith open() 구문을 사용하면 파일을 자동으로 닫을 수 있어 파일 관리가 편리하다.\n\nwith open(\"example.txt\", \"r\") as file:\n    content = file.read()  # 전체 내용 읽기\n    print(content)\n\nwith 문을 사용하면 close()를 명시적으로 호출할 필요가 없으며, 예외가 발생해도 파일이 안전하게 닫힌다.\n\n\n\n바이너리 파일 읽기\n\n바이너리 파일을 읽을 때는 \"rb\" 모드를 사용한다.\n\n읽은 데이터는 바이트 객체로 반환된다.\n\nwith open(\"image.jpg\", \"rb\") as file:\n    binary_data = file.read()  # 이미지 파일을 바이트로 읽기\n    print(binary_data[:10])  # 바이트 일부 출력\n\n바이너리 파일을 읽은 후에는 바이트 객체로 처리되며, 일반적인 문자열 처리 방법과는 다르다.\n\n\n\n파일에서 일부만 읽기\n\nread(size)를 사용하면 파일에서 지정한 크기만큼 데이터를 읽을 수 있다.\n\nwith open(\"example.txt\", \"r\") as file:\n    # 첫 5글자만 읽기\n    content = file.read(5)\n    print(content)\n\n\n출력 결과\n\nHello\n\n\n\nread(size)는 파일의 처음부터 지정된 바이트 수만큼 읽고, 이후 다음 호출에서 나머지를 읽는다.\n\n\n\n\nCSV 파일 읽고 쓰기\ncsv 모듈을 사용하여 CSV 파일을 읽고 쓸 수 있다.\n\nCSV 파일 쓰기\nimport csv\n\nwith open(\"data.csv\", \"w\", newline=\"\", encoding=\"utf-8\") as file:\n    writer = csv.writer(file)\n    writer.writerow([\"이름\", \"나이\", \"직업\"])  # 헤더 작성\n    writer.writerow([\"철수\", 25, \"개발자\"])\n    writer.writerow([\"영희\", 30, \"디자이너\"])\n\n\n파일 내용 (data.csv)\n\n이름,나이,직업\n철수,25,개발자\n영희,30,디자이너\n\n\n\n\nCSV 파일 읽기\nwith open(\"data.csv\", \"r\", encoding=\"utf-8\") as file:\n    reader = csv.reader(file)\n    for row in reader:\n        print(row)\n\n\n출력 결과\n\n['이름', '나이', '직업']\n['철수', '25', '개발자']\n['영희', '30', '디자이너']\n\n\n\n\n\nJSON 파일 읽고 쓰기\njson 모듈을 사용하여 JSON 파일을 읽고 쓸 수 있다.\n\nJSON 파일 쓰기\nimport json\n\ndata = {\"이름\": \"철수\", \"나이\": 25, \"직업\": \"개발자\"}\n\nwith open(\"data.json\", \"w\", encoding=\"utf-8\") as file:\n    json.dump(data, file, ensure_ascii=False, indent=4)  # JSON 저장\n\n\n파일 내용 (data.json)\n\n{\n\"이름\": \"철수\",\n\"나이\": 25,\n\"직업\": \"개발자\"\n}\n\n\n\n\nJSON 파일 읽기\nwith open(\"data.json\", \"r\", encoding=\"utf-8\") as file:\n    data = json.load(file)\n    print(data)\n\n\n출력 결과\n\n{'이름': '철수', '나이': 25, '직업': '개발자'}",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>파일 입출력</span>"
    ]
  },
  {
    "objectID": "70exception.html",
    "href": "70exception.html",
    "title": "예외처리",
    "section": "",
    "text": "예외 처리 (Exception Handling)\n예외(Exception)는 프로그램 실행 중 발생하는 오류로, 이를 적절히 처리하지 않으면 프로그램이 강제 종료될 수 있다. Python에서는 try-except 문을 사용하여 예외를 처리하고, 프로그램이 중단되지 않도록 만들 수 있다.\n예외 처리를 활용하면 프로그램이 예상치 못한 오류에도 안전하게 실행될 수 있다.",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>예외처리</span>"
    ]
  },
  {
    "objectID": "70exception.html#예외-처리-exception-handling",
    "href": "70exception.html#예외-처리-exception-handling",
    "title": "예외처리",
    "section": "",
    "text": "기능\n설명\n\n\n\n\ntry\n예외가 발생할 가능성이 있는 코드 실행\n\n\nexcept 예외_타입\n특정 예외가 발생했을 때 실행\n\n\nexcept Exception as e\n모든 예외를 처리하고 오류 메시지 출력\n\n\nelse\n예외가 발생하지 않았을 때 실행\n\n\nfinally\n예외 발생 여부와 관계없이 항상 실행\n\n\nraise 예외_타입(\"메시지\")\n직접 예외 발생\n\n\n\n\n\n예외 처리 기본 구조\ntry:\n    # 예외가 발생할 가능성이 있는 코드\nexcept 예외_타입:\n    # 예외가 발생했을 때 실행할 코드\n\ntry: 예외가 발생할 가능성이 있는 코드를 작성\n\nexcept: 예외가 발생하면 실행할 코드 작성\n\n\n\n\n기본 예제\n1. 0으로 나누기 예외 (ZeroDivisionError)\n\ntry:\n    # num = int(input(\"숫자를 입력하세요: \"))\n    num = 0\n    result = 10 / num  # 0 입력 시 예외 발생\n    print(\"결과:\", result)\nexcept ZeroDivisionError:\n    print(\"0으로 나눌 수 없습니다.\")\n\n0으로 나눌 수 없습니다.\n\n\n2. 입력값이 숫자가 아닐 때 예외 (ValueError)\n\ntry:\n    # num = int(input(\"숫자를 입력하세요: \"))  # 문자를 입력하면 예외 발생\n    num = int('abc')\n    print(\"입력한 숫자:\", num)\nexcept ValueError:\n    print(\"올바른 숫자를 입력하세요.\")\n\n올바른 숫자를 입력하세요.\n\n\n3. 여러 개의 예외 처리\n\ntry:\n    # num = int(input(\"숫자를 입력하세요: \"))\n    num = 0 # num = 'abc'\n    result = 10 / num\nexcept ZeroDivisionError:\n    print(\"0으로 나눌 수 없습니다.\")\nexcept ValueError:\n    print(\"올바른 숫자를 입력하세요.\")\nexcept Exception as e:\n    print(\"예외 발생:\", e)\n\n0으로 나눌 수 없습니다.\n\n\n4. else와 finally 사용\n\ntry:\n    # num = int(input(\"숫자를 입력하세요: \"))\n    num = 0\n    result = 10 / num\nexcept ZeroDivisionError:\n    print(\"0으로 나눌 수 없습니다.\")\nexcept ValueError:\n    print(\"올바른 숫자를 입력하세요.\")\nelse:\n    print(\"연산 결과:\", result)\nfinally:\n    print(\"프로그램 종료\")\n\n0으로 나눌 수 없습니다.\n프로그램 종료\n\n\n\nelse: 예외가 발생하지 않으면 실행\n\nfinally: 예외 발생 여부와 관계없이 항상 실행\n\n5. 사용자 정의 예외 (raise)\n\nclass NegativeNumberError(Exception):\n    pass\n\n\ntry:\n    # num = int(input(\"양수를 입력하세요: \"))\n    num = -1\n    if num &lt; 0:\n        raise NegativeNumberError(\"음수는 입력할 수 없습니다.\")\n    print(\"입력한 숫자:\", num)\nexcept NegativeNumberError as e:\n    print(e)\nexcept ValueError:\n    print(\"올바른 숫자를 입력하세요.\")\n\n음수는 입력할 수 없습니다.\n\n\n6. 파일 읽기 예외 (FileNotFoundError)\n\ntry:\n    with open(\"nonexistent.txt\", \"r\") as file:\n        content = file.read()\n        print(content)\nexcept FileNotFoundError:\n    print(\"파일을 찾을 수 없습니다.\")\n\n파일을 찾을 수 없습니다.",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>예외처리</span>"
    ]
  },
  {
    "objectID": "80class.html",
    "href": "80class.html",
    "title": "클래스",
    "section": "",
    "text": "클래스 개념 이해",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>클래스</span>"
    ]
  },
  {
    "objectID": "80class.html#클래스-개념-이해",
    "href": "80class.html#클래스-개념-이해",
    "title": "클래스",
    "section": "",
    "text": "객체지향 프로그래밍(OOP) 개념\n객체지향 프로그래밍(OOP, Object-Oriented Programming)은 현실 세계를 객체(Object) 단위로 나누어 프로그램을 설계하는 방식이다. OOP의 주요 특징은 다음과 같다.\n\n캡슐화(Encapsulation): 데이터와 기능(메서드)을 하나로 묶어 보호하는 개념\n\n상속(Inheritance): 기존 클래스(부모)에서 기능을 물려받아 새로운 클래스(자식)를 만드는 개념\n\n다형성(Polymorphism): 같은 이름의 메서드가 다른 기능을 할 수 있는 개념\n\n추상화(Abstraction): 객체의 중요한 속성만 표현하여 단순화하는 개념\n\n\n\n클래스와 객체의 정의\n\n클래스(Class): 객체를 만들기 위한 설계도\n\n객체(Object): 클래스에서 생성된 실체(인스턴스)\n\n클래스와 객체\n\nclass Car:\n    def __init__(self, brand, color):\n        self.brand = brand  # 속성(변수)\n        self.color = color\n\n    def drive(self):  # 메서드(함수)\n        print(f\"{self.color} {self.brand}가 주행 중입니다.\")\n\n# 객체 생성\nmy_car = Car(\"Hyundai\", \"Red\")\n\n# 객체 사용\nprint(my_car.brand)  # Hyundai 출력\nmy_car.drive()       # \"Red Hyundai가 주행 중입니다.\" 출력\n\nHyundai\nRed Hyundai가 주행 중입니다.\n\n\n\n\n클래스와 인스턴스의 차이\n\n클래스와 인스턴스\n\n\n\n\n\n\n\n구분\n설명\n예제\n\n\n\n\n클래스\n객체를 만들기 위한 설계도\nclass Car:\n\n\n인스턴스(객체)\n클래스로부터 생성된 개별 실체\nmy_car = Car(\"Hyundai\", \"Red\")\n\n\n\n클래스와 인스턴스의 관계 예제\n\nclass Dog:\n    def __init__(self, name):\n        self.name = name\n\n# 인스턴스 생성\ndog1 = Dog(\"Buddy\")\ndog2 = Dog(\"Charlie\")\n\nprint(dog1.name)  # Buddy 출력\nprint(dog2.name)  # Charlie 출력\n\nBuddy\nCharlie\n\n\n\nDog 클래스는 하나지만, dog1, dog2처럼 여러 개의 인스턴스를 생성 가능\n\n각 인스턴스는 독립적으로 동작\n\n이 개념을 이해하면 객체지향 프로그래밍(OOP)을 기반으로 한 클래스 설계를 할 수 있다.",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>클래스</span>"
    ]
  },
  {
    "objectID": "80class.html#클래스-정의와-객체-생성",
    "href": "80class.html#클래스-정의와-객체-생성",
    "title": "클래스",
    "section": "클래스 정의와 객체 생성",
    "text": "클래스 정의와 객체 생성\n객체지향 프로그래밍(OOP)의 기본이 되는 클래스와 객체 개념을 이해하면 더욱 효율적인 프로그램을 작성할 수 있다.\n\n클래스와 객책\n\n\n\n\n\n\n\n개념\n설명\n예제\n\n\n\n\n클래스\n객체를 만들기 위한 설계도\nclass Car:\n\n\n객체(인스턴스)\n클래스로부터 생성된 실체\nmy_car = Car(\"Hyundai\", \"Red\")\n\n\n속성(변수)\n객체가 가지는 데이터\nself.brand = brand\n\n\n메서드(함수)\n객체가 수행할 동작\ndef drive(self):\n\n\n\n\n클래스 정의\n클래스는 class 키워드를 사용하여 정의하며, 객체의 속성(변수)과 동작(메서드)을 포함할 수 있다.\n\nclass 클래스이름:\n    def __init__(self, 속성1, 속성2):\n        self.속성1 = 속성1\n        self.속성2 = 속성2\n    \n    def 메서드(self):\n        print(\"이것은 클래스의 메서드입니다.\")\n\n\n\n객체(인스턴스) 생성\n클래스를 정의한 후, 인스턴스를 만들어 사용할 수 있다.\n클래스 정의와 객체 생성 \n\nclass Car:\n    def __init__(self, brand, color):  # 생성자\n        self.brand = brand  # 속성\n        self.color = color\n\n    def drive(self):  # 메서드\n        print(f\"{self.color} {self.brand}가 주행 중입니다.\")\n\n# 객체 생성\ncar1 = Car(\"Hyundai\", \"Red\")  # Car 클래스의 인스턴스 생성\ncar2 = Car(\"Toyota\", \"Blue\")\n\n# 객체 사용\nprint(car1.brand)  # Hyundai 출력\nprint(car2.color)  # Blue 출력\n\ncar1.drive()  # \"Red Hyundai가 주행 중입니다.\" 출력\ncar2.drive()  # \"Blue Toyota가 주행 중입니다.\" 출력\n\nHyundai\nBlue\nRed Hyundai가 주행 중입니다.\nBlue Toyota가 주행 중입니다.\n\n\n\n\nself 키워드 이해\nself는 현재 인스턴스를 가리키는 변수이고, 메서드에서 self를 사용하여 인스턴스 변수에 접근할 수 있다.\n\nclass Person:\n    def __init__(self, name):\n        self.name = name  # self.name은 인스턴스 변수\n\n    def greet(self):\n        print(f\"안녕하세요, 저는 {self.name}입니다.\")\n\n# 객체 생성\np1 = Person(\"철수\")\np2 = Person(\"영희\")\n\n# 메서드 호출\np1.greet()  # \"안녕하세요, 저는 철수입니다.\" 출력\np2.greet()  # \"안녕하세요, 저는 영희입니다.\" 출력\n\n안녕하세요, 저는 철수입니다.\n안녕하세요, 저는 영희입니다.\n\n\n\n\n여러 개의 객체 생성 가능\n클래스를 한 번 정의하면 여러 개의 객체(인스턴스)를 생성할 수 있다.\n\nclass Animal:\n    def __init__(self, species, sound):\n        self.species = species\n        self.sound = sound\n\n    def make_sound(self):\n        print(f\"{self.species}가 '{self.sound}' 소리를 냅니다.\")\n\n# 객체 생성\ndog = Animal(\"강아지\", \"멍멍\")\ncat = Animal(\"고양이\", \"야옹\")\n\n# 메서드 호출\ndog.make_sound()  # \"강아지가 '멍멍' 소리를 냅니다.\" 출력\ncat.make_sound()  # \"고양이가 '야옹' 소리를 냅니다.\" 출력\n\n강아지가 '멍멍' 소리를 냅니다.\n고양이가 '야옹' 소리를 냅니다.",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>클래스</span>"
    ]
  },
  {
    "objectID": "80class.html#생성자와-소멸자",
    "href": "80class.html#생성자와-소멸자",
    "title": "클래스",
    "section": "생성자와 소멸자",
    "text": "생성자와 소멸자\n\n생성자와 소멸자\n\n\n\n\n\n\n\n개념\n설명\n예제\n\n\n\n\n생성자 (__init__)\n객체가 생성될 때 자동 실행\ncar1 = Car(\"Hyundai\", \"Red\")\n\n\n소멸자 (__del__)\n객체가 삭제될 때 자동 실행\ndel car1 또는 프로그램 종료 시\n\n\n\n\n생성자는 객체가 생성될 때 호출되며, 속성을 초기화하는 역할 수행\n\n소멸자는 객체가 삭제되거나 프로그램이 종료될 때 호출되며, 메모리에서 해제될 때 필요한 작업을 수행\n\n소멸자는 직접 호출하는 경우는 드물지만, 파일을 닫거나 리소스를 정리하는 용도로 활용될 수 있다.\n\n생성자 init()\n생성자(Constructor)는 객체가 생성될 때 자동으로 실행되는 특별한 메서드이다.\n\n__init__() 메서드를 사용하여 정의한다.\n\n객체의 속성을 초기화하는 역할을 한다.\n\n생성자 예제\n\nclass Car:\n    def __init__(self, brand, color):  # 생성자\n        self.brand = brand  # 속성 초기화\n        self.color = color\n        print(f\"{self.color} {self.brand} 자동차가 생성되었습니다.\")\n\n# 객체 생성\ncar1 = Car(\"Hyundai\", \"Red\")  \ncar2 = Car(\"Toyota\", \"Blue\")  \n\nRed Hyundai 자동차가 생성되었습니다.\nBlue Toyota 자동차가 생성되었습니다.\n\n\n\n\n소멸자 del()\n소멸자(Destructor)는 객체가 삭제될 때 자동으로 호출되는 특별한 메서드이다.\n\n__del__() 메서드를 사용하여 정의한다.\n\n객체가 메모리에서 제거될 때 수행할 동작을 정의할 수 있다.\n\n소멸자 예제\n\nclass Car:\n    def __init__(self, brand, color):\n        self.brand = brand\n        self.color = color\n        print(f\"{self.color} {self.brand} 자동차가 생성되었습니다.\")\n\n    def __del__(self):  # 소멸자\n        print(f\"{self.color} {self.brand} 자동차가 삭제되었습니다.\")\n\n# 객체 생성\ncar1 = Car(\"Hyundai\", \"Red\")  \ncar2 = Car(\"Toyota\", \"Blue\")  \n\n# 객체 삭제\ndel car1  \ndel car2  \n\nRed Hyundai 자동차가 생성되었습니다.\nBlue Toyota 자동차가 생성되었습니다.\nRed Hyundai 자동차가 삭제되었습니다.\nBlue Toyota 자동차가 삭제되었습니다.",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>클래스</span>"
    ]
  },
  {
    "objectID": "80class.html#클래스-변수와-인스턴스-변수",
    "href": "80class.html#클래스-변수와-인스턴스-변수",
    "title": "클래스",
    "section": "클래스 변수와 인스턴스 변수",
    "text": "클래스 변수와 인스턴스 변수\n\n클래스와 인스턴스 변수\n\n\n\n\n\n\n\n구분\n클래스 변수(Class Variable)\n인스턴스 변수(Instance Variable)\n\n\n\n\n정의 위치\n클래스 내부에서 self 없이 선언\n__init__() 내부에서 self.변수명 형태로 선언\n\n\n공유 여부\n모든 인스턴스가 공유\n각 인스턴스마다 독립적\n\n\n접근 방법\n클래스명.변수명 또는 self.변수명\nself.변수명\n\n\n변경 시 영향\n모든 인스턴스에 적용\n해당 인스턴스에만 적용\n\n\n\n클래스 변수는 공통 속성을 저장하는 데 사용하고, 인스턴스 변수는 개별 속성을 저장하는 데 사용하면 된다.\n\n클래스 변수와 인스턴스 변수\n\n클래스 변수와 인스턴스 변수 비교\n\n\n\n\n\n\n\n구분\n클래스 변수\n인스턴스 변수\n\n\n\n\n정의 위치\n클래스 내부, self 없이 선언\n클래스 내부, self를 사용하여 선언\n\n\n공유 여부\n모든 인스턴스가 공유\n각 인스턴스마다 개별적으로 존재\n\n\n접근 방법\n클래스명.변수명 또는 self.변수명\nself.변수명\n\n\n\n\n\n클래스 변수\n클래스 변수(Class Variable)는 모든 인스턴스가 공유하는 변수로 클래스 내부에서 self 없이 선언하며, 클래스명.변수명으로 접근할 수 있다.\n클래스 변수 예제\n\nclass Car:\n    wheels = 4  # 클래스 변수 (모든 자동차가 공유)\n\n    def __init__(self, brand, color):\n        self.brand = brand  # 인스턴스 변수\n        self.color = color\n\n# 객체 생성\ncar1 = Car(\"Hyundai\", \"Red\")\ncar2 = Car(\"Toyota\", \"Blue\")\n\n# 클래스 변수 접근\nprint(Car.wheels)   # 4 출력 (클래스 변수 직접 접근)\nprint(car1.wheels)  # 4 출력 (인스턴스를 통해 접근)\nprint(car2.wheels)  # 4 출력\n\n# 클래스 변수 변경\nCar.wheels = 6\nprint(car1.wheels)  # 6 출력\nprint(car2.wheels)  # 6 출력\n\n4\n4\n4\n6\n6\n\n\n\n\n인스턴스 변수\n인스턴스 변수(Instance Variable)는 각 객체(인스턴스)마다 독립적으로 존재하는 변수, self.변수명 형태로 선언하고 사용한다.\n인스턴스 변수 예제\n\nclass Car:\n    def __init__(self, brand, color):\n        self.brand = brand  # 인스턴스 변수\n        self.color = color\n\n# 객체 생성\ncar1 = Car(\"Hyundai\", \"Red\")\ncar2 = Car(\"Toyota\", \"Blue\")\n\n# 인스턴스 변수 접근\nprint(car1.brand)  # Hyundai 출력\nprint(car2.brand)  # Toyota 출력\n\n# 개별 인스턴스 변수 변경\ncar1.color = \"Black\"\nprint(car1.color)  # Black 출력\nprint(car2.color)  # Blue 출력 (car1과 독립적)\n\nHyundai\nToyota\nBlack\nBlue\n\n\n\n\n클래스 변수와 인스턴스 변수의 차이\n\nclass Animal:\n    species = \"Mammal\"  # 클래스 변수 (모든 인스턴스가 공유)\n\n    def __init__(self, name):\n        self.name = name  # 인스턴스 변수 (각 인스턴스마다 다름)\n\n# 객체 생성\ndog = Animal(\"Dog\")\ncat = Animal(\"Cat\")\n\n# 클래스 변수 접근\nprint(dog.species)  # Mammal 출력\nprint(cat.species)  # Mammal 출력\n\n# 인스턴스 변수 접근\nprint(dog.name)  # Dog 출력\nprint(cat.name)  # Cat 출력\n\n# 클래스 변수 변경 (모든 인스턴스에 영향)\nAnimal.species = \"Reptile\"\nprint(dog.species)  # Reptile 출력\nprint(cat.species)  # Reptile 출력\n\n# 인스턴스 변수 변경 (다른 인스턴스에 영향 없음)\ndog.name = \"Wolf\"\nprint(dog.name)  # Wolf 출력\nprint(cat.name)  # Cat 출력 (영향 없음)\n\nMammal\nMammal\nDog\nCat\nReptile\nReptile\nWolf\nCat",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>클래스</span>"
    ]
  },
  {
    "objectID": "80class.html#메서드의-종류",
    "href": "80class.html#메서드의-종류",
    "title": "클래스",
    "section": "메서드의 종류",
    "text": "메서드의 종류\n파이썬 클래스에는 인스턴스 메서드(Instance Method), 클래스 메서드(Class Method), 정적 메서드(Static Method)의 세 가지 종류가 있다.\n\n메서드 종류\n\n\n\n\n\n\n\n\n메서드 종류\n정의 방식\n첫 번째 매개변수\n주요 특징\n\n\n\n\n인스턴스 메서드\ndef method(self):\nself\n인스턴스 속성 및 메서드에 접근 가능\n\n\n클래스 메서드\n@classmethod 사용\ncls\n클래스 변수 및 메서드에 접근 가능\n\n\n정적 메서드\n@staticmethod 사용\n없음\n클래스, 인스턴스와 무관하게 독립적으로 실행\n\n\n\n\n메서드와 변수\n\n\n메서드 종류\nself 사용 여부\ncls 사용 여부\n접근 가능한 변수\n\n\n\n\n인스턴스 메서드\nO\nX\n인스턴스 변수, 클래스 변수\n\n\n클래스 메서드\nX\nO\n클래스 변수\n\n\n정적 메서드\nX\nX\n클래스 및 인스턴스와 무관\n\n\n\n각 메서드의 역할에 따라 적절히 활용하면 객체지향 프로그래밍(OOP)을 더욱 효율적으로 설계할 수 있다.\n\n인스턴스 메서드\nself 매개변수를 사용하여 인스턴스 변수 및 다른 인스턴스 메서드에 접근할 수 있다. 일반적인 메서드이며, 대부분의 메서드는 인스턴스 메서드로 작성된다.\n예제\n\nclass Car:\n    def __init__(self, brand, color):\n        self.brand = brand  # 인스턴스 변수\n        self.color = color  \n\n    def drive(self):  # 인스턴스 메서드\n        print(f\"{self.color} {self.brand}가 주행 중입니다.\")\n\n# 객체 생성\ncar1 = Car(\"Hyundai\", \"Red\")\n\n# 인스턴스 메서드 호출\ncar1.drive()  # Red Hyundai가 주행 중입니다.\n\nRed Hyundai가 주행 중입니다.\n\n\n\n\n클래스 메서드\n@classmethod 데코레이터를 사용하며, 첫 번째 매개변수로 cls를 받는다. 클래스 변수에 접근 가능하며, 클래스 레벨에서 동작하는 메서드이다.\n예제\n\nclass Car:\n    wheels = 4  # 클래스 변수\n\n    @classmethod\n    def set_wheels(cls, num):\n        cls.wheels = num  # 클래스 변수 변경\n        print(f\"모든 자동차의 바퀴 수가 {cls.wheels}로 변경되었습니다.\")\n\n# 클래스 메서드 호출\nCar.set_wheels(6)  # 모든 자동차의 바퀴 수가 6로 변경되었습니다.\n\n모든 자동차의 바퀴 수가 6로 변경되었습니다.\n\n\n\n클래스 변수 wheels를 수정할 수 있으며, 모든 인스턴스에 영향을 줌\n\n\n\n정적 메서드\n@staticmethod 데코레이터를 사용하며, 클래스나 인스턴스와 관계없이 독립적으로 동작한다. self나 cls를 사용하지 않으며, 일반적으로 단순한 유틸리티 기능을 제공할 때 사용한다.\n예제\n\nclass Car:\n    @staticmethod\n    def general_info():\n        print(\"자동차는 도로에서 운행되는 일반적인 교통수단입니다.\")\n\n# 정적 메서드 호출\nCar.general_info()  # 자동차는 도로에서 운행되는 일반적인 교통수단입니다.\n\n자동차는 도로에서 운행되는 일반적인 교통수단입니다.\n\n\n\n인스턴스나 클래스 변수를 사용하지 않으므로 독립적인 기능을 수행함\n\n메서드 비교 예제\n\nclass Example:\n    class_var = \"클래스 변수\"\n\n    def __init__(self, value):\n        self.instance_var = value  # 인스턴스 변수\n\n    def instance_method(self):  # 인스턴스 메서드\n        print(f\"인스턴스 변수: {self.instance_var}\")\n\n    @classmethod\n    def class_method(cls):  # 클래스 메서드\n        print(f\"클래스 변수: {cls.class_var}\")\n\n    @staticmethod\n    def static_method():  # 정적 메서드\n        print(\"정적 메서드 실행\")\n\n# 객체 생성\nobj = Example(\"Hello\")\n\n# 메서드 호출\nobj.instance_method()  # 인스턴스 변수: Hello\nExample.class_method()  # 클래스 변수: 클래스 변수\nExample.static_method()  # 정적 메서드 실행\n\n인스턴스 변수: Hello\n클래스 변수: 클래스 변수\n정적 메서드 실행",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>클래스</span>"
    ]
  },
  {
    "objectID": "80class.html#접근-제어자와-캡슐화",
    "href": "80class.html#접근-제어자와-캡슐화",
    "title": "클래스",
    "section": "접근 제어자와 캡슐화",
    "text": "접근 제어자와 캡슐화\n접근 제어자(Access Modifier)는 접근 수준에 따라 Public, Protected, Private으로 나뉜다.\n\n접근 제어자\n\n\n\n\n\n\n\n\n접근 수준\n사용 방법\n외부 접근 가능 여부\n활용\n\n\n\n\nPublic\n변수명\nO\n일반적인 속성 및 메서드\n\n\nProtected\n_변수명\nO (권장 X)\n내부적 용도 또는 상속 클래스에서 사용\n\n\nPrivate\n__변수명\nX\n데이터 보호 및 보안 강화\n\n\n\n캡슐화(Encapsulation)를 통해 중요한 데이터를 보호하고, getter와 setter를 활용하면 보다 안전한 객체지향 프로그래밍이 가능하다.\n\n접근 제어자\n파이썬에서 클래스의 속성과 메서드는 접근 수준을 설정할 수 있으며, 접근 제어자는 다음과 같이 구분된다.\n\n접근 제어자 접근 수준\n\n\n\n\n\n\n\n\n접근 제어자\n기호\n접근 가능 범위\n특징\n\n\n\n\n공개(Public)\n변수명\n어디서든 접근 가능\n기본적으로 모든 속성과 메서드는 public\n\n\n보호(Protected)\n_변수명\n클래스 내부 및 상속받은 클래스에서 접근 가능\n암묵적인 규칙으로, 강제적인 제한은 없음\n\n\n비공개(Private)\n__변수명\n클래스 내부에서만 접근 가능\n이름이 변경되어 _클래스명__변수명 형태로 변환됨\n\n\n\n\n\n캡슐화\n캡슐화는 객체의 속성(데이터)을 외부에서 직접 접근하지 못하도록 보호하는 개념으로 데이터를 숨기고(private), 메서드를 통해 안전하게 접근하도록 하는 방식이다.\n접근 제어자 예제\n\nclass Person:\n    def __init__(self, name, age):\n        self.name = name        # 공개(Public)\n        self._age = age         # 보호(Protected)\n        self.__password = \"1234\"  # 비공개(Private)\n\n    def display_info(self):\n        print(f\"이름: {self.name}, 나이: {self._age}\")\n\n    def __get_password(self):  # 비공개 메서드\n        return self.__password\n\n# 객체 생성\np = Person(\"Alice\", 30)\n\n# Public 변수 접근 (가능)\nprint(p.name)  # Alice 출력\n\n# Protected 변수 접근 (가능하지만 권장되지 않음)\nprint(p._age)  # 30 출력\n\n# Private 변수 접근 (불가능)\n# print(p.__password)  # AttributeError 발생\n\n# Private 변수는 아래처럼 접근 가능 (권장되지 않음)\nprint(p._Person__password)  # 1234 출력\n\nAlice\n30\n1234\n\n\n\nPublic 속성은 외부에서 자유롭게 접근 가능\n\nProtected 속성은 _로 시작하며, 관례적으로 내부에서만 사용 (접근 가능하지만 직접 사용은 지양)\n\nPrivate 속성은 __로 시작하며, 외부에서 직접 접근 불가능 (_클래스명__변수명으로 접근 가능)\n\n\n\n캡슐화를 활용한 Getter / Setter\n비공개 속성(private)에 접근하려면 Getter와 Setter 메서드를 사용해야 한다.\n\nclass BankAccount:\n    def __init__(self, owner, balance):\n        self.owner = owner\n        self.__balance = balance  # Private 변수\n\n    def get_balance(self):  # Getter\n        return self.__balance\n\n    def set_balance(self, amount):  # Setter\n        if amount &gt;= 0:\n            self.__balance = amount\n        else:\n            print(\"잔액은 음수가 될 수 없습니다.\")\n\n# 객체 생성\naccount = BankAccount(\"Alice\", 1000)\n\n# Getter 사용\nprint(account.get_balance())  # 1000 출력\n\n# Setter 사용\naccount.set_balance(2000)\nprint(account.get_balance())  # 2000 출력\n\n# 직접 접근 불가\n# print(account.__balance)  # AttributeError 발생\n\n1000\n2000",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>클래스</span>"
    ]
  },
  {
    "objectID": "80class.html#상속-개념과-활용",
    "href": "80class.html#상속-개념과-활용",
    "title": "클래스",
    "section": "상속 개념과 활용",
    "text": "상속 개념과 활용\n상속(Inheritance)은 부모 클래스 속성과 메서드를 자식 클래스가 사용할 수 있도록 하는 방법이다.\n\n상속 개념\n\n\n\n\n\n\n개념\n설명\n\n\n\n\n단일 상속\n하나의 부모 클래스를 상속\n\n\n다중 상속\n여러 개의 부모 클래스를 상속\n\n\n메서드 오버라이딩\n부모 클래스의 메서드를 자식 클래스에서 재정의\n\n\nsuper()\n부모 클래스의 메서드를 호출할 때 사용\n\n\n\n상속은 코드의 재사용성과 유지보수성을 높이지만, 불필요한 상속은 코드 복잡성을 증가시킬 수 있으므로 신중하게 설계해야 한다.\n\n상속 개념\n상속은 기존 클래스(부모 클래스, superclass)의 속성과 메서드를 새로운 클래스(자식 클래스, subclass)가 물려받아 사용할 수 있도록 하는 개념으로 코드의 재사용성을 높이고, 클래스 간의 관계를 구조화할 수 있다.\n\n\n상속 기본 문법\nclass 부모클래스:\n    # 부모 클래스 정의\n\nclass 자식클래스(부모클래스):\n    # 부모 클래스를 상속받은 자식 클래스 정의\n상속 기본 예제\n\n# 부모 클래스 정의\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n\n    def speak(self):\n        print(\"동물이 소리를 냅니다.\")\n\n# 자식 클래스 (Animal을 상속)\nclass Dog(Animal):\n    def speak(self):  # 메서드 오버라이딩 (재정의)\n        print(f\"{self.name}가 멍멍 짖습니다.\")\n\n# 객체 생성\ndog = Dog(\"바둑이\")\ndog.speak()  # 바둑이가 멍멍 짖습니다.\n\n바둑이가 멍멍 짖습니다.\n\n\n\nDog 클래스는 Animal 클래스를 상속받아 name 속성과 speak() 메서드를 그대로 사용 가능\n\nspeak() 메서드는 자식 클래스에서 재정의(오버라이딩, overriding) 가능\n\n\n\nsuper()를 사용한 부모 클래스 접근\nsuper()를 사용하면 부모 클래스의 메서드를 자식 클래스에서 호출 가능하다.\n\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n\n    def speak(self):\n        print(\"동물이 소리를 냅니다.\")\n\nclass Dog(Animal):\n    def __init__(self, name, breed):\n        super().__init__(name)  # 부모 클래스의 __init__() 호출\n        self.breed = breed\n\n    def speak(self):\n        super().speak()  # 부모 클래스의 speak() 호출\n        print(f\"{self.name}가 멍멍 짖습니다.\")\n\n# 객체 생성\ndog = Dog(\"바둑이\", \"진돗개\")\ndog.speak()\n\n동물이 소리를 냅니다.\n바둑이가 멍멍 짖습니다.\n\n\n\n\n다중 상속\n파이썬에서는 여러 개의 부모 클래스를 동시에 상속(Multiple Inheritance)받을 수 있다. 다중 상속 시 MRO(Method Resolution Order, 메서드 탐색 순서)가 적용된다.\n\nclass A:\n    def method_a(self):\n        print(\"A 클래스의 메서드\")\n\nclass B:\n    def method_b(self):\n        print(\"B 클래스의 메서드\")\n\nclass C(A, B):  # A와 B를 동시에 상속\n    def method_c(self):\n        print(\"C 클래스의 메서드\")\n\n# 객체 생성\nobj = C()\nobj.method_a()  # A 클래스의 메서드\nobj.method_b()  # B 클래스의 메서드\nobj.method_c()  # C 클래스의 메서드\n\nA 클래스의 메서드\nB 클래스의 메서드\nC 클래스의 메서드\n\n\n\n\n메서드 오버라이딩과 오버로딩\n\n오버라이딩과 오버로딩\n\n\n\n\n\n\n\n개념\n설명\n예제\n\n\n\n\n오버라이딩 (Overriding)\n부모 클래스의 메서드를 자식 클래스에서 재정의\nspeak() 메서드 재정의\n\n\n오버로딩 (Overloading)\n동일한 메서드명을 가지되 매개변수가 다름\n파이썬에서는 직접 지원하지 않지만, 기본값을 설정하여 구현 가능\n\n\n\n\nclass Parent:\n    def show(self):\n        print(\"부모 클래스의 메서드\")\n\nclass Child(Parent):\n    def show(self):  # 오버라이딩\n        print(\"자식 클래스에서 오버라이딩한 메서드\")\n\nobj = Child()\nobj.show()  # 자식 클래스에서 오버라이딩한 메서드\n\n자식 클래스에서 오버라이딩한 메서드\n\n\n\n\n상속 활용 예제\n은행 시스템 예제\n\nclass BankAccount:\n    def __init__(self, owner, balance):\n        self.owner = owner\n        self.balance = balance\n\n    def deposit(self, amount):\n        self.balance += amount\n        print(f\"{amount}원 입금되었습니다. 현재 잔액: {self.balance}원\")\n\n    def withdraw(self, amount):\n        if self.balance &gt;= amount:\n            self.balance -= amount\n            print(f\"{amount}원 출금되었습니다. 현재 잔액: {self.balance}원\")\n        else:\n            print(\"잔액이 부족합니다.\")\n\n# 자식 클래스 (이자 기능 추가)\nclass SavingsAccount(BankAccount):\n    def __init__(self, owner, balance, interest_rate):\n        super().__init__(owner, balance)\n        self.interest_rate = interest_rate\n\n    def add_interest(self):\n        interest = self.balance * self.interest_rate\n        self.balance += interest\n        print(f\"이자 {interest}원이 추가되었습니다. 현재 잔액: {self.balance}원\")\n\n# 객체 생성\naccount = SavingsAccount(\"홍길동\", 10000, 0.05)\naccount.deposit(5000)   # 5000원 입금\naccount.add_interest()  # 이자 추가\naccount.withdraw(3000)  # 3000원 출금\n\n5000원 입금되었습니다. 현재 잔액: 15000원\n이자 750.0원이 추가되었습니다. 현재 잔액: 15750.0원\n3000원 출금되었습니다. 현재 잔액: 12750.0원\n\n\n\n\n상속 장점과 단점\n\n상속 장점과 단점\n\n\n\n\n\n\n장점\n단점\n\n\n\n\n코드 재사용성이 높아짐\n다중 상속 시 복잡성이 증가\n\n\n유지보수성이 향상됨\n부모 클래스가 변경되면 자식 클래스도 영향을 받을 수 있음\n\n\n코드 중복을 줄일 수 있음\n잘못된 설계 시 불필요한 상속이 발생할 수 있음\n\n\n\n\n\n상속과 캡슐화 결합\n상속을 사용할 때는 캡슐화(Private, Protected 변수)와 함께 활용하여 데이터 보호를 강화할 수 있다.\n\nclass Parent:\n    def __init__(self):\n        self._protected_var = \"보호된 변수\"  # Protected\n        self.__private_var = \"비공개 변수\"  # Private\n\n    def get_private_var(self):\n        return self.__private_var  # Getter 메서드\n\nclass Child(Parent):\n    def show_vars(self):\n        print(self._protected_var)  # 접근 가능\n        # print(self.__private_var)  # 접근 불가 (AttributeError 발생)\n        print(self.get_private_var())  # Getter를 통해 접근 가능\n\nobj = Child()\nobj.show_vars()\n\n보호된 변수\n비공개 변수",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>클래스</span>"
    ]
  },
  {
    "objectID": "80class.html#다형성과-추상-클래스",
    "href": "80class.html#다형성과-추상-클래스",
    "title": "클래스",
    "section": "다형성과 추상 클래스",
    "text": "다형성과 추상 클래스\n다형성을 사용하면 동일한 메서드가 여러 객체에서 다르게 동작할 수 있다. 추상 클래스는 자식 클래스가 공통된 메서드를 구현하도록 강제하며, 구체적인 동작은 자식 클래스에 위임한다. 다형성과 추상 클래스를 결합하면 유연하고 확장 가능한 코드를 작성할 수 있다.\n\n다형성 개념\n다형성(Polymorphism)은 동일한 이름의 메서드나 함수가 여러 다른 방식으로 동작할 수 있게 하는 개념이다. 객체 지향 프로그래밍에서 다양한 객체들이 동일한 인터페이스(메서드)를 통해 서로 다른 동작을 수행할 수 있도록 한다. 메서드 오버라이딩(Method Overriding)과 메서드 오버로딩(Method Overloading)이 다형성의 주요 기법이다.\n\n메서드 오버라이딩 (Method Overriding)\n\n\n부모 클래스의 메서드를 자식 클래스에서 재정의하여, 자식 클래스 객체가 호출할 때 다른 동작을 할 수 있도록 한다.\n\n\n메서드 오버로딩 (Method Overloading)\n\n\n동일한 이름의 메서드를 다양한 매개변수로 정의하는 방식이다. 하지만, 파이썬은 메서드 오버로딩을 기본적으로 지원하지 않으므로, 보통 기본값 인수나 가변 인수를 사용하여 구현한다.\n\n\n\n다형성 예제 (Method Overriding)\n\nclass Animal:\n    def speak(self):\n        print(\"동물이 소리를 냅니다.\")\n\nclass Dog(Animal):\n    def speak(self):  # 메서드 오버라이딩\n        print(\"멍멍!\")\n\nclass Cat(Animal):\n    def speak(self):  # 메서드 오버라이딩\n        print(\"야옹!\")\n\n# 객체 생성\nanimals = [Dog(), Cat()]\n\n# 다형성: 동일한 인터페이스(speak())지만 각기 다른 동작을 함\nfor animal in animals:\n    animal.speak()\n\n멍멍!\n야옹!\n\n\n\nDog와 Cat 객체가 각각 speak() 메서드를 오버라이딩하여 각기 다른 방식으로 동작함.\n\n\n\n추상 클래스 개념\n추상 클래스(Abstract Class)는 직접 인스턴스를 생성할 수 없고, 자식 클래스에서 반드시 구현해야 하는 메서드를 정의하는 클래스이다. 추상 메서드를 포함하고 있으며, 자식 클래스에서 이를 구현(Override)하도록 강제한다. 추상 클래스는 abc 모듈을 사용하여 정의할 수 있다.\n\n추상 클래스 사용 이유\n\n\n공통된 인터페이스를 강제하고, 구체적인 구현은 자식 클래스에 맡겨 구현의 일관성을 유지할 수 있다.\n여러 클래스에서 공통적으로 구현해야 하는 메서드를 정의하고, 이를 자식 클래스에서 구체화하도록 한다.\n\n\n\n추상 클래스 예제\n\nfrom abc import ABC, abstractmethod\n\n# 추상 클래스 정의\nclass Animal(ABC):\n    @abstractmethod\n    def speak(self):  # 추상 메서드\n        pass\n\nclass Dog(Animal):\n    def speak(self):  # 추상 메서드 구현\n        print(\"멍멍!\")\n\nclass Cat(Animal):\n    def speak(self):  # 추상 메서드 구현\n        print(\"야옹!\")\n\n# 객체 생성\ndog = Dog()\ncat = Cat()\n\n# 추상 클래스의 메서드를 자식 클래스에서 구현해야 하므로 오류가 발생하지 않음\ndog.speak()  # 멍멍!\ncat.speak()  # 야옹!\n\n멍멍!\n야옹!\n\n\n\nAnimal 클래스는 추상 클래스로 정의되어 있고, speak() 메서드는 자식 클래스에서 반드시 구현해야 한다.\n\nDog와 Cat 클래스에서 speak() 메서드를 구현하여 오류 없이 동작한다.\n\n\n\n추상 클래스와 인스턴스화\n추상 클래스는 직접 인스턴스화할 수 없다.\n\n# 직접 인스턴스를 생성할 수 없음\nanimal = Animal()  # TypeError 발생: Can't instantiate abstract class Animal with abstract methods speak\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[26], line 2\n      1 # 직접 인스턴스를 생성할 수 없음\n----&gt; 2 animal = Animal()  # TypeError 발생: Can't instantiate abstract class Animal with abstract methods speak\n\nTypeError: Can't instantiate abstract class Animal with abstract method speak\n\n\n\n\n추상 클래스는 인스턴스를 생성할 수 없고, 반드시 이를 상속받은 자식 클래스에서 구체적인 구현을 해야만 인스턴스를 생성하고 사용할 수 있음\n\n\n\n다형성과 추상 클래스의 결합\n다형성을 활용하여 추상 클래스를 공통된 인터페이스로 사용하고, 구체적인 구현은 자식 클래스에서 제공하도록 할 수 있다.\n\nfrom abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):\n        pass\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n    \n    def area(self):\n        return 3.14 * self.radius * self.radius\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n\n# 객체 생성\nshapes = [Circle(5), Rectangle(4, 6)]\n\n# 다형성을 통한 추상 클래스 메서드 호출\nfor shape in shapes:\n    print(shape.area())\n\n78.5\n24\n\n\n\nShape는 추상 클래스로 정의되고, Circle과 Rectangle 클래스에서 area() 메서드를 구체화함.\nshapes 리스트에서 Circle과 Rectangle 객체들을 다루며, 다형성을 통해 동일한 인터페이스로 각기 다른 방식으로 area() 메서드를 호출\n\n\n\n다형성, 추상 클래스, 상속 결합\n\n다형성, 추상클래스, 상속\n\n\n\n\n\n\n\n개념\n설명\n예시\n\n\n\n\n다형성\n같은 이름의 메서드가 객체의 종류에 따라 다르게 동작\nspeak() 메서드\n\n\n추상 클래스\n자식 클래스에 공통적인 인터페이스를 강제, 직접 인스턴스화 불가\nAnimal 추상 클래스\n\n\n상속\n부모 클래스에서 자식 클래스가 속성이나 메서드를 물려받음\nDog, Cat 클래스",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>클래스</span>"
    ]
  },
  {
    "objectID": "80class.html#연산자-오버로딩",
    "href": "80class.html#연산자-오버로딩",
    "title": "클래스",
    "section": "연산자 오버로딩",
    "text": "연산자 오버로딩\n연산자 오버로딩(Operator Overloading)은 객체 지향 프로그래밍에서 연산자를 커스터마이즈하여 클래스에 맞게 동작하게 만드는 기법이다. 이를 통해 직관적이고 유연한 객체 연산이 가능하지만, 과용하면 코드의 가독성과 유지보수성에 문제가 될 수 있다.\n\n연산자 오버로딩 개념\n연산자 오버로딩은 기존의 연산자가 클래스에 대해 새로운 의미로 동작하도록 만드는 기능이다. 기본 연산자(예: +, -, *, ==)의 동작 방식을 사용자가 정의한 클래스에 맞게 재정의할 수 있다. 이를 통해 자체적으로 정의한 객체들 간의 연산을 직관적으로 사용할 수 있게 된다.\n\n\n연산자 오버로딩의 예시\n파이썬에서는 연산자에 해당하는 특수 메서드(매직 메서드)를 정의함으로써 연산자 오버로딩을 구현한다. 예를 들어, + 연산자는 __add__() 메서드를 통해 오버로딩할 수 있다.\n\n주요 연산자 오버로딩 메서드\n\n\n연산자\n메서드\n\n\n\n\n+\n__add__(self, other)\n\n\n-\n__sub__(self, other)\n\n\n*\n__mul__(self, other)\n\n\n/\n__truediv__(self, other)\n\n\n==\n__eq__(self, other)\n\n\n!=\n__ne__(self, other)\n\n\n&lt;\n__lt__(self, other)\n\n\n&gt;\n__gt__(self, other)\n\n\n\n\n\n연산자 오버로딩 예제\n+ 연산자 오버로딩 예제\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):  # + 연산자 오버로딩\n        return Point(self.x + other.x, self.y + other.y)\n\n    def __str__(self):  # 출력 형식 지정\n        return f\"({self.x}, {self.y})\"\n\n# 객체 생성\npoint1 = Point(1, 2)\npoint2 = Point(3, 4)\n\n# + 연산자를 사용하여 두 점을 더하기\nresult = point1 + point2\nprint(result)  # (4, 6)\n\n(4, 6)\n\n\n\n__add__() 메서드는 두 Point 객체의 x와 y 좌표를 더하여 새로운 Point 객체를 반환\n이처럼 + 연산자를 오버로딩하면, 두 객체 간에 더하기 연산을 직관적으로 사용\n\n== 연산자 오버로딩 예제\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __eq__(self, other):  # == 연산자 오버로딩\n        return self.x == other.x and self.y == other.y\n\n    def __str__(self):\n        return f\"({self.x}, {self.y})\"\n\n# 객체 생성\npoint1 = Point(1, 2)\npoint2 = Point(1, 2)\npoint3 = Point(3, 4)\n\n# == 연산자 사용\nprint(point1 == point2)  # True\nprint(point1 == point3)  # False\n\nTrue\nFalse\n\n\n\n__eq__() 메서드를 오버로딩하여 두 Point 객체가 같은지 비교\n\n\n\n다양한 연산자 오버로딩 예제\n\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    # + 연산자 오버로딩\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n\n    # * 연산자 오버로딩 (스칼라 곱)\n    def __mul__(self, scalar):\n        return Vector(self.x * scalar, self.y * scalar)\n\n    # == 연산자 오버로딩\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def __str__(self):\n        return f\"({self.x}, {self.y})\"\n\n# 객체 생성\nv1 = Vector(2, 3)\nv2 = Vector(1, 1)\n\n# 연산자 사용\nv3 = v1 + v2  # Vector(3, 4)\nv4 = v1 * 3   # Vector(6, 9)\nprint(v3)  # (3, 4)\nprint(v4)  # (6, 9)\nprint(v1 == v2)  # False\n\n(3, 4)\n(6, 9)\nFalse\n\n\n\n+, *, == 연산자를 오버로딩하여 Vector 객체에 대해 벡터 덧셈, 스칼라 곱, 비교 연산 가능\n\n\n\n연산자 오버로딩 시 주의사항\n연산자 오버로딩을 너무 남용하면 코드의 가독성이 떨어질 수 있다. 연산자 오버로딩을 사용한 코드가 직관적이어야 한다. 기본 연산자들의 의미를 지나치게 변경하면 예상치 못한 동작을 할 수 있으므로, 명확한 목적을 가지고 오버로딩을 활용하는 것이 중요하다.\n\n\n연산자 오버로딩 장단점\n\n연산자 오버로딩 장점과 단점\n\n\n\n\n\n\n장점\n단점\n\n\n\n\n객체 간의 직관적이고 간결한 연산을 가능하게 한다.\n연산자 오버로딩이 지나치면 코드의 직관성이 떨어질 수 있다.\n\n\n객체의 구체적인 동작을 추상화할 수 있어 코드의 가독성을 높일 수 있다.\n각 연산자의 의미가 명확히 정의되지 않으면, 의도치 않은 오류가 발생할 수 있다.",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>클래스</span>"
    ]
  },
  {
    "objectID": "80class.html#클래스-활용-및-실전-예제",
    "href": "80class.html#클래스-활용-및-실전-예제",
    "title": "클래스",
    "section": "클래스 활용 및 실전 예제",
    "text": "클래스 활용 및 실전 예제\n\n클래스 활용 개념\n클래스는 객체 지향 프로그래밍(OOP)에서 중요한 개념으로, 데이터와 이를 처리하는 메서드를 하나의 단위로 묶을 수 있다. 이를 통해 재사용성, 확장성, 유지보수 용이성 등의 장점이 생긴다. 클래스는 특히 복잡한 시스템을 개발할 때 코드를 모듈화하고, 구체화하는 데 큰 도움이 된다.\n\n\n클래스 활용 중요성\n클래스 활용 중요성은 다음과 같다.\n\n코드 재사용: 동일한 구조를 가진 여러 객체를 만들 때 클래스는 코드의 재사용을 가능하게 한다.\n추상화: 현실 세계의 복잡한 객체를 단순화하여 중요한 정보만을 다룰 수 있게 한다.\n캡슐화: 데이터를 하나로 묶어 내부 구현을 숨기고, 외부와의 인터페이스만을 제공한다.\n상속과 다형성: 부모 클래스의 기능을 자식 클래스에 물려주어, 기존 코드를 수정하지 않고 새로운 기능을 추가할 수 있다.\n\n\n\n실전 예제 1: 은행 계좌 관리 시스템\n목표: 은행 계좌를 클래스화하여 입금, 출금, 잔액 조회 등의 기능을 구현.\n\nclass BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner  # 계좌 소유자\n        self.balance = balance  # 계좌 잔액\n\n    def deposit(self, amount):\n        \"\"\"입금 메서드\"\"\"\n        if amount &gt; 0:\n            self.balance += amount\n            print(f\"입금액: {amount}, 현재 잔액: {self.balance}\")\n        else:\n            print(\"입금액은 0보다 커야 합니다.\")\n\n    def withdraw(self, amount):\n        \"\"\"출금 메서드\"\"\"\n        if amount &gt; 0 and amount &lt;= self.balance:\n            self.balance -= amount\n            print(f\"출금액: {amount}, 현재 잔액: {self.balance}\")\n        else:\n            print(\"출금액이 부적합합니다.\")\n\n    def get_balance(self):\n        \"\"\"잔액 조회 메서드\"\"\"\n        return self.balance\n\n# 계좌 객체 생성\naccount1 = BankAccount(\"김철수\", 1000)\n\n# 입금, 출금, 잔액 조회\naccount1.deposit(500)\naccount1.withdraw(200)\nprint(f\"최종 잔액: {account1.get_balance()}\")\n\n입금액: 500, 현재 잔액: 1500\n출금액: 200, 현재 잔액: 1300\n최종 잔액: 1300\n\n\n\nBankAccount 클래스는 은행 계좌의 기본적인 기능인 입금, 출금, 잔액 조회를 구현\n입금, 출금은 조건을 통해 올바른 금액만 처리\n__init__() 메서드를 통해 초기값인 계좌 소유자와 잔액을 설정\n\n\n\n실전 예제 2: 쇼핑몰 제품 관리 시스템\n목표: 제품을 관리하는 클래스를 작성하고, 제품 정보 등록 및 가격 변경 기능을 구현\n\nclass Product:\n    def __init__(self, name, price, stock):\n        self.name = name  # 제품명\n        self.price = price  # 가격\n        self.stock = stock  # 재고\n\n    def update_price(self, new_price):\n        \"\"\"가격 변경 메서드\"\"\"\n        self.price = new_price\n        print(f\"{self.name}의 가격이 {new_price}로 변경되었습니다.\")\n\n    def update_stock(self, amount):\n        \"\"\"재고 업데이트 메서드\"\"\"\n        self.stock += amount\n        print(f\"{self.name}의 재고가 {self.stock}개로 변경되었습니다.\")\n\n    def product_info(self):\n        \"\"\"제품 정보 출력 메서드\"\"\"\n        return f\"제품명: {self.name}, 가격: {self.price}, 재고: {self.stock}\"\n\n# 제품 객체 생성\nproduct1 = Product(\"노트북\", 1000000, 10)\nproduct2 = Product(\"스마트폰\", 800000, 20)\n\n# 제품 정보 출력\nprint(product1.product_info())\nprint(product2.product_info())\n\n# 가격 및 재고 변경\nproduct1.update_price(950000)\nproduct2.update_stock(5)\n\n제품명: 노트북, 가격: 1000000, 재고: 10\n제품명: 스마트폰, 가격: 800000, 재고: 20\n노트북의 가격이 950000로 변경되었습니다.\n스마트폰의 재고가 25개로 변경되었습니다.\n\n\n\nProduct 클래스는 제품명, 가격, 재고를 속성으로 가짐\n가격과 재고 변경은 update_price()와 update_stock() 메서드를 통해 수행\n제품 정보 출력 메서드를 통해 제품 정보를 쉽게 확인 가능\n\n\n\n실전 예제 3: 학생 성적 관리 시스템\n목표: 학생의 성적을 관리하고, 평균 성적을 계산하는 클래스를 작성\n\nclass Student:\n    def __init__(self, name, grades):\n        self.name = name  # 학생 이름\n        self.grades = grades  # 성적 리스트\n\n    def add_grade(self, grade):\n        \"\"\"성적 추가 메서드\"\"\"\n        self.grades.append(grade)\n\n    def average_grade(self):\n        \"\"\"평균 성적 계산 메서드\"\"\"\n        return sum(self.grades) / len(self.grades) if self.grades else 0\n\n    def student_info(self):\n        \"\"\"학생 정보 및 성적 출력 메서드\"\"\"\n        return f\"학생명: {self.name}, 성적: {self.grades}, 평균 성적: {self.average_grade():.2f}\"\n\n# 학생 객체 생성\nstudent1 = Student(\"홍길동\", [85, 90, 78])\nstudent2 = Student(\"김유진\", [92, 88, 95])\n\n# 학생 정보 출력\nprint(student1.student_info())\nprint(student2.student_info())\n\n# 성적 추가 및 정보 갱신\nstudent1.add_grade(80)\nprint(student1.student_info())\n\n학생명: 홍길동, 성적: [85, 90, 78], 평균 성적: 84.33\n학생명: 김유진, 성적: [92, 88, 95], 평균 성적: 91.67\n학생명: 홍길동, 성적: [85, 90, 78, 80], 평균 성적: 83.25\n\n\n\nStudent 클래스는 학생의 이름과 성적 리스트를 속성으로 가짐\n성적을 추가할 수 있는 add_grade() 메서드와, 평균 성적을 계산하는 average_grade() 메서드를 제공\n\n\n\n클래스 활용 시 주의사항\n클래스 활용 시 주의사항은 다음과 같다.\n\n책임 분리: 클래스는 하나의 책임만 가지도록 설계하는 것이 좋다. 여러 가지 기능이 혼합되면 유지보수와 확장이 어려워진다.\n적절한 추상화: 클래스는 필요한 정보를 추상화하여 복잡성을 줄이고, 객체들 간의 상호작용을 단순화해야 한다.\n상속과 다형성 활용: 공통된 기능을 부모 클래스에 정의하고, 상속을 통해 자식 클래스에서 기능을 확장할 수 있다.",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>클래스</span>"
    ]
  },
  {
    "objectID": "90library.html",
    "href": "90library.html",
    "title": "패키지",
    "section": "",
    "text": "파이썬에서 사용하는 주요 패키지\n이 외에도 파이썬에는 다양한 패키지가 있어, 특정 용도에 맞는 패키지를 선택하여 활용할 수 있다.",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>패키지</span>"
    ]
  },
  {
    "objectID": "90library.html#파이썬에서-사용하는-주요-패키지",
    "href": "90library.html#파이썬에서-사용하는-주요-패키지",
    "title": "패키지",
    "section": "",
    "text": "패키지\n설명\n\n\n\n\nNumPy\n수치 계산을 위한 패키지로, 다차원 배열 객체인 ndarray를 제공하며, 고속의 배열 연산을 지원한다. 과학 및 수학 연산에서 필수적인 패키지다.\n\n\nPandas\n데이터 분석을 위한 패키지로, DataFrame과 Series와 같은 자료구조를 사용해 데이터를 효율적으로 처리하고 분석할 수 있다. 데이터 정제와 탐색에 유용하다.\n\n\nMatplotlib\n데이터 시각화를 위한 패키지로, 다양한 종류의 그래프(라인, 막대, 히스토그램 등)를 그릴 수 있다. 데이터 분석 결과를 시각적으로 표현할 때 사용된다.\n\n\nSeaborn\nMatplotlib을 기반으로 하는 시각화 패키지로, 통계적 시각화와 복잡한 그래프를 간편하게 만들 수 있다. 데이터 분포 및 관계를 시각화하는 데 유용하다.\n\n\nSciPy\n과학적 계산을 위한 패키지로, 수학, 공학, 통계, 신호 처리 등을 위한 여러 기능을 제공한다. NumPy의 기능을 확장하는 역할을 한다.\n\n\nScikit-learn\n기계 학습을 위한 패키지로, 분류, 회귀, 클러스터링 등 다양한 모델을 손쉽게 사용할 수 있게 해준다. 데이터 전처리와 모델 평가 기능도 제공한다.\n\n\nTensorFlow\n딥러닝을 위한 오픈소스 라이브러리로, 신경망 모델을 구현하고 학습시킬 수 있는 강력한 기능을 제공한다. 구글에서 개발하였다.\n\n\nKeras\n딥러닝 모델을 빠르게 설계하고 학습시킬 수 있는 고수준 API로, TensorFlow 위에서 작동한다. 간단한 인터페이스로 딥러닝을 쉽게 다룰 수 있다.\n\n\nFlask\n웹 개발을 위한 마이크로 웹 프레임워크로, 간단한 API 서버를 구축할 때 사용된다. 경량화된 구조로 빠르게 웹 애플리케이션을 만들 수 있다.\n\n\nDjango\n웹 개발을 위한 풀스택 웹 프레임워크로, 강력한 ORM, 인증, 관리자 인터페이스 등을 제공하며 대규모 웹 애플리케이션 개발에 유용하다.\n\n\nRequests\nHTTP 요청을 처리하는 간단한 라이브러리로, REST API와의 통신 시 자주 사용된다. URL 요청, 응답 처리 등을 쉽게 할 수 있다.\n\n\nBeautifulSoup\n웹 스크래핑을 위한 패키지로, HTML 및 XML 문서를 파싱하고, 데이터를 추출하는 데 사용된다. 웹 페이지에서 정보를 쉽게 가져올 수 있다.\n\n\nOpenCV\n컴퓨터 비전을 위한 라이브러리로, 이미지 및 비디오 처리, 객체 인식, 얼굴 인식 등 다양한 기능을 제공한다.\n\n\nSQLAlchemy\n데이터베이스 ORM 라이브러리로, 관계형 데이터베이스와 객체지향 프로그래밍을 연결해주는 도구이다. SQL을 객체처럼 다룰 수 있다.\n\n\nPillow\n이미지 처리를 위한 패키지로, 다양한 이미지 파일 형식을 읽고 쓰며, 이미지 편집 작업(자르기, 회전, 크기 조정 등)을 할 수 있다.",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>패키지</span>"
    ]
  },
  {
    "objectID": "90library.html#패키지-검색",
    "href": "90library.html#패키지-검색",
    "title": "패키지",
    "section": "패키지 검색",
    "text": "패키지 검색\n\n\n\nPyPI\n\n\nPyPI(Python Package Index)에서 파이썬 패키지를 검색할 수 있다.\n\nPyPI (Python Package Index)\n\n\n웹사이트: https://pypi.org\nPyPI는 파이썬 패키지를 검색하고, 설치할 수 있는 공식적인 리포지터리이다. 사용자는 이곳에서 원하는 패키지를 검색하여 설치 방법이나 버전 정보를 확인할 수 있다.\n\n\n기능\n\n\n패키지 이름, 설명, 버전, 라이센스 정보 등을 검색할 수 있다.\n패키지의 문서화, 다운로드 링크, 기타 관련 정보를 제공한다.\n\n\n\nPyPI에서는 pip 명령어를 통해 파이썬 패키지를 손쉽게 설치할 수 있다.\npip install package_name\n위 사이트에서 파이썬 패키지의 자세한 정보를 얻고, 직접 설치할 수도 있다.",
    "crumbs": [
      "파이썬 기초",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>패키지</span>"
    ]
  },
  {
    "objectID": "app_markdown.html",
    "href": "app_markdown.html",
    "title": "참고자료 A: 마크다운",
    "section": "",
    "text": "주요 특징\n마크다운(Markdown)은 간단한 텍스트 형식으로, HTML과 같은 복잡한 문법 없이도 서식 있는 문서를 작성할 수 있게 해주는 경량 마크업 언어입니다. 주로 문서화나 블로그에서 많이 사용되며, 읽기 쉽고 쓰기 쉬운 특성이 있습니다.",
    "crumbs": [
      "참고자료",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>마크다운</span>"
    ]
  },
  {
    "objectID": "app_markdown.html#참고자료",
    "href": "app_markdown.html#참고자료",
    "title": "참고자료 A: 마크다운",
    "section": "참고자료",
    "text": "참고자료\n\nhttps://ko.wikipedia.org/wiki/마크다운",
    "crumbs": [
      "참고자료",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>마크다운</span>"
    ]
  },
  {
    "objectID": "app_csv_json.html",
    "href": "app_csv_json.html",
    "title": "참고자료 B: CSV 파일과 JSON 파일",
    "section": "",
    "text": "CSV 파일\nCSV(Comma-Separated Values) 파일은 데이터를 쉼표(,)로 구분하여 저장하는 텍스트 파일 형식이다. 주로 엑셀(Excel), 데이터베이스, 웹 애플리케이션 등에서 데이터를 저장하고 교환하는 데 사용된다. CSV 파일은 일반적으로 행(row)과 열(column) 형태로 데이터를 저장하며, 각 행은 줄바꿈 문자(\\n), 각 열은 쉼표(,)로 구분된다.\nPython의 csv 모듈을 활용하면 엑셀 파일을 다루듯이 데이터를 쉽게 저장하고 읽을 수 있다.",
    "crumbs": [
      "참고자료",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>CSV 파일과 JSON 파일</span>"
    ]
  },
  {
    "objectID": "app_csv_json.html#csv-파일",
    "href": "app_csv_json.html#csv-파일",
    "title": "참고자료 B: CSV 파일과 JSON 파일",
    "section": "",
    "text": "CSV 관련 함수\n\n\n\n\n\n\n기능\n함수\n\n\n\n\nCSV 파일 쓰기 (리스트)\ncsv.writer(file).writerows(data)\n\n\nCSV 파일 읽기 (리스트)\ncsv.reader(file)\n\n\nCSV 파일 쓰기 (딕셔너리)\ncsv.DictWriter(file, fieldnames=[])\n\n\nCSV 파일 읽기 (딕셔너리)\ncsv.DictReader(file)\n\n\n헤더 추가\nwriter.writeheader()\n\n\nCSV 구분자 변경\ncsv.writer(file, delimiter=\";\")\n\n\n파일 존재 여부 확인\nos.path.exists(\"파일명\")\n\n\n\n\n\nCSV 파일 형식\n이름,나이,직업\n철수,25,학생\n영희,30,개발자\n민수,28,디자이너\n\n첫 번째 행: 헤더(Header) → 열(column)의 이름을 정의\n\n이후 행: 데이터(Data)\n\n\n\nCSV 파일 쓰기\nPython에서 CSV 파일을 저장할 때는 csv 모듈을 사용한다.\nCSV 파일 저장 (writerow())\nimport csv\n\n# 저장할 데이터\ndata = [\n    [\"이름\", \"나이\", \"직업\"],\n    [\"철수\", 25, \"학생\"],\n    [\"영희\", 30, \"개발자\"],\n    [\"민수\", 28, \"디자이너\"]\n]\n\n# CSV 파일로 저장\nwith open(\"data.csv\", \"w\", newline=\"\", encoding=\"utf-8\") as file:\n    writer = csv.writer(file)  # CSV 작성 객체 생성\n    writer.writerows(data)  # 여러 행을 한 번에 저장\n\n\n출력 (data.csv 파일)\n\n이름,나이,직업\n철수,25,학생\n영희,30,개발자\n민수,28,디자이너\n\n\n\ncsv.writer(file): CSV 작성 객체 생성\n\nwriterow(): 한 행씩 저장\n\nwriterows(): 여러 행을 한 번에 저장\n\nnewline=\"\": 줄바꿈 문제를 방지\n\n\n\nCSV 파일 읽기\nCSV 파일을 읽을 때는 csv.reader()를 사용하여 데이터를 리스트로 변환할 수 있다.\nCSV 파일 읽기 (reader())\nimport csv\n\n# CSV 파일 읽기\nwith open(\"data.csv\", \"r\", encoding=\"utf-8\") as file:\n    reader = csv.reader(file)  # CSV 읽기 객체 생성\n    for row in reader:\n        print(row)\n\n출력\n['이름', '나이', '직업']\n['철수', '25', '학생']\n['영희', '30', '개발자']\n['민수', '28', '디자이너']\n\ncsv.reader(file): CSV 읽기 객체 생성\n\n각 행(row)은 리스트 형태로 반환됨\n\n\n\nCSV 파일을 딕셔너리 형태로 저장 및 읽기\n(1) CSV 파일을 딕셔너리로 저장 (DictWriter)\n딕셔너리(dict) 데이터를 CSV 파일로 저장할 수도 있다.\nimport csv\n\n# 딕셔너리 데이터\ndata = [\n    {\"이름\": \"철수\", \"나이\": 25, \"직업\": \"학생\"},\n    {\"이름\": \"영희\", \"나이\": 30, \"직업\": \"개발자\"},\n    {\"이름\": \"민수\", \"나이\": 28, \"직업\": \"디자이너\"}\n]\n\n# CSV 파일 저장\nwith open(\"data_dict.csv\", \"w\", newline=\"\", encoding=\"utf-8\") as file:\n    fieldnames = [\"이름\", \"나이\", \"직업\"]\n    writer = csv.DictWriter(file, fieldnames=fieldnames)\n    \n    writer.writeheader()  # 헤더 저장\n    writer.writerows(data)  # 데이터 저장\n\n출력 (data_dict.csv 파일)\n이름,나이,직업\n철수,25,학생\n영희,30,개발자\n민수,28,디자이너\n\ncsv.DictWriter(file, fieldnames=[]): 딕셔너리를 CSV로 저장하는 객체\n\nwriteheader(): 헤더(Header) 저장\n\nwriterows(): 여러 개의 딕셔너리를 한 번에 저장\n\n(2) CSV 파일을 딕셔너리로 읽기 (DictReader)\nimport csv\n\n# CSV 파일 읽기\nwith open(\"data_dict.csv\", \"r\", encoding=\"utf-8\") as file:\n    reader = csv.DictReader(file)  # 딕셔너리 형태로 읽기\n    for row in reader:\n        print(row)\n\n\n출력\n\n{'이름': '철수', '나이': '25', '직업': '학생'}\n{'이름': '영희', '나이': '30', '직업': '개발자'}\n{'이름': '민수', '나이': '28', '직업': '디자이너'}\n\n\n\ncsv.DictReader(file): CSV 데이터를 딕셔너리(dict) 형태로 변환\n\n각 행이 dict 형태로 반환됨\n\n\n\nCSV 파일 존재 여부 확인 후 읽기\nimport os\nimport csv\n\nfile_name = \"data.csv\"\n\nif os.path.exists(file_name):\n    with open(file_name, \"r\", encoding=\"utf-8\") as file:\n        reader = csv.reader(file)\n        for row in reader:\n            print(row)\nelse:\n    print(\"파일이 존재하지 않습니다.\")\n\n\nCSV 파일에서 특정 열만 읽기\nCSV 파일에서 특정 열(column)만 선택하여 읽을 수도 있다.\nimport csv\n\nwith open(\"data.csv\", \"r\", encoding=\"utf-8\") as file:\n    reader = csv.reader(file)\n    next(reader)  # 헤더 건너뛰기\n    for row in reader:\n        print(row[0])  # '이름' 열만 출력\n\n\nCSV 파일 구분자 변경\n기본적으로 CSV는 쉼표(,)로 구분되지만, 세미콜론(;) 또는 탭(\\t)으로 변경할 수도 있다.\n(1) 세미콜론(;)으로 구분\nwith open(\"data_semicolon.csv\", \"w\", newline=\"\", encoding=\"utf-8\") as file:\n    writer = csv.writer(file, delimiter=\";\")  # 구분자 변경\n    writer.writerows(data)\n(2) 탭(\\t)으로 구분\nwith open(\"data_tab.csv\", \"w\", newline=\"\", encoding=\"utf-8\") as file:\n    writer = csv.writer(file, delimiter=\"\\t\")\n    writer.writerows(data)",
    "crumbs": [
      "참고자료",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>CSV 파일과 JSON 파일</span>"
    ]
  },
  {
    "objectID": "app_csv_json.html#json-파일",
    "href": "app_csv_json.html#json-파일",
    "title": "참고자료 B: CSV 파일과 JSON 파일",
    "section": "JSON 파일",
    "text": "JSON 파일\nJSON(JavaScript Object Notation)은 데이터를 저장하고 전송하기 위한 경량 데이터 형식으로, Python에서는 json 모듈을 사용하여 JSON 파일을 읽고 쓸 수 있다. JSON은 키-값 쌍으로 이루어진 구조이며, Python의 dict와 유사하다. 따라서 Python의 딕셔너리, 리스트 등의 자료형을 JSON 파일로 저장하거나 불러올 수 있다.\n\nJSON 관련 함수\n\n\n\n\n\n\n기능\n함수\n\n\n\n\nPython 객체 → JSON 파일 저장\njson.dump(data, file)\n\n\nJSON 파일 → Python 객체 읽기\njson.load(file)\n\n\nPython 객체 → JSON 문자열 변환\njson.dumps(data)\n\n\nJSON 문자열 → Python 객체 변환\njson.loads(json_string)\n\n\nJSON을 보기 좋게 저장\nindent=4\n\n\n한글 깨짐 방지\nensure_ascii=False\n\n\n\n\nJSON 파일 형식\nJSON 파일은 아래와 같은 형태로 구성된다.\n{\n    \"이름\": \"철수\",\n    \"나이\": 25,\n    \"취미\": [\"축구\", \"독서\", \"영화 감상\"],\n    \"주소\": {\n        \"도시\": \"서울\",\n        \"우편번호\": \"12345\"\n    }\n}\n\n문자열(String): 큰따옴표(\" \")로 감싸야 한다.\n\n숫자(Number): 따옴표 없이 사용한다.\n\n배열(Array, 리스트와 유사): []로 감싸서 사용한다.\n\n객체(Object, 딕셔너리와 유사): {}로 감싸서 키-값 쌍을 사용한다.\n\n\n\nJSON 파일 쓰기\nPython 객체(딕셔너리, 리스트 등)를 JSON 파일로 저장할 수 있다.\nJSON 파일 저장\nimport json\n\n# 저장할 데이터 (Python 딕셔너리)\ndata = {\n    \"이름\": \"철수\",\n    \"나이\": 25,\n    \"취미\": [\"축구\", \"독서\", \"영화 감상\"],\n    \"주소\": {\n        \"도시\": \"서울\",\n        \"우편번호\": \"12345\"\n    }\n}\n\n# JSON 파일로 저장\nwith open(\"data.json\", \"w\", encoding=\"utf-8\") as file:\n    json.dump(data, file, ensure_ascii=False, indent=4)\n출력(data.json 파일 내용)\n{\n    \"이름\": \"철수\",\n    \"나이\": 25,\n    \"취미\": [\"축구\", \"독서\", \"영화 감상\"],\n    \"주소\": {\n        \"도시\": \"서울\",\n        \"우편번호\": \"12345\"\n    }\n}\n\njson.dump(data, file): Python 객체를 JSON 파일로 저장한다.\n\nensure_ascii=False: 한글을 올바르게 저장하기 위해 사용 (기본값 True이면 유니코드 변환됨)\n\nindent=4: JSON 파일을 보기 좋게 정렬\n\n\n\nJSON 파일 읽기\nJSON 파일을 읽어서 Python 객체로 변환할 수 있다.\nJSON 파일 읽기\nimport json\n\n# JSON 파일 열기\nwith open(\"data.json\", \"r\", encoding=\"utf-8\") as file:\n    data = json.load(file)  # JSON을 Python 객체로 변환\n\n# 데이터 출력\nprint(data)\nprint(data[\"이름\"])  # '철수'\nprint(data[\"취미\"])  # ['축구', '독서', '영화 감상']\n\njson.load(file): JSON 파일을 읽어서 Python 객체로 변환한다.\n\nJSON 데이터는 Python의 딕셔너리(dict) 또는 리스트(list)로 변환됨.\n\n\n\nJSON 문자열 변환\n\nJSON 파일이 아닌 문자열 데이터를 다룰 때 json.dumps()와 json.loads()를 사용한다.\n\n(1) Python 객체 → JSON 문자열 (dumps())\n\nimport json\n\ndata = {\"이름\": \"영희\", \"나이\": 30}\n\n# Python 객체를 JSON 문자열로 변환\njson_str = json.dumps(data, ensure_ascii=False, indent=4)\nprint(json_str)\n\n{\n    \"이름\": \"영희\",\n    \"나이\": 30\n}\n\n\n(2) JSON 문자열 → Python 객체 (loads())\n\nimport json\n\njson_str = '{\"이름\": \"영희\", \"나이\": 30}'\n\n# JSON 문자열을 Python 객체로 변환\ndata = json.loads(json_str)\nprint(data[\"이름\"])  # '영희'\n\n영희\n\n\n\n\nJSON 데이터 활용 예제\n(1) 리스트 데이터를 JSON으로 저장하고 읽기\nimport json\n\n# 리스트 데이터\nfruits = [\"사과\", \"바나나\", \"포도\"]\n\n# JSON 파일로 저장\nwith open(\"fruits.json\", \"w\", encoding=\"utf-8\") as file:\n    json.dump(fruits, file, ensure_ascii=False)\n\n# JSON 파일 읽기\nwith open(\"fruits.json\", \"r\", encoding=\"utf-8\") as file:\n    fruits_list = json.load(file)\n\nprint(fruits_list)  # ['사과', '바나나', '포도']\n(2) JSON 파일이 존재하는지 확인 후 읽기\n파일이 존재하는지 확인한 후 JSON을 읽으면 오류를 방지할 수 있다.\nimport os\nimport json\n\nfile_name = \"data.json\"\n\nif os.path.exists(file_name):  # 파일 존재 여부 확인\n    with open(file_name, \"r\", encoding=\"utf-8\") as file:\n        data = json.load(file)\n    print(data)\nelse:\n    print(\"파일이 존재하지 않습니다.\")",
    "crumbs": [
      "참고자료",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>CSV 파일과 JSON 파일</span>"
    ]
  }
]